var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LibAWSCRT","category":"page"},{"location":"#LibAWSCRT","page":"Home","title":"LibAWSCRT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAWSCRT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LibAWSCRT]","category":"page"},{"location":"#LibAWSCRT.aws_array_list_comparator_fn","page":"Home","title":"LibAWSCRT.aws_array_list_comparator_fn","text":"Prototype for a comparator function for sorting elements.\n\na and b should be cast to pointers to the element type held in the list before being dereferenced. The function should compare the elements and return a positive number if a > b, zero if a = b, and a negative number if a < b.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_atomic_var","page":"Home","title":"LibAWSCRT.aws_atomic_var","text":"aws_atomic_var\n\nstruct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated with atomics methods defined in this header.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_auth_errors","page":"Home","title":"LibAWSCRT.aws_auth_errors","text":"aws_auth_errors\n\nAuth-specific error codes\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_auth_log_subject","page":"Home","title":"LibAWSCRT.aws_auth_log_subject","text":"aws_auth_log_subject\n\nAuth-specific logging subjects\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_byte_buf","page":"Home","title":"LibAWSCRT.aws_byte_buf","text":"aws_byte_buf\n\nRepresents a length-delimited binary string or buffer. If byte buffer points to constant memory or memory that should otherwise not be freed by this struct, set allocator to NULL and free function will be a no-op.\n\nThis structure used to define the output for all functions that write to a buffer.\n\nNote that this structure allocates memory at the buffer pointer only. The struct itself does not get dynamically allocated and must be either maintained or copied to avoid losing access to the memory.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_byte_cursor","page":"Home","title":"LibAWSCRT.aws_byte_cursor","text":"aws_byte_cursor\n\nRepresents a movable pointer within a larger binary string or buffer.\n\nThis structure is used to define buffers for reading.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_byte_predicate_fn","page":"Home","title":"LibAWSCRT.aws_byte_predicate_fn","text":"Signature for function argument to trim APIs\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_cache","page":"Home","title":"LibAWSCRT.aws_cache","text":"aws_cache\n\nBase stucture for caches, used the linked hash table implementation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_channel_on_protocol_negotiated_fn","page":"Home","title":"LibAWSCRT.aws_channel_on_protocol_negotiated_fn","text":"If ALPN is being used this function will be invoked by the channel once an ALPN message is received. The returned channel_handler will be added to, and managed by, the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_channel_options","page":"Home","title":"LibAWSCRT.aws_channel_options","text":"aws_channel_options\n\nArgs for creating a new channel. event_loop to use for IO and tasks. on_setup_completed will be invoked when the setup process is finished It will be executed in the event loop's thread. on_shutdown_completed will be executed upon channel shutdown.\n\nenable_read_back_pressure toggles whether or not back pressure will be applied in the channel. Leave this option off unless you're using something like reactive-streams, since it is a slight throughput penalty.\n\nUnless otherwise specified all functions for channels and channel slots must be executed within that channel's event-loop's thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_cli_options_subcommand_fn","page":"Home","title":"LibAWSCRT.aws_cli_options_subcommand_fn","text":"Invoked when a subcommand is encountered. argc and argv[] begins at the command encountered. command_name is the name of the command being handled.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_cli_subcommand_dispatch","page":"Home","title":"LibAWSCRT.aws_cli_subcommand_dispatch","text":"aws_cli_subcommand_dispatch\n\nDispatch table to dispatch cli commands from. command_name should be the exact string for the command you want to handle from the command line.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_client_bootstrap","page":"Home","title":"LibAWSCRT.aws_client_bootstrap","text":"aws_client_bootstrap\n\naws_client_bootstrap handles creation and setup of channels that communicate via socket with a specific endpoint.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_client_bootstrap_on_channel_event_fn","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_on_channel_event_fn","text":"Generic event function for channel lifecycle events.\n\nCallbacks are provided for: (1) Channel creation (2) Channel setup - If TLS is being used, this function is called once the socket has connected, the channel has been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If TLS negotiation fails, this function will be called with the corresponding error code. If TLS is not being used, this function is called once the socket has connected and the channel has been initialized. (3) Channel shutdown\n\nThese callbacks are always invoked within the thread of the event-loop that the channel is assigned to.\n\nThis function does NOT always imply \"success\" – if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an error condition occurred.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_client_bootstrap_options","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_options","text":"aws_client_bootstrap_options\n\naws_client_bootstrap creation options.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_client_bootstrap_shutdown_complete_fn","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_shutdown_complete_fn","text":"Called after client bootstrap has been completely cleaned up, after its last refcount is released.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_cognito_identity_provider_token_pair","page":"Home","title":"LibAWSCRT.aws_cognito_identity_provider_token_pair","text":"aws_cognito_identity_provider_token_pair\n\nA (string) pair defining an identity provider and a valid login token sourced from it.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider","page":"Home","title":"LibAWSCRT.aws_credentials_provider","text":"aws_credentials_provider\n\nA baseclass for credentials providers. A credentials provider is an object that has an asynchronous query function for retrieving AWS credentials.\n\nRef-counted. Thread-safe.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_cached_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_cached_options","text":"aws_credentials_provider_cached_options\n\nConfiguration options for a provider that functions as a caching decorator. Credentials sourced through this provider will be cached within it until their expiration time. When the cached credentials expire, new credentials will be fetched when next queried.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_chain_default_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_chain_default_options","text":"aws_credentials_provider_chain_default_options\n\nConfiguration options for the default credentials provider chain.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_chain_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_chain_options","text":"aws_credentials_provider_chain_options\n\nConfiguration options for a provider that queries, in order, a list of providers. This provider uses the first set of credentials successfully queried. Providers are queried one at a time; a provider is not queried until the preceding provider has failed to source credentials.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_cognito_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_cognito_options","text":"aws_credentials_provider_cognito_options\n\nConfiguration options needed to create a Cognito-based Credentials Provider\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_delegate_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_delegate_options","text":"aws_credentials_provider_delegate_options\n\nConfiguration options for the delegate credentials provider.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_environment_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_environment_options","text":"aws_credentials_provider_environment_options\n\nConfiguration options for a provider that returns credentials based on environment variable values\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_imds_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_imds_options","text":"aws_credentials_provider_imds_options\n\nConfiguration options for the provider that sources credentials from ec2 instance metadata\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_process_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_process_options","text":"aws_credentials_provider_process_options\n\nConfiguration options for the process credentials provider\n\nThe process credentials provider sources credentials from running a command or process. The command to run is sourced from a profile in the AWS config file, using the standard profile selection rules. The profile key the command is read from is \"credential_process.\" E.g.: [default] credential_process=/opt/amazon/bin/my-credential-fetcher –argsA=abc On successfully running the command, the output should be a json data with the following format: { \"Version\": 1, \"AccessKeyId\": \"accesskey\", \"SecretAccessKey\": \"secretAccessKey\" \"SessionToken\": \"....\", \"Expiration\": \"2019-05-29T00:21:43Z\" } Version here identifies the command output format version.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_profile_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_profile_options","text":"aws_credentials_provider_profile_options\n\nConfiguration options for a provider that sources credentials from the aws config and credentials files (by default ~/.aws/config and ~/.aws/credentials)\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_static_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_static_options","text":"aws_credentials_provider_static_options\n\nConfiguration options for a provider that returns a fixed set of credentials\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_sts_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_sts_options","text":"aws_credentials_provider_sts_options\n\nConfiguration options for the STS credentials provider\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_sts_web_identity_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_sts_web_identity_options","text":"aws_credentials_provider_sts_web_identity_options\n\nConfiguration options for the STS web identity provider\n\nSts with web identity credentials provider sources a set of temporary security credentials for users who have been authenticated in a mobile or web application with a web identity provider. Example providers include Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID Connect-compatible identity provider like Elastic Kubernetes Service https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html The required parameters used in the request (region, roleArn, sessionName, tokenFilePath) are automatically resolved by SDK from envrionment variables or config file. ––––––––––––––––––––––––––––––––––––––––- | Parameter | Environment Variable Name | Config File Property Name | ––––––––––––––––––––––––––––––––––––––––– | region | AWS_DEFAULT_REGION | region | | role_arn | AWS_ROLE_ARN | role_arn | | role_session_name | AWS_ROLE_SESSION_NAME | role_session_name | | token_file_path | AWS_WEB_IDENTITY_TOKEN_FILE | web_identity_token_file | |––––––––––––––––––––––––––––––––––––––––|\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_credentials_provider_x509_options","page":"Home","title":"LibAWSCRT.aws_credentials_provider_x509_options","text":"aws_credentials_provider_x509_options\n\nConfiguration options for the X509 credentials provider\n\nThe x509 credentials provider sources temporary credentials from AWS IoT Core using TLS mutual authentication. See details: https://docs.aws.amazon.com/iot/latest/developerguide/authorizing-direct-aws.html An end to end demo with detailed steps can be found here: https://aws.amazon.com/blogs/security/how-to-eliminate-the-need-for-hardcoded-aws-credentials-in-devices-by-using-the-aws-iot-credentials-provider/\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_common_statistics_category","page":"Home","title":"LibAWSCRT.aws_crt_common_statistics_category","text":"aws_crt_common_statistics_category\n\nThe common-specific range of the aws_crt_statistics_category cross-library enum.\n\nThis enum functions as an RTTI value that lets statistics handler's interpret (via cast) a specific statistics structure if the RTTI value is understood.\n\nCommon doesn't have any statistics structures presently, so its range is essentially empty.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_base","page":"Home","title":"LibAWSCRT.aws_crt_statistics_base","text":"aws_crt_statistics_base\n\nPattern-struct that functions as a base \"class\" for all statistics structures. To conform to the pattern, a statistics structure must have its first member be the category. In that case it becomes \"safe\" to cast from aws_crt_statistics_base to the specific statistics structure based on the category value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_handler","page":"Home","title":"LibAWSCRT.aws_crt_statistics_handler","text":"aws_crt_statistics_handler\n\nBase structure for all statistics handler implementations.\n\nA statistics handler is an object that listens to a stream of polymorphic (via the category RTTI enum) statistics structures emitted from some arbitrary source. In the initial implementation, statistics handlers are primarily attached to channels, where they monitor IO throughput and state data (from channel handlers) to determine a connection's health.\n\nStatistics handlers are a generalization of the timeout and bandwidth filters that are often associated with SDK network connections. Configurable, default implementations are defined at the protocol level (http, etc...) where they can be attached at connection (channel) creation time.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_handler_vtable","page":"Home","title":"LibAWSCRT.aws_crt_statistics_handler_vtable","text":"aws_crt_statistics_handler_vtable\n\nVtable for functions that all statistics handlers must implement\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_http1_channel","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http1_channel","text":"aws_crt_statistics_http1_channel\n\nA statistics struct for http handlers. Tracks the actual amount of time that incoming and outgoing requests are waiting for their IO to complete.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_sample_interval","page":"Home","title":"LibAWSCRT.aws_crt_statistics_sample_interval","text":"aws_crt_statistics_sample_interval\n\nThe start and end time, in milliseconds-since-epoch, that a set of statistics was gathered over.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_socket","page":"Home","title":"LibAWSCRT.aws_crt_statistics_socket","text":"aws_crt_statistics_socket\n\nSocket channel handler statistics record\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_crt_statistics_tls","page":"Home","title":"LibAWSCRT.aws_crt_statistics_tls","text":"aws_crt_statistics_tls\n\nTls channel handler statistics record\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_custom_key_op_handler","page":"Home","title":"LibAWSCRT.aws_custom_key_op_handler","text":"aws_custom_key_op_handler\n\nThe custom key operation that is used when performing a mutual TLS handshake. This can be extended to provide custom private key operations, like PKCS11 or similar.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_custom_key_op_handler_vtable","page":"Home","title":"LibAWSCRT.aws_custom_key_op_handler_vtable","text":"aws_custom_key_op_handler_vtable\n\nvtable for aws_custom_key_op_handler.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_on_message_received_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_on_message_received_fn","text":"Invoked when an aws_event_stream_message is encountered. If the message parsed successfully, message will be non-null and error_code will be AWS_ERROR_SUCCESS. Otherwise message will be null and error_code will represent the error that was encountered. Note that any case that error_code was not AWS_OP_SUCCESS, the channel also shuts down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_on_message_written_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_on_message_written_fn","text":"Invoked when an aws_event_stream_message is flushed to the IO interface. When error_code is AWS_ERROR_SUCCESS the write happened successfuly. Regardless, message is held from the aws_event_stream_channel_handler_write_message() call and should likely be freed in this callback. If error_code is non-zero, the channel will be shutdown immediately after this callback returns.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_header_received_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_header_received_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a header is encountered. 'header' is not yours. Copy the data you want from it if your scope extends beyond your callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_on_complete_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_on_complete_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a message decoding is complete and crc is verified.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_on_error_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_on_error_fn","text":"Called by aws_aws_event_stream_streaming_decoder when an error is encountered. The decoder is not in a good state for usage after this callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_prelude_received_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_prelude_received_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a new message has arrived. The prelude will contain metadata about the message. At this point no headers or payload have been received. prelude is copyable.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_process_on_payload_segment_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_process_on_payload_segment_fn","text":"Called by aws_aws_event_stream_streaming_decoder when payload data has been received. 'data' doesn't belong to you, so copy the data if it is needed beyond the scope of your callback. final_segment == 1 indicates the current data is the last payload buffer for that message.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_protocol_message_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_protocol_message_fn","text":"Invoked when a non-stream level message is received on a connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_message_flush_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_message_flush_fn","text":"Invoked whenever a message has been flushed to the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_on_connection_setup_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_on_connection_setup_fn","text":"Invoked when a connection attempt completes.\n\nIf the attempt was unsuccessful, the error_code will be non-zero and the connection pointer will be NULL, and aws_event_stream_rpc_client_on_connection_shutdown_fn will not be invoked.\n\nIf the attempt was successful, error_code will be 0 and the connection pointer will be valid. You must call aws_event_stream_rpc_client_connection_acquire() to prevent the pointer's memory from being destroyed before you are ready. When you are completely done with the connection pointer you must call aws_event_stream_rpc_client_connection_release() or its memory will leak. aws_event_stream_rpc_client_on_connection_shutdown_fn will be invoked when the network connection has closed. If you are done with the connection, but it is still open, you must call aws_aws_event_stream_rpc_client_close() or network connection will remain open, even if you call release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_on_connection_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_on_connection_shutdown_fn","text":"Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_stream_continuation_closed_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_stream_continuation_closed_fn","text":"Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection shuts down and deletes the continuation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_stream_continuation_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_stream_continuation_fn","text":"Invoked when a connection receives a message on an existing stream. message_args contains the message data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_protocol_message_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_protocol_message_fn","text":"Invoked when a non-stream level message is received on a connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_message_flush_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_message_flush_fn","text":"Invoked whenever a message has been flushed to the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_on_connection_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_on_connection_shutdown_fn","text":"Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_on_incoming_stream_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_on_incoming_stream_fn","text":"Invoked when a new stream has been received on the connection. If you return AWS_OP_SUCCESS (0), You must fill in the fields for continuation options or the program will assert and exit.\n\nA failure path MUST leave the ref count of the continuation alone.\n\nA success path should probably take a ref which will leave the continuation (assuming no other interference) at two AFTER creation is complete: 1 for the connection's continuation table, and one for the callback recipient which is presumably tracking it as well.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_on_listener_destroy_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_on_listener_destroy_fn","text":"(Optional). Invoked when the listener has been successfully shutdown (after the last ref count release).\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_on_new_connection_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_on_new_connection_fn","text":"Invoked when a new connection is received on a server listener. If you return AWS_OP_SUCCESS, You must fill in the fields for connection_options or the program will assert and exit.\n\nIf error_code is non-zero, an error occurred upon setting up the channel and connection will be NULL. Otherwise, connection is non-null. If you intend to seat a pointer to connection, you MUST call aws_event_stream_rpc_server_connection_acquire() and when you're finished with the connection you MUST call aws_event_stream_server_connection_release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_stream_continuation_closed_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_stream_continuation_closed_fn","text":"Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection shutsdown and deletes the continuation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_stream_continuation_fn","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_stream_continuation_fn","text":"Invoked when a connection receives a message on an existing stream. message_args contains the message data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_exponential_backoff_jitter_mode","page":"Home","title":"LibAWSCRT.aws_exponential_backoff_jitter_mode","text":"aws_exponential_backoff_jitter_mode\n\nJitter mode for exponential backoff.\n\nFor a great writeup on these options see: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_exponential_backoff_retry_options","page":"Home","title":"LibAWSCRT.aws_exponential_backoff_retry_options","text":"aws_exponential_backoff_retry_options\n\nOptions for exponential backoff retry strategy. el_group must be set, any other option, if set to 0 will signify \"use defaults\"\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_future_callback_fn","page":"Home","title":"LibAWSCRT.aws_future_callback_fn","text":"Completion callback for aws_future<T>\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_generate_random_fn","page":"Home","title":"LibAWSCRT.aws_generate_random_fn","text":"Optional function to supply your own generate random implementation\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_hash_callback_destroy_fn","page":"Home","title":"LibAWSCRT.aws_hash_callback_destroy_fn","text":"Prototype for a hash table key or value destructor function pointer.\n\nThis function is used to destroy elements in the hash table when the table is cleared or cleaned up.\n\nNote that functions which remove individual elements from the hash table provide options of whether or not to invoke the destructors on the key and value of a removed element.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_hash_callback_eq_fn","page":"Home","title":"LibAWSCRT.aws_hash_callback_eq_fn","text":"Prototype for a hash table equality check function pointer.\n\nThis type is usually used for a function that compares two hash table keys, but note that the same type is used for a function that compares two hash table values in aws_hash_table_eq.\n\nEquality functions used in a hash table must be reflexive (i.e., a == b if and only if b == a), and must be consistent with the hash function in use.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_hash_element","page":"Home","title":"LibAWSCRT.aws_hash_element","text":"aws_hash_element\n\nRepresents an element in the hash table. Various operations on the hash table may provide pointers to elements stored within the hash table; generally, calling code may alter value, but must not alter key (or any information used to compute key's hash code).\n\nPointers to elements within the hash are invalidated whenever an operation which may change the number of elements in the hash is invoked (i.e. put, delete, clear, and clean_up), regardless of whether the number of elements actually changes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_hash_fn","page":"Home","title":"LibAWSCRT.aws_hash_fn","text":"Prototype for a key hashing function pointer.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_host_resolver_vtable","page":"Home","title":"LibAWSCRT.aws_host_resolver_vtable","text":"aws_host_resolver_vtable\n\nshould you absolutely disdain the default implementation, feel free to implement your own.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http1_chunk_extension","page":"Home","title":"LibAWSCRT.aws_http1_chunk_extension","text":"aws_http1_chunk_extension\n\nHTTP/1.1 chunk extension for chunked encoding. Note that the underlying strings are not owned by the byte cursors.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http1_chunk_options","page":"Home","title":"LibAWSCRT.aws_http1_chunk_options","text":"aws_http1_chunk_options\n\nEncoding options for an HTTP/1.1 chunked transfer encoding chunk.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http1_connection_options","page":"Home","title":"LibAWSCRT.aws_http1_connection_options","text":"aws_http1_connection_options\n\nOptions specific to HTTP/1.x connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http1_stream_write_chunk_complete_fn","page":"Home","title":"LibAWSCRT.aws_http1_stream_write_chunk_complete_fn","text":"Invoked when the data of an outgoing HTTP/1.1 chunk is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nParameters\n\nstream: HTTP-stream this chunk was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this chunk. Any other non-zero error code indicates a problem with this particular chunk's data.\nuser_data: User data for this chunk.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_connection_options","page":"Home","title":"LibAWSCRT.aws_http2_connection_options","text":"aws_http2_connection_options\n\nOptions specific to HTTP/2 connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_on_change_settings_complete_fn","page":"Home","title":"LibAWSCRT.aws_http2_on_change_settings_complete_fn","text":"Invoked when the HTTP/2 settings change is complete. If connection setup successfully this will always be invoked whether settings change successfully or unsuccessfully. If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the settings and the change has been applied. If error_code is non-zero, then a connection error occurred before the settings could be fully acknowledged and applied. This is always invoked on the connection's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_on_goaway_received_fn","page":"Home","title":"LibAWSCRT.aws_http2_on_goaway_received_fn","text":"Invoked when an HTTP/2 GOAWAY frame is received from peer. Implies that the peer has initiated shutdown, or encountered a serious error. Once a GOAWAY is received, no further streams may be created on this connection.\n\nParameters\n\nhttp2_connection: This HTTP/2 connection.\nlast_stream_id: ID of the last locally-initiated stream that peer will process. Any locally-initiated streams with a higher ID are ignored by peer, and are safe to retry on another connection.\nhttp2_error_code: The HTTP/2 error code (RFC-7540 section 7) sent by peer. enum [awshttp2error_code](@ref) lists official codes.\ndebug_data: The debug data sent by peer. It can be empty. (NOTE: this data is only valid for the lifetime of the callback. Make a deep copy if you wish to keep it longer.)\nuser_data: User-data passed to the callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_on_ping_complete_fn","page":"Home","title":"LibAWSCRT.aws_http2_on_ping_complete_fn","text":"Invoked when the HTTP/2 PING completes, whether peer has acknowledged it or not. If error_code is AWS_ERROR_SUCCESS (0), then the peer has acknowledged the PING and round_trip_time_ns will be the round trip time in nano seconds for the connection. If error_code is non-zero, then a connection error occurred before the PING get acknowledgment and round_trip_time_ns will be useless in this case.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_on_remote_settings_change_fn","page":"Home","title":"LibAWSCRT.aws_http2_on_remote_settings_change_fn","text":"Invoked when new HTTP/2 settings from peer have been applied. Settings_array is the array of aws_http2_settings that contains all the settings we just changed in the order we applied (the order settings arrived). Num_settings is the number of elements in that array.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_stream_manager_on_stream_acquired_fn","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_on_stream_acquired_fn","text":"Always invoked asynchronously when the stream was created, successfully or not. When stream is NULL, error code will be set to indicate what happened. If there is a stream returned, you own the stream completely. Invoked on the same thread as other callback of the stream, which will be the thread of the connection, ideally. If there is no connection made, the callback will be invoked from a sperate thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_stream_manager_options","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_options","text":"aws_http2_stream_manager_options\n\nHTTP/2 stream manager configuration struct.\n\nContains all of the configuration needed to create an http2 connection as well as connection manager under the hood.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_stream_manager_shutdown_complete_fn","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_shutdown_complete_fn","text":"Invoked asynchronously when the stream manager has been shutdown completely. Never invoked when aws_http2_stream_manager_new failed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_stream_write_data_complete_fn","page":"Home","title":"LibAWSCRT.aws_http2_stream_write_data_complete_fn","text":"Invoked when the data of an outgoing HTTP2 data frame is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nParameters\n\nstream: HTTP2-stream this write was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this write. Any other non-zero error code indicates a problem with this particular write's data.\nuser_data: User data for this write.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http2_stream_write_data_options","page":"Home","title":"LibAWSCRT.aws_http2_stream_write_data_options","text":"aws_http2_stream_write_data_options\n\nEncoding options for manual H2 data frame writes\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_client_connection_options","page":"Home","title":"LibAWSCRT.aws_http_client_connection_options","text":"aws_http_client_connection_options\n\nOptions for creating an HTTP client connection. Initialize with AWS_HTTP_CLIENT_CONNECTION_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_connection_monitoring_options","page":"Home","title":"LibAWSCRT.aws_http_connection_monitoring_options","text":"aws_http_connection_monitoring_options\n\nConfiguration options for connection monitoring\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_header","page":"Home","title":"LibAWSCRT.aws_http_header","text":"aws_http_header\n\nA lightweight HTTP header struct. Note that the underlying strings are not owned by the byte cursors.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_header_block","page":"Home","title":"LibAWSCRT.aws_http_header_block","text":"aws_http_header_block\n\nHeader block type. INFORMATIONAL: Header block for 1xx informational (interim) responses. MAIN: Main header block sent with request or response. TRAILING: Headers sent after the body of a request or response.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_header_compression","page":"Home","title":"LibAWSCRT.aws_http_header_compression","text":"aws_http_header_compression\n\nControls whether a header's strings may be compressed by encoding the index of strings in a cache, rather than encoding the literal string.\n\nThis setting has no effect on HTTP/1.x connections. On HTTP/2 connections this controls HPACK behavior. See RFC-7541 Section 7.1 for security considerations.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_make_request_options","page":"Home","title":"LibAWSCRT.aws_http_make_request_options","text":"aws_http_make_request_options\n\nOptions for creating a stream which sends a request from the client and receives a response from the server.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_manager_metrics","page":"Home","title":"LibAWSCRT.aws_http_manager_metrics","text":"aws_http_manager_metrics\n\nMetrics for logging and debugging purpose.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_message_transform_complete_fn","page":"Home","title":"LibAWSCRT.aws_http_message_transform_complete_fn","text":"Function to invoke when a message transformation completes. This function MUST be invoked or the application will soft-lock. message and complete_ctx must be the same pointers provided to the aws_http_message_transform_fn. error_code should should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_message_transform_fn","page":"Home","title":"LibAWSCRT.aws_http_message_transform_fn","text":"A function that may modify a request or response before it is sent. The transformation may be asynchronous or immediate. The user MUST invoke the complete_fn when transformation is complete or the application will soft-lock. When invoking the complete_fn, pass along the message and complete_ctx provided here and an error code. The error code should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_client_connection_setup_fn","page":"Home","title":"LibAWSCRT.aws_http_on_client_connection_setup_fn","text":"Invoked when connect completes.\n\nIf unsuccessful, error_code will be set, connection will be NULL, and the on_shutdown callback will never be invoked.\n\nIf successful, error_code will be 0 and connection will be valid. The user is now responsible for the connection and must call aws_http_connection_release() when they are done with it.\n\nThe connection uses one event-loop thread to do all its work. The thread invoking this callback will be the same thread that invokes all future callbacks for this connection and its streams.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_client_connection_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_http_on_client_connection_shutdown_fn","text":"Invoked when the connection has finished shutting down. Never invoked if on_setup failed. This is always invoked on connection's event-loop thread. Note that the connection is not completely done until on_shutdown has been invoked AND aws_http_connection_release() has been called.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_incoming_body_fn","page":"Home","title":"LibAWSCRT.aws_http_on_incoming_body_fn","text":"Called repeatedly as body data is received. The data must be copied immediately if you wish to preserve it. This is always invoked on the HTTP connection's event-loop thread.\n\nNote that, if the connection is using manual_window_management then the window size has shrunk by the amount of body data received. If the window size reaches 0 no further data will be received. Increment the window size with aws_http_stream_update_window().\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return AWS_OP_ERR to indicate failure and cancel the stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_incoming_header_block_done_fn","page":"Home","title":"LibAWSCRT.aws_http_on_incoming_header_block_done_fn","text":"Invoked when the incoming header block of this type(informational/main/trailing) has been completely read. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return AWS_OP_ERR to indicate failure and cancel the stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_incoming_headers_fn","page":"Home","title":"LibAWSCRT.aws_http_on_incoming_headers_fn","text":"Invoked repeatedly times as headers are received. At this point, aws_http_stream_get_incoming_response_status() can be called for the client. And aws_http_stream_get_incoming_request_method() and aws_http_stream_get_incoming_request_uri() can be called for the server. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return AWS_OP_ERR to indicate failure and cancel the stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_incoming_request_done_fn","page":"Home","title":"LibAWSCRT.aws_http_on_incoming_request_done_fn","text":"Invoked when request has been completely read. This is always invoked on the HTTP connection's event-loop thread.\n\nReturn AWS_OP_SUCCESS to continue processing the stream. Return AWS_OP_ERR to indicate failure and cancel the stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_incoming_request_fn","page":"Home","title":"LibAWSCRT.aws_http_on_incoming_request_fn","text":"Invoked at the start of an incoming request. To process the request, the user must create a request handler stream and return it to the connection. If NULL is returned, the request will not be processed and the last error will be reported as the reason for failure.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_stream_complete_fn","page":"Home","title":"LibAWSCRT.aws_http_on_stream_complete_fn","text":"Invoked when request/response stream is completely destroyed. This may be invoked synchronously when aws_http_stream_release() is called. This is invoked even if the stream is never activated.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_stream_destroy_fn","page":"Home","title":"LibAWSCRT.aws_http_on_stream_destroy_fn","text":"Invoked when request/response stream destroy completely. This can be invoked within the same thead who release the refcount on http stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_on_stream_metrics_fn","page":"Home","title":"LibAWSCRT.aws_http_on_stream_metrics_fn","text":"Invoked right before request/response stream is complete to report the tracing metrics for aws_http_stream. This may be invoked synchronously when aws_http_stream_release() is called. This is invoked even if the stream is never activated. See aws_http_stream_metrics for details.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_authentication_type","page":"Home","title":"LibAWSCRT.aws_http_proxy_authentication_type","text":"aws_http_proxy_authentication_type\n\n\\deprecated - Supported proxy authentication modes. Superceded by proxy strategy.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_connection_type","page":"Home","title":"LibAWSCRT.aws_http_proxy_connection_type","text":"aws_http_proxy_connection_type\n\nSupported proxy connection types\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_connect_on_incoming_headers_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_connect_on_incoming_headers_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the headers in the response to the most recent CONNECT request as they arrive.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_get_challenge_token_sync_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_get_challenge_token_sync_fn","text":"Synchronous (for now) callback function to fetch a token used in modifying CONNECT request. Includes a (byte string) context intended to be used as part of a challenge-response flow.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_get_token_sync_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_get_token_sync_fn","text":"Synchronous (for now) callback function to fetch a token used in modifying CONNECT requests\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_http_request_forward_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_http_request_forward_fn","text":"Proxy negotiation logic must call this function to forward the potentially-mutated request back to the proxy connection logic.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_http_request_transform_async_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_http_request_transform_async_fn","text":"User-supplied transform callback which implements the proxy request flow and ultimately, across all execution pathways, invokes either the terminate function or the forward function appropriately.\n\nFor tunneling proxy connections, this request flow transform only applies to the CONNECT stage of proxy connection establishment.\n\nFor forwarding proxy connections, this request flow transform applies to every single http request that goes out on the connection.\n\nForwarding proxy connections cannot yet support a truly async request transform without major surgery on http stream creation, so for now, we split into an async version (for tunneling proxies) and a separate synchronous version for forwarding proxies. Also forwarding proxies are a kind of legacy dead-end in some sense.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiation_terminate_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiation_terminate_fn","text":"Proxy negotiation logic must call this function to indicate an unsuccessful outcome\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_connect_on_incoming_body_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_connect_on_incoming_body_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the body of the response to the most recent CONNECT request.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_connect_status_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_connect_status_fn","text":"Tunneling proxy connections only. A callback that lets the negotiator examine the status code of the response to the most recent CONNECT request.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_forwarding_vtable","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_forwarding_vtable","text":"aws_http_proxy_negotiator_forwarding_vtable\n\nVtable for forwarding-based proxy negotiators\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_tunnelling_vtable","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_tunnelling_vtable","text":"aws_http_proxy_negotiator_tunnelling_vtable\n\nVtable for tunneling-based proxy negotiators\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_options","page":"Home","title":"LibAWSCRT.aws_http_proxy_options","text":"aws_http_proxy_options\n\nOptions for http proxy server usage\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_create_negotiator_fn","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_create_negotiator_fn","text":"\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_server","page":"Home","title":"LibAWSCRT.aws_http_server","text":"A listening socket which accepts incoming HTTP connections, creating a server-side aws_http_connection to handle each one.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_server_connection_options","page":"Home","title":"LibAWSCRT.aws_http_server_connection_options","text":"aws_http_server_connection_options\n\nOptions for configuring a server-side aws_http_connection. Initialized with AWS_HTTP_SERVER_CONNECTION_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_server_options","page":"Home","title":"LibAWSCRT.aws_http_server_options","text":"aws_http_server_options\n\nOptions for creating an HTTP server. Initialize with AWS_HTTP_SERVER_OPTIONS_INIT to set default values.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_statistics_observer_fn","page":"Home","title":"LibAWSCRT.aws_http_statistics_observer_fn","text":"Callback invoked on each statistics sample.\n\nconnection_nonce is unique to each connection for disambiguation of each callback per connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_status_code","page":"Home","title":"LibAWSCRT.aws_http_status_code","text":"aws_http_status_code\n\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved. SPDX-License-Identifier: Apache-2.0.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_stream_metrics","page":"Home","title":"LibAWSCRT.aws_http_stream_metrics","text":"aws_http_stream_metrics\n\nTracing metrics for aws_http_stream. Data maybe not be available if the data of stream was never sent/received before it completes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_http_stream_write_complete_fn","page":"Home","title":"LibAWSCRT.aws_http_stream_write_complete_fn","text":"Invoked when the data stream of an outgoing HTTP write operation is no longer in use. This is always invoked on the HTTP connection's event-loop thread.\n\nParameters\n\nstream: HTTP-stream this write operation was submitted to.\nerror_code: If error_code is AWS_ERROR_SUCCESS (0), the data was successfully sent. Any other error_code indicates that the HTTP-stream is in the process of terminating. If the error_code is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED, the stream's termination has nothing to do with this write operation. Any other non-zero error code indicates a problem with this particular write operation's data.\nuser_data: User data for this write operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_code","page":"Home","title":"LibAWSCRT.aws_huffman_code","text":"aws_huffman_code\n\nRepresents an encoded code\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_decoder","page":"Home","title":"LibAWSCRT.aws_huffman_decoder","text":"aws_huffman_decoder\n\nStructure used for persistent decoding. Allows for reading from or writing to incomplete buffers.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_encoder","page":"Home","title":"LibAWSCRT.aws_huffman_encoder","text":"aws_huffman_encoder\n\nStructure used for persistent encoding. Allows for reading from or writing to incomplete buffers.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_symbol_coder","page":"Home","title":"LibAWSCRT.aws_huffman_symbol_coder","text":"aws_huffman_symbol_coder\n\nStructure used to define how symbols are encoded and decoded\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_symbol_decoder_fn","page":"Home","title":"LibAWSCRT.aws_huffman_symbol_decoder_fn","text":"Function used to decode a code into a symbol\n\nParameters\n\nbits:[in] The bits to attept to decode a symbol from\nsymbol:[out] The symbol found. Do not write to if no valid symbol found\nuserdata:[in] Optional userdata (aws_huffman_symbol_coder.userdata)\n\nReturns\n\nThe number of bits read from bits\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_huffman_symbol_encoder_fn","page":"Home","title":"LibAWSCRT.aws_huffman_symbol_encoder_fn","text":"Function used to encode a single symbol to an aws_huffman_code\n\nParameters\n\nsymbol:[in] The symbol to encode\nuserdata:[in] Optional userdata (aws_huffman_symbol_coder.userdata)\n\nReturns\n\nThe code representing the symbol. If this symbol is not recognized, return a code with num_bits set to 0.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_imds_client","page":"Home","title":"LibAWSCRT.aws_imds_client","text":"AWS EC2 Metadata Client is used to retrieve AWS EC2 Instance Metadata info.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_imds_client_options","page":"Home","title":"LibAWSCRT.aws_imds_client_options","text":"aws_imds_client_options\n\nConfiguration options when creating an imds client\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_imds_client_shutdown_options","page":"Home","title":"LibAWSCRT.aws_imds_client_shutdown_options","text":"aws_imds_client_shutdown_options\n\nOptional callback and user data to be invoked when an imds client has fully shut down\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_imds_iam_profile","page":"Home","title":"LibAWSCRT.aws_imds_iam_profile","text":"aws_imds_iam_profile\n\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_imds_instance_info","page":"Home","title":"LibAWSCRT.aws_imds_instance_info","text":"aws_imds_instance_info\n\nBlock of per-instance EC2-specific data\n\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_input_stream","page":"Home","title":"LibAWSCRT.aws_input_stream","text":"aws_input_stream\n\nBase class for input streams. Note: when you implement one input stream, the ref_count needs to be initialized to clean up the resource when reaches to zero.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_get_ip_list_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_get_ip_list_fn","text":"User callback type invoked to retrieve an ip list custom metric\n\nList provided will already be initialized and caller must push items into the list of type (struct aws_string *). String allocated that are placed into the list are destroyed by the defender task after it is done with the list.\n\nreturns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_get_number_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_get_number_fn","text":"User callback type invoked to retrieve a number type custom metric.\n\nreturns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_get_number_list_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_get_number_list_fn","text":"User callback type invoked to retrieve a number list custom metric\n\nList provided will already be initialized and caller must push items into the list of type double.\n\nreturns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_get_string_list_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_get_string_list_fn","text":"User callback type invoked to retrieve a string list custom metric\n\nList provided will already be initialized and caller must push items into the list of type (struct aws_string *). String allocated that are placed into the list are destroyed by the defender task after it is done with the list.\n\nreturns: AWS_OP_SUCCESS if the custom metric was successfully added to the task config\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_publish_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_publish_fn","text":"Callback to invoke when the defender task needs to \"publish\" a report. Useful to override default MQTT publish behavior, for testing report outputs\n\nNotes: * This function should not perform blocking IO. * This function should copy the report if it needs to hold on to the memory for an IO operation\n\nreturns: AWS_OP_SUCCESS if the user callback wants to consider the publish failed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_report_accepted_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_report_accepted_fn","text":"User callback type invoked when the subscribed device defender topic for accepted reports receives a message.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_report_rejected_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_report_rejected_fn","text":"User callback type invoked when a report fails to submit.\n\nThere are two possibilities for failed submission: 1. The MQTT client fails to publish the message and returns an error code. In this scenario, the client_error_code will be a value other than AWS_ERROR_SUCCESS. The rejected_message_payload parameter will be NULL. 2. After a successful publish, a reply is received on the respective MQTT rejected topic with a message. In this scenario, the client_error_code will be AWS_ERROR_SUCCESS, and rejected_message_payload will contain the payload of the rejected message received.\n\nParameters\n\nrejected_message_payload:[in] response payload recieved from rejection topic\nuserdata:[in] callback userdata\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_task_canceled_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_task_canceled_fn","text":"User callback type invoked when DeviceDefender task has completed cancellation. After a request to stop the task, this signals the completion of the cancellation and no further user callbacks will be invoked.\n\nParameters\n\nuserdata:[in] callback userdata\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_iotdevice_defender_task_failure_fn","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_task_failure_fn","text":"General callback handler for the task to report that an error occurred while running the DeviceDefender task. Error codes can only go so far in describing where/when and how the failure occur so the errors here may best communicate where/when and the how of the underlying call should be found in log output\n\nParameters\n\nis_task_stopped:[in] flag indicating whether or not the task is unable to continue running\nerror_code:[in] error code describing the nature of the failure\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_json_on_member_encountered_const_fn","page":"Home","title":"LibAWSCRT.aws_json_on_member_encountered_const_fn","text":"callback for iterating members of an object Iteration can be controlled as follows: - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) - continue iteration without error - return AWS_OP_SUCCESS and out_continue is set to false - stop iteration without error - return AWS_OP_ERR - stop iteration with error\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_json_on_value_encountered_const_fn","page":"Home","title":"LibAWSCRT.aws_json_on_value_encountered_const_fn","text":"callback for iterating values of an array. Iteration can be controlled as follows: - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) - continue iteration without error - return AWS_OP_SUCCESS and out_continue is set to false - stop iteration without error - return AWS_OP_ERR - stop iteration with error\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_linked_hash_table","page":"Home","title":"LibAWSCRT.aws_linked_hash_table","text":"aws_linked_hash_table\n\nSimple linked hash table. Preserves insertion order, and can be iterated in insertion order.\n\nYou can also change the order safely without altering the shape of the underlying hash table.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_linked_hash_table_node","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_node","text":"aws_linked_hash_table_node\n\nLinked-List node stored in the table. This is the node type that will be returned in aws_linked_hash_table_get_iteration_list().\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_log_level","page":"Home","title":"LibAWSCRT.aws_log_level","text":"aws_log_level\n\nControls what log calls pass through the logger and what log calls get filtered out. If a log level has a value of X, then all log calls using a level <= X will appear, while those using a value > X will not occur.\n\nYou can filter both dynamically (by setting the log level on the logger object) or statically (by defining AWS_STATIC_LOG_LEVEL to be an appropriate integer module-wide). Statically filtered log calls will be completely compiled out but require a rebuild if you want to get more detail about what's happening.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_log_subject_t","page":"Home","title":"LibAWSCRT.aws_log_subject_t","text":"Log subject is a way of designating the topic of logging.\n\nThe general idea is to support a finer-grained approach to log level control. The primary use case is for situations that require more detailed logging within a specific domain, where enabling that detail globally leads to an untenable flood of information.\n\nFor example, enable TRACE logging for tls-related log statements (handshake binary payloads), but only WARN logging everywhere else (because http payloads would blow up the log files).\n\nLog subject is an enum similar to aws error: each library has its own value-space and someone is responsible for registering the value <-> string connections.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_logger_standard_options","page":"Home","title":"LibAWSCRT.aws_logger_standard_options","text":"aws_logger_standard_options\n\nOptions for aws_logger_init_standard(). Set filename to open a file for logging and close it when the logger cleans up. Set file to use a file that is already open, such as stderr or stdout.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_logger_vtable","page":"Home","title":"LibAWSCRT.aws_logger_vtable","text":"aws_logger_vtable\n\nWe separate the log level function from the log call itself so that we can do the filter check in the macros (see below)\n\nBy doing so, we make it so that the variadic format arguments are not even evaluated if the filter check does not succeed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_client_on_connection_closed_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_client_on_connection_closed_fn","text":"Called if the connection to the server is closed by user request Note: Currently the \"data\" argument is always NULL, but this may change in the future if additional data is needed to be sent.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_client_on_connection_complete_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_client_on_connection_complete_fn","text":"Called when a connection attempt is completed, either in success or error.\n\nIf error code is AWS_ERROR_SUCCESS, then a CONNACK has been received from the server and return_code and session_present contain the values received. If error_code is not AWS_ERROR_SUCCESS, it refers to the internal error that occurred during connection, and return_code and session_present are invalid.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_client_on_connection_resumed_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_client_on_connection_resumed_fn","text":"Called when a connection to the server is resumed (if clean_session is true, calling aws_mqtt_resubscribe_existing_topics is suggested)\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_client_on_disconnect_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_client_on_disconnect_fn","text":"Called when a connection is closed, right before any resources are deleted\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_client_publish_received_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_client_publish_received_fn","text":"Called when a publish message is received.\n\nParameters\n\nconnection:[in] The connection object\ntopic:[in] The information channel to which the payload data was published.\npayload:[in] The payload data.\ndup:[in] DUP flag. If true, this might be re-delivery of an earlier attempt to send the message.\nqos:[in] Quality of Service used to deliver the message.\nretain:[in] Retain flag. If true, the message was sent as a result of a new subscription being made by the client.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_connection_operation_statistics","page":"Home","title":"LibAWSCRT.aws_mqtt_connection_operation_statistics","text":"aws_mqtt_connection_operation_statistics\n\nContains some simple statistics about the current state of the connection's queue of operations\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_connection_options","page":"Home","title":"LibAWSCRT.aws_mqtt_connection_options","text":"aws_mqtt_connection_options\n\nhost_name The server name to connect to. This resource may be freed immediately on return. port The port on the server to connect to client_id The clientid to place in the CONNECT packet. socket_options The socket options to pass to the aws_client_bootstrap functions. This is copied into the connection tls_options TLS settings to use when opening a connection. This is copied into the connection Pass NULL to connect without TLS (NOT RECOMMENDED) clean_session True to discard all server session data and start fresh keep_alive_time_secs The keep alive value to place in the CONNECT PACKET, a PING will automatically be sent at this interval as well. If you specify 0, defaults will be used and a ping will be sent once per 20 minutes. This duration must be longer than ping_timeout_ms. ping_timeout_ms Network connection is re-established if a ping response is not received within this amount of time (milliseconds). If you specify 0, a default value of 3 seconds is used. Alternatively, tcp keep-alive may be away to accomplish this in a more efficient (low-power) scenario, but keep-alive options may not work the same way on every platform and OS version. This duration must be shorter than keep_alive_time_secs. protocol_operation_timeout_ms Timeout when waiting for the response to some operation requires response by protocol. Set to zero to disable timeout. Otherwise, the operation will fail with error AWS_ERROR_MQTT_TIMEOUT if no response is received within this amount of time after the packet is written to the socket. The timer is reset if the connection is interrupted. It applied to PUBLISH (QoS>0) and UNSUBSCRIBE now. Note: While the MQTT 3 specification states that a broker MUST respond, some brokers are known to ignore publish packets in exceptional circumstances (e.g. AWS IoT Core will not respond if the publish quota is exceeded). on_connection_complete The callback to fire when the connection attempt completes user_data Passed to the userdata param of on_connection_complete\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_op_complete_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_op_complete_fn","text":"Callback called when a request roundtrip is complete (QoS0 immediately, QoS1 on PUBACK, QoS2 on PUBCOMP). Either succeed or not\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_suback_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_suback_fn","text":"Called when a single-topic subscription request is complete. Note: If the qos value is AWS_MQTT_QOS_FAILURE, then the subscription was rejected by the broker.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_suback_multi_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_suback_multi_fn","text":"Called when a multi-topic subscription request is complete. Note: If any topic_suback's qos value is AWS_MQTT_QOS_FAILURE, then that topic subscription was rejected by the broker.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_topic_subscription","page":"Home","title":"LibAWSCRT.aws_mqtt_topic_subscription","text":"aws_mqtt_topic_subscription\n\nPassed to subscribe() and suback callbacks\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_transform_websocket_handshake_complete_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_transform_websocket_handshake_complete_fn","text":"Function to invoke when the websocket handshake request transformation completes. This function MUST be invoked or the application will soft-lock.\n\nrequest and complete_ctx must be the same pointers provided to the aws_mqtt_transform_websocket_handshake_fn. error_code should should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_transform_websocket_handshake_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_transform_websocket_handshake_fn","text":"Function that may transform the websocket handshake request. Called each time a websocket connection is attempted.\n\nThe default request uses path \"/mqtt\". All required headers are present, plus the optional header \"Sec-WebSocket-Protocol: mqtt\".\n\nThe user MUST invoke the complete_fn when transformation is complete or the application will soft-lock. When invoking the complete_fn, pass along the request and complete_ctx provided here and an error code. The error code should be AWS_ERROR_SUCCESS if transformation was successful, otherwise pass a different AWS_ERROR_X value.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_userdata_cleanup_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_userdata_cleanup_fn","text":"Function called on cleanup of a userdata.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_mqtt_validate_websocket_handshake_fn","page":"Home","title":"LibAWSCRT.aws_mqtt_validate_websocket_handshake_fn","text":"Function that may accept or reject a websocket handshake response. Called each time a valid websocket connection is established.\n\nAll required headers have been checked already (ex: \"Sec-Websocket-Accept\"),\n\nReturn AWS_OP_SUCCESS to accept the connection or AWS_OP_ERR to stop the connection attempt.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_off_t","page":"Home","title":"LibAWSCRT.aws_off_t","text":"\\deprecated Use int64_t instead for offsets in public APIs.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_on_directory_entry","page":"Home","title":"LibAWSCRT.aws_on_directory_entry","text":"Invoked during calls to aws_directory_traverse() as an entry is encountered. entry will contain the parsed directory entry info.\n\nReturn true to continue the traversal, or alternatively, if you have a reason to abort the traversal, return false.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_on_host_resolved_result_fn","page":"Home","title":"LibAWSCRT.aws_on_host_resolved_result_fn","text":"Invoked once an address has been resolved for host. The type in host_addresses is struct aws_host_address (by-value). The caller does not own this memory and you must copy the host address before returning from this function if you plan to use it later. For convenience, we've provided the aws_host_address_copy() and aws_host_address_clean_up() functions.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_pipe_on_readable_fn","page":"Home","title":"LibAWSCRT.aws_pipe_on_readable_fn","text":"Callback for when the pipe is readable (edge-triggered), or an error has occurred. Afer subscribing, the callback is invoked when the pipe has data to read, or the pipe has an error. The readable callback is invoked again any time the user reads all data, and then more data arrives. Note that it will not be invoked again if the pipe still has unread data when more data arrives. error_code of AWS_ERROR_SUCCESS indicates a readable event, and otherwise contains the value of the error. user_data corresponds to the user_data passed into aws_pipe_subscribe_to_read_events(). This callback is always invoked on the read-end's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_pipe_on_write_completed_fn","page":"Home","title":"LibAWSCRT.aws_pipe_on_write_completed_fn","text":"Callback for when the asynchronous aws_pipe_write() operation has either completed or failed. write_end will be NULL if this callback is invoked after the the write-end has been cleaned up, this does not necessarily mean that the write operation failed. error_code will be AWS_ERROR_SUCCESS if all data was written, or a code corresponding to the error. src_buffer corresponds to the buffer passed into aws_pipe_write() user_data corresponds to the user_data passed into aws_pipe_write(). This callback is always invoked on the write-end's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_pkcs11_lib_behavior","page":"Home","title":"LibAWSCRT.aws_pkcs11_lib_behavior","text":"aws_pkcs11_lib_behavior\n\nControls how aws_pkcs11_lib calls C_Initialize() and C_Finalize() on the PKCS#11 library.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_pkcs11_lib_options","page":"Home","title":"LibAWSCRT.aws_pkcs11_lib_options","text":"aws_pkcs11_lib_options\n\nOptions for aws_pkcs11_lib_new()\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_profile_source_type","page":"Home","title":"LibAWSCRT.aws_profile_source_type","text":"aws_profile_source_type\n\nThe profile specification has rule exceptions based on what file the profile collection comes from.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_resolve_host_implementation_fn","page":"Home","title":"LibAWSCRT.aws_resolve_host_implementation_fn","text":"Function signature for configuring your own resolver (the default just uses getaddrinfo()). The type in output_addresses is struct aws_host_address (by-value). We assume this function blocks, hence this absurdly complicated design.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_retry_strategy_on_retry_ready_fn","page":"Home","title":"LibAWSCRT.aws_retry_strategy_on_retry_ready_fn","text":"Invoked after a successful call to aws_retry_strategy_schedule_retry(). This function will always be invoked if and only if aws_retry_strategy_schedule_retry() returns AWS_OP_SUCCESS. It will never be invoked synchronously from aws_retry_strategy_schedule_retry(). After attempting the operation, either call aws_retry_strategy_schedule_retry() with an aws_retry_error_type or call aws_retry_token_record_success() and then release the token via. aws_retry_token_release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_retry_strategy_on_retry_token_acquired_fn","page":"Home","title":"LibAWSCRT.aws_retry_strategy_on_retry_token_acquired_fn","text":"Invoked upon the acquisition, or failure to acquire a retry token. This function will always be invoked if and only if aws_retry_strategy_acquire_retry_token() returns AWS_OP_SUCCESS. It will never be invoked synchronously from aws_retry_strategy_acquire_retry_token(). Token will always be NULL if error_code is non-zero, and vice-versa. If token is non-null, it will have a reference count of 1, and you must call aws_retry_token_release() on it later. See the comments for aws_retry_strategy_on_retry_ready_fn for more info.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_ring_buffer","page":"Home","title":"LibAWSCRT.aws_ring_buffer","text":"aws_ring_buffer\n\nLockless ring buffer implementation that is thread safe assuming a single thread acquires and a single thread releases. For any other use case (other than the single-threaded use-case), you must manage thread-safety manually.\n\nAlso, a very important note: release must happen in the same order as acquire. If you do not your application, and possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be poisoned for generations with fragments of what is left of your radioactive corrupted memory.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_finish_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_finish_fn","text":"Invoked when the entire meta request execution is complete.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_headers_callback_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_headers_callback_fn","text":"Invoked to provide response headers received during execution of the meta request, both for success and error HTTP status codes.\n\nReturn AWS_OP_SUCCESS to continue processing the request.\n\nReturn aws_raise_error(E) to cancel the request. The error you raise will be reflected in [awss3metarequestresult](@ref).error\\_code. If you're not sure which error to raise, use AWS_ERROR_S3_CANCELED.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_options","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_options","text":"aws_s3_meta_request_options\n\nOptions for a new meta request, ie, file transfer that will be handled by the high performance client.\n\nThere are several ways to pass the request's body data: 1) If the data is already in memory, set the body-stream on message. 2) If the data is on disk, set send_filepath for best performance. 3) If the data will be be produced in asynchronous chunks, set send_async_stream.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_progress","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_progress","text":"aws_s3_meta_request_progress\n\nInformation sent in the meta_request progress callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_progress_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_progress_fn","text":"Invoked to report progress of a meta-request. For PutObject, progress refers to bytes uploaded. For CopyObject, progress refers to bytes copied. For GetObject, progress refers to bytes downloaded. For anything else, progress refers to response body bytes received.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_receive_body_callback_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_receive_body_callback_fn","text":"Invoked to provide the response body as it is received.\n\nNote: If you set enable_read_backpressure true on the S3 client, you must maintain the flow-control window. The flow-control window shrinks as you receive body data via this callback. Whenever the flow-control window reaches 0 you will stop downloading data. Use aws_s3_meta_request_increment_read_window() to increment the window and keep data flowing. Maintain a larger window to keep up a high download throughput, parts cannot download in parallel unless the window is large enough to hold multiple parts. Maintain a smaller window to limit the amount of data buffered in memory.\n\nIf manual_window_management is false, you do not need to maintain the flow-control window. No back-pressure is applied and data arrives as fast as possible.\n\nReturn AWS_OP_SUCCESS to continue processing the request.\n\nReturn aws_raise_error(E) to cancel the request. The error you raise will be reflected in [awss3metarequestresult](@ref).error\\_code. If you're not sure which error to raise, use AWS_ERROR_S3_CANCELED.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_telemetry_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_telemetry_fn","text":"Invoked to report the telemetry of the meta request once a single request finishes. Invoked from the thread of the connection that request made from. Note: *metrics is only valid for the duration of the callback. If you need to keep it around, use aws_s3_request_metrics_acquire\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_type","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_type","text":"aws_s3_meta_request_type\n\nA Meta Request represents a group of generated requests that are being done on behalf of the original request. For example, one large GetObject request can be transformed into a series of ranged GetObject requests that are executed in parallel to improve throughput.\n\nThe aws_s3_meta_request_type is a hint of transformation to be applied.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_meta_request_upload_review_fn","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_upload_review_fn","text":"Optional callback, for you to review an upload before it completes. For example, you can review each part's checksum and fail the upload if you do not agree with them.\n\nReturn AWS_OP_SUCCESS to continue processing the request.\n\nReturn aws_raise_error(E) to cancel the request. The error you raise will be reflected in [awss3metarequestresult](@ref).error\\_code. If you're not sure which error to raise, use AWS_ERROR_S3_CANCELED.\n\nWARNING: This feature is experimental/unstable. At this time, the callback is only invoked for multipart upload (when Content-Length is above the multipart_upload_threshold, or Content-Length not specified).\n\nParameters\n\nmeta_request: pointer to the aws_s3_meta_request of the upload.\ninfo: Detailed info about the upload.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_request_type","page":"Home","title":"LibAWSCRT.aws_s3_request_type","text":"aws_s3_request_type\n\nThe type of S3 request made. Used by metrics.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_upload_part_review","page":"Home","title":"LibAWSCRT.aws_s3_upload_part_review","text":"aws_s3_upload_part_review\n\nInfo about a single part, for you to review before the upload completes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_s3_upload_review","page":"Home","title":"LibAWSCRT.aws_s3_upload_review","text":"aws_s3_upload_review\n\nInfo for you to review before an upload completes.\n\nWARNING: This feature is experimental/unstable. At this time, review is only available for multipart upload (when Content-Length is above the multipart_upload_threshold, or Content-Length not specified).\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunnel_connection_view","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_connection_view","text":"aws_secure_tunnel_connection_view\n\nRead-only snapshot of a Secure Tunnel Connection Completion Data\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunnel_message_received_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_message_received_fn","text":"Signature of callback to invoke on received messages\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunnel_message_type","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_message_type","text":"aws_secure_tunnel_message_type\n\nType of IoT Secure Tunnel message. Enum values match IoT Secure Tunneling Local Proxy V3 Websocket Protocol Guide values.\n\nhttps://github.com/aws-samples/aws-iot-securetunneling-localproxy/blob/main/V3WebSocketProtocolGuide.md\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunnel_message_view","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_message_view","text":"aws_secure_tunnel_message_view\n\nRead-only snapshot of a Secure Tunnel Message\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunnel_options","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_options","text":"aws_secure_tunnel_options\n\nBasic Secure Tunnel configuration struct.\n\nContains connection properties for the creation of a Secure Tunnel\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_connection_complete_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_connection_complete_fn","text":"Signature of callback to invoke on fully established connection to Secure Tunnel Service\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_connection_reset_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_connection_reset_fn","text":"Signature of callback to invoke on a connection id stream being reset\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_connection_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_connection_shutdown_fn","text":"Signature of callback to invoke on shutdown of connection to Secure Tunnel Service\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_connection_start_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_connection_start_fn","text":"Signature of callback to invoke on start of a connection id stream\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_send_message_complete_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_send_message_complete_fn","text":"Signature of callback to invoke on completion of an outbound message\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_session_reset_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_session_reset_fn","text":"Signature of callback to invoke on session reset recieved from the Secure Tunnel Service\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_stopped_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_stopped_fn","text":"Signature of callback to invoke on Secure Tunnel reaching a STOPPED state\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_stream_reset_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_stream_reset_fn","text":"Signature of callback to invoke on a stream being reset\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_stream_start_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_stream_start_fn","text":"Signature of callback to invoke on the start of a stream\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_secure_tunneling_on_termination_complete_fn","page":"Home","title":"LibAWSCRT.aws_secure_tunneling_on_termination_complete_fn","text":"Signature of callback to invoke on termination completion of the Native Secure Tunnel Client\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_server_bootstrap","page":"Home","title":"LibAWSCRT.aws_server_bootstrap","text":"aws_server_bootstrap\n\naws_server_bootstrap manages listening sockets, creating and setting up channels to handle each incoming connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_server_bootstrap_on_accept_channel_setup_fn","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_on_accept_channel_setup_fn","text":"If TLS is being used, this function is called once the socket has received an incoming connection, the channel has been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If TLS negotiation fails, this function will be called with the corresponding error code.\n\nIf TLS is not being used, this function is called once the socket has received an incoming connection and the channel has been initialized.\n\nThis function is always called within the thread of the event-loop that the new channel is assigned to upon success.\n\nOn failure, the channel might not be assigned to an event loop yet, and will thus be invoked on the listener's event-loop thread.\n\nThis function does NOT mean \"success\", if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an error condition occurred.\n\nIf an error occurred, you do not need to shutdown the channel. The aws_channel_client_shutdown_callback will be invoked once the channel has finished shutting down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_server_bootstrap_on_accept_channel_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_on_accept_channel_shutdown_fn","text":"Once the channel shuts down, this function will be invoked within the thread of the event-loop that the channel is assigned to.\n\nNote: this function is only invoked if the channel was successfully setup, e.g. aws_server_bootstrap_on_accept_channel_setup_fn() was invoked without an error code.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_server_bootstrap_on_server_listener_destroy_fn","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_on_server_listener_destroy_fn","text":"Once the server listener socket is finished destroying, and all the existing connections are closed, this fuction will be invoked.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_server_socket_channel_bootstrap_options","page":"Home","title":"LibAWSCRT.aws_server_socket_channel_bootstrap_options","text":"aws_server_socket_channel_bootstrap_options\n\nArguments to setup a server socket listener which will also negotiate and configure TLS. This creates a socket listener bound to host and 'port' using socket options options, and TLS options tls_options. incoming_callback will be invoked once an incoming channel is ready for use and TLS is finished negotiating, or if an error is encountered. shutdown_callback will be invoked once the channel has shutdown. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down. Immediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that listener is assigned to.\n\nUpon shutdown of your application, you'll want to call aws_server_bootstrap_destroy_socket_listener with the return value from this function.\n\nThe socket type in options must be AWS_SOCKET_STREAM if tls_options is set. DTLS is not currently supported for tls.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signable","page":"Home","title":"LibAWSCRT.aws_signable","text":"aws_signable\n\nSignable is a generic interface for any kind of object that can be cryptographically signed.\n\nLike signing_result, the signable interface presents\n\n(1) Properties - A set of key-value pairs (2) Property Lists - A set of named key-value pair lists\n\nas well as\n\n(3) A message payload modeled as a stream\n\nWhen creating a signable \"subclass\" the query interface should map to retrieving the properties of the underlying object needed by signing algorithms that can operate on it.\n\nAs an example, if a signable implementation wrapped an http request, you would query request elements like method and uri from the property interface, headers would be queried via the property list interface, and the request body would map to the payload stream.\n\nString constants that map to agreed on keys for particular signable types (\"METHOD\", \"URI\", \"HEADERS\", etc...) are exposed in appropriate header files.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signature_type","page":"Home","title":"LibAWSCRT.aws_signature_type","text":"aws_signature_type\n\nWhat sort of signature should be computed from the signable?\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signed_body_header_type","page":"Home","title":"LibAWSCRT.aws_signed_body_header_type","text":"aws_signed_body_header_type\n\nControls if signing adds a header containing the canonical request's body value\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_algorithm","page":"Home","title":"LibAWSCRT.aws_signing_algorithm","text":"aws_signing_algorithm\n\nWhat version of the AWS signing process should we use.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_complete_fn","page":"Home","title":"LibAWSCRT.aws_signing_complete_fn","text":"Gets called by the signing function when the signing is complete.\n\nNote that result will be destroyed after this function returns, so either copy it, or do all necessary adjustments inside the callback.\n\nWhen performing event or chunk signing, you will need to copy out the signature value in order to correctly configure the signable that wraps the event or chunk you want signed next. The signature is found in the \"signature\" property on the signing result. This value must be added as the \"previous-signature\" property on the next signable.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_config_aws","page":"Home","title":"LibAWSCRT.aws_signing_config_aws","text":"aws_signing_config_aws\n\nA configuration structure for use in AWS-related signing. Currently covers sigv4 only, but is not required to.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_config_base","page":"Home","title":"LibAWSCRT.aws_signing_config_base","text":"aws_signing_config_base\n\nAll signing configuration structs must match this by having the config_type member as the first member.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_config_type","page":"Home","title":"LibAWSCRT.aws_signing_config_type","text":"aws_signing_config_type\n\nA primitive RTTI indicator for signing configuration structs\n\nThere must be one entry per config structure type and it's a fatal error to put the wrong value in the \"config_type\" member of your config structure.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_signing_result","page":"Home","title":"LibAWSCRT.aws_signing_result","text":"aws_signing_result\n\nA structure for tracking all the signer-requested changes to a signable. Interpreting these changes is signing-algorithm specific.\n\nA signing result consists of\n\n(1) Properties - A set of key-value pairs (2) Property Lists - A set of named key-value pair lists\n\nThe hope is that these two generic structures are enough to model the changes required by any generic message-signing algorithm.\n\nNote that the key-value pairs of a signing_result are different types (but same intent) as the key-value pairs in the signable interface. This is because the signing result stands alone and owns its own copies of all values, whereas a signable can wrap an existing object and thus use non-owning references (like byte cursors) if appropriate to its implementation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_socket_channel_bootstrap_options","page":"Home","title":"LibAWSCRT.aws_socket_channel_bootstrap_options","text":"aws_socket_channel_bootstrap_options\n\nSocket-based channel creation options.\n\nbootstrap - configs name resolution and which event loop group the connection will be seated into host_name - host to connect to; if a dns address, will be resolved prior to connecting port - port to connect to socket_options - socket properties, including type (tcp vs. udp vs. unix domain) and connect timeout. TLS connections are currently restricted to tcp (AWS_SOCKET_STREAM) only. tls_options - (optional) tls context to apply after connection establishment. If NULL, the connection will not be protected by TLS. creation_callback - (optional) callback invoked when the channel is first created. This is always right after the connection was successfully established. Does NOT get called if the initial connect failed. setup_callback - callback invoked once the channel is ready for use and TLS has been negotiated or if an error is encountered shutdown_callback - callback invoked once the channel has shutdown. enable_read_back_pressure - controls whether or not back pressure will be applied in the channel user_data - arbitrary data to pass back to the various callbacks requested_event_loop - if set, the connection will be placed on the requested event loop rather than one chosen internally from the bootstrap's associated event loop group. It is an error to pass in an event loop that is not associated with the bootstrap's event loop group.\n\nImmediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that the new channel is assigned to.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_socket_on_accept_result_fn","page":"Home","title":"LibAWSCRT.aws_socket_on_accept_result_fn","text":"Called by a listening socket when either an incoming connection has been received or an error occurred.\n\nIn the normal use-case, this function will be called multiple times over the lifetime of a single listening socket. new_socket is already connected and initialized, and is using the same options and allocator as the listening socket. A user may want to call aws_socket_set_options() on the new socket if different options are desired.\n\nnew_socket is not yet assigned to an event-loop. The user should call aws_socket_assign_to_event_loop() before performing IO operations.\n\nWhen error_code is AWS_ERROR_SUCCESS, new_socket is the recently accepted connection. If error_code is non-zero, an error occurred and you should aws_socket_close() the socket.\n\nDo not call aws_socket_clean_up() from this callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_socket_on_connection_result_fn","page":"Home","title":"LibAWSCRT.aws_socket_on_connection_result_fn","text":"Called in client mode when an outgoing connection has succeeded or an error has occurred. If the connection was successful error_code will be AWS_ERROR_SUCCESS and the socket has already been assigned to the event loop specified in aws_socket_connect().\n\nIf an error occurred error_code will be non-zero.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_socket_on_readable_fn","page":"Home","title":"LibAWSCRT.aws_socket_on_readable_fn","text":"Callback for when socket is either readable (edge-triggered) or when an error has occurred. If the socket is readable, error_code will be AWS_ERROR_SUCCESS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_socket_on_write_completed_fn","page":"Home","title":"LibAWSCRT.aws_socket_on_write_completed_fn","text":"Callback for when the data passed to a call to aws_socket_write() has either completed or failed. On success, error_code will be AWS_ERROR_SUCCESS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_task_fn","page":"Home","title":"LibAWSCRT.aws_task_fn","text":"A scheduled function.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_thread_join_strategy","page":"Home","title":"LibAWSCRT.aws_thread_join_strategy","text":"aws_thread_join_strategy\n\nSpecifies the join strategy used on an aws_thread, which in turn controls whether or not a thread participates in the managed thread system. The managed thread system provides logic to guarantee a join on all participating threads at the cost of laziness (the user cannot control when joins happen).\n\nManual - thread does not participate in the managed thread system; any joins must be done by the user. This is the default. The user must call aws_thread_clean_up(), but only after any desired join operation has completed. Not doing so will cause the windows handle to leak.\n\nManaged - the managed thread system will automatically perform a join some time after the thread's run function has completed. It is an error to call aws_thread_join on a thread configured with the managed join strategy. The managed thread system will call aws_thread_clean_up() on the thread after the background join has completed.\n\nAdditionally, an API exists, aws_thread_join_all_managed(), which blocks and returns when all outstanding threads with the managed strategy have fully joined. This API is useful for tests (rather than waiting for many individual signals) and program shutdown or DLL unload. This API is automatically invoked by the common library clean up function. If the common library clean up is called from a managed thread, this will cause deadlock.\n\nLazy thread joining is done only when threads finish their run function or when the user calls aws_thread_join_all_managed(). This means it may be a long time between thread function completion and the join being applied, but the queue of unjoined threads is always one or fewer so there is no critical resource backlog.\n\nCurrently, only event loop group async cleanup and host resolver threads participate in the managed thread system. Additionally, event loop threads will increment and decrement the pending join count (they are manually joined internally) in order to have an accurate view of internal thread usage and also to prevent failure to release an event loop group fully from allowing aws_thread_join_all_managed() from running to completion when its intent is such that it should block instead.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_ctx_pkcs11_options","page":"Home","title":"LibAWSCRT.aws_tls_ctx_pkcs11_options","text":"aws_tls_ctx_pkcs11_options\n\nThis struct exists as a graceful way to pass many arguments when calling init-with-pkcs11 functions on aws_tls_ctx_options (this also makes it easy to introduce optional arguments in the future). Instances of this struct should only exist briefly on the stack.\n\nInstructions for binding this to high-level languages: - Python: The members of this struct should be the keyword args to the init-with-pkcs11 functions. - JavaScript: This should be an options map passed to init-with-pkcs11 functions. - Java: This should be an options class passed to init-with-pkcs11 functions. - C++: Same as Java\n\nNotes on integer types: PKCS#11 uses unsigned long for IDs, handles, etc but we expose them as uint64_t in public APIs. We do this because sizeof(long) is inconsistent across platform/arch/language (ex: always 64bit in Java, always 32bit in C on Windows, matches CPU in C on Linux and Apple). By using uint64_t in our public API, we can keep the careful bounds-checking all in one place, instead of expecting each high-level language binding to get it just right.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_hash_algorithm","page":"Home","title":"LibAWSCRT.aws_tls_hash_algorithm","text":"aws_tls_hash_algorithm\n\nThe hash algorithm of a TLS private key operation. Any custom private key operation handlers are expected to perform operations on the input TLS data using the correct hash algorithm or fail the operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_key_operation","page":"Home","title":"LibAWSCRT.aws_tls_key_operation","text":"A struct containing all of the data needed for a private key operation when making a mutual TLS connection. This struct contains the data that needs to be operated on, like performing a sign operation or a decrypt operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_key_operation_type","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_type","text":"aws_tls_key_operation_type\n\nThe TLS private key operation that needs to be performed by a custom private key operation handler when making a connection using mutual TLS.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_negotiation_status","page":"Home","title":"LibAWSCRT.aws_tls_negotiation_status","text":"aws_tls_negotiation_status\n\nAn enum for the current state of tls negotiation within a tls channel handler\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_on_data_read_fn","page":"Home","title":"LibAWSCRT.aws_tls_on_data_read_fn","text":"Only used if the TLS handler is the last handler in the channel. This allows you to read any data that was read and decrypted by the handler. If you have application protocol channel handlers, this function is not necessary and certainly not recommended.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_on_error_fn","page":"Home","title":"LibAWSCRT.aws_tls_on_error_fn","text":"Invoked when an error occurs in the TLS state machine AFTER the handshake has completed. This function should only be used in conjunction with the rules of aws_tls_on_data_read_fn.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_on_negotiation_result_fn","page":"Home","title":"LibAWSCRT.aws_tls_on_negotiation_result_fn","text":"Invoked upon completion of the TLS handshake. If successful error_code will be AWS_OP_SUCCESS, otherwise the negotiation failed and immediately after this function is invoked, the channel will be shutting down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_tls_signature_algorithm","page":"Home","title":"LibAWSCRT.aws_tls_signature_algorithm","text":"aws_tls_signature_algorithm\n\nThe signature of a TLS private key operation. Any custom private key operation handlers are expected to perform operations on the input TLS data using the correct signature algorithm or fail the operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_uri","page":"Home","title":"LibAWSCRT.aws_uri","text":"aws_uri\n\nData representing a URI. uri_str is always allocated and filled in. The other portions are merely storing offsets into uri_str.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_uri_builder_options","page":"Home","title":"LibAWSCRT.aws_uri_builder_options","text":"aws_uri_builder_options\n\nArguments for building a URI instance. All members must be initialized before passing them to aws_uri_init().\n\nquery_string and query_params are exclusive to each other. If you set query_string, do not prepend it with '?'\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_uri_param","page":"Home","title":"LibAWSCRT.aws_uri_param","text":"aws_uri_param\n\nkey/value pairs for a query string. If the query fragment was not in format key=value, the fragment value will be stored in key\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket","page":"Home","title":"LibAWSCRT.aws_websocket","text":"A websocket connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_client_connection_options","page":"Home","title":"LibAWSCRT.aws_websocket_client_connection_options","text":"aws_websocket_client_connection_options\n\nOptions for creating a websocket client connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_incoming_frame","page":"Home","title":"LibAWSCRT.aws_websocket_incoming_frame","text":"aws_websocket_incoming_frame\n\nData about an incoming frame. See RFC-6455 Section 5.2.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_connection_setup_data","page":"Home","title":"LibAWSCRT.aws_websocket_on_connection_setup_data","text":"aws_websocket_on_connection_setup_data\n\nData passed to the websocket on_connection_setup callback.\n\nAn error_code of zero indicates that setup was completely successful. You own the websocket pointer now and must call aws_websocket_release() when you are done with it. You can inspect the response headers, if you're interested.\n\nA non-zero error_code indicates that setup failed. The websocket pointer will be NULL. If the server sent a response, you can inspect its status-code, headers, and body, but this data will NULL if setup failed before a full response could be received. If you wish to persist data from the response make a deep copy. The response data becomes invalid once the callback completes.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_connection_setup_fn","page":"Home","title":"LibAWSCRT.aws_websocket_on_connection_setup_fn","text":"Called when websocket setup is complete. Called exactly once on the websocket's event-loop thread. See aws_websocket_on_connection_setup_data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_connection_shutdown_fn","page":"Home","title":"LibAWSCRT.aws_websocket_on_connection_shutdown_fn","text":"Called when the websocket has finished shutting down. Called once on the websocket's event-loop thread if setup succeeded. If setup failed, this is never called.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_incoming_frame_begin_fn","page":"Home","title":"LibAWSCRT.aws_websocket_on_incoming_frame_begin_fn","text":"Called when a new frame arrives. Invoked once per frame on the websocket's event-loop thread. Each incoming-frame-begin call will eventually be followed by an incoming-frame-complete call, before the next frame begins and before the websocket shuts down.\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_incoming_frame_complete_fn","page":"Home","title":"LibAWSCRT.aws_websocket_on_incoming_frame_complete_fn","text":"Called when done processing an incoming frame. If error_code is non-zero, an error occurred and the payload may not have been completely received. Invoked once per frame on the websocket's event-loop thread.\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_on_incoming_frame_payload_fn","page":"Home","title":"LibAWSCRT.aws_websocket_on_incoming_frame_payload_fn","text":"Called repeatedly as payload data arrives. Invoked 0 or more times on the websocket's event-loop thread. Payload data will not be valid after this call, so copy if necessary. The payload data is always unmasked at this point.\n\nNOTE: If you created the websocket with manual_window_management set true, you must maintain the read window. Whenever the read window reaches 0, you will stop receiving anything. The websocket's initial_window_size determines the starting size of the read window. The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION). Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing. Maintain a larger window to keep up high throughput. You only need to worry about the payload from \"data\" frames. The websocket automatically increments the window to account for any other incoming bytes, including other parts of a frame (opcode, payload-length, etc) and the payload of other frame types (PING, PONG, CLOSE).\n\nReturn true to proceed normally. If false is returned, the websocket will read no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_opcode","page":"Home","title":"LibAWSCRT.aws_websocket_opcode","text":"aws_websocket_opcode\n\nOpcode describing the type of a websocket frame. RFC-6455 Section 5.2\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_outgoing_frame_complete_fn","page":"Home","title":"LibAWSCRT.aws_websocket_outgoing_frame_complete_fn","text":"Called when a aws_websocket_send_frame() operation completes. error_code will be zero if the operation was successful. \"Success\" does not guarantee that the peer actually received or processed the frame. Invoked exactly once per sent frame on the websocket's event-loop thread.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_send_frame_options","page":"Home","title":"LibAWSCRT.aws_websocket_send_frame_options","text":"aws_websocket_send_frame_options\n\nOptions for sending a websocket frame. This structure is copied immediately by aws_websocket_send(). For descriptions of opcode, fin, and payload_length see in RFC-6455 Section 5.2.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_websocket_stream_outgoing_payload_fn","page":"Home","title":"LibAWSCRT.aws_websocket_stream_outgoing_payload_fn","text":"Called repeatedly as the websocket's payload is streamed out. The user should write payload data to out_buf, up to available capacity. The websocket will mask this data for you, if necessary. Invoked repeatedly on the websocket's event-loop thread.\n\nReturn true to proceed normally. If false is returned, the websocket will send no further data, the frame will complete with an error-code, and the connection will close.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_xml_parser_on_node_encountered_fn","page":"Home","title":"LibAWSCRT.aws_xml_parser_on_node_encountered_fn","text":"Callback for when an xml node is encountered in the document. As a user you have a few options:\n\nfail the parse by returning AWS_OP_ERR (after an error has been raised). This will stop any further parsing. 2. call aws_xml_node_traverse() on the node to descend into the node with a new callback and user_data. 3. call aws_xml_node_as_body() to retrieve the contents of the node as text.\n\nYou MUST NOT call both aws_xml_node_traverse() and aws_xml_node_as_body() on the same node.\n\nreturn true to continue the parsing operation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.defender_custom_metric_type","page":"Home","title":"LibAWSCRT.defender_custom_metric_type","text":"defender_custom_metric_type\n\nChange name if this needs external exposure. Needed to keep track of how to interpret instantiated metrics, and cast the supplier_fn correctly.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.hash_table_state","page":"Home","title":"LibAWSCRT.hash_table_state","text":"Hash table data structure. This module provides an automatically resizing hash table implementation for general purpose use. The hash table stores a mapping between void * keys and values; it is expected that in most cases, these will point to a structure elsewhere in the heap, instead of inlining a key or value into the hash table element itself.\n\nCurrently, this hash table implements a variant of robin hood hashing, but we do not guarantee that this won't change in the future.\n\nAssociated with each hash function are four callbacks:\n\nhash_fn - A hash function from the keys to a uint64_t. It is critical that the hash function for a key does not change while the key is in the hash table; violating this results in undefined behavior. Collisions are tolerated, though naturally with reduced performance.\n\nequals_fn - An equality comparison function. This function must be reflexive and consistent with hash_fn.\n\ndestroy_key_fn, destroy_value_fn - Optional callbacks invoked when the table is cleared or cleaned up and at the caller's option when an element is removed from the table. Either or both may be set to NULL, which has the same effect as a no-op destroy function.\n\nThis datastructure can be safely moved between threads, subject to the requirements of the underlying allocator. It is also safe to invoke non-mutating operations on the hash table from multiple threads. A suitable memory barrier must be used when transitioning from single-threaded mutating usage to multithreaded usage.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.on_connection_closed_data","page":"Home","title":"LibAWSCRT.on_connection_closed_data","text":"Empty struct that is passed when on_connection_closed is called. Currently holds nothing but will allow expanding in the future should it be needed.\n\n\n\n\n\n","category":"type"},{"location":"#LibAWSCRT.aws_add_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_size_checked","text":"aws_add_size_checked(a, b, r)\n\nAdds a + b and returns the result in *r. If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_add_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_size_saturating","text":"aws_add_size_saturating(a, b)\n\nAdds a + b. If the result overflows returns SIZE_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_add_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_add_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_u32_checked","text":"aws_add_u32_checked(a, b, r)\n\nIf a + b overflows, returns AWS_OP_ERR; otherwise adds a + b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_add_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_u32_saturating","text":"aws_add_u32_saturating(a, b)\n\nAdds a + b. If the result overflows, returns 2^32 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_add_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_add_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_u64_checked","text":"aws_add_u64_checked(a, b, r)\n\nIf a + b overflows, returns AWS_OP_ERR; otherwise adds a + b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_add_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_add_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_add_u64_saturating","text":"aws_add_u64_saturating(a, b)\n\nAdds a + b. If the result overflows, returns 2^64 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_add_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_aes_cbc_256_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_aes_cbc_256_new","text":"aws_aes_cbc_256_new(allocator, key, iv)\n\nCreates an instance of AES CBC with 256-bit key. If key and iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_cbc_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_aes_ctr_256_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_aes_ctr_256_new","text":"aws_aes_ctr_256_new(allocator, key, iv)\n\nCreates an instance of AES CTR with 256-bit key. If key and iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_ctr_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_aes_gcm_256_new-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_aes_gcm_256_new","text":"aws_aes_gcm_256_new(allocator, key, iv, aad, decryption_tag)\n\nCreates an instance of AES GCM with 256-bit key. If key, iv are NULL, they will be generated internally. You can get the generated key and iv back by calling:\n\naws_symmetric_cipher_get_key() and aws_symmetric_cipher_get_initialization_vector()\n\nrespectively.\n\nIf they are set, that key and iv will be copied internally and used by the cipher.\n\nIf tag and aad are set they will be copied internally and used by the cipher. decryption_tag would most likely be used for a decrypt operation to detect tampering or corruption. The Tag for the most recent encrypt operation will be available in:\n\naws_symmetric_cipher_get_tag()\n\nIf aad is set it will be copied and applied to the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_gcm_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key, const struct aws_byte_cursor *iv, const struct aws_byte_cursor *aad, const struct aws_byte_cursor *decryption_tag);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_aes_keywrap_256_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_aes_keywrap_256_new","text":"aws_aes_keywrap_256_new(allocator, key)\n\nCreates an instance of AES Keywrap with 256-bit key. If key is NULL, it will be generated internally. You can get the generated key back by calling:\n\naws_symmetric_cipher_get_key()\n\nIf key is set, that key will be copied internally and used by the cipher.\n\nReturns NULL on failure. You can check aws_last_error() to get the error code indicating the failure cause.\n\nPrototype\n\nstruct aws_symmetric_cipher *aws_aes_keywrap_256_new( struct aws_allocator *allocator, const struct aws_byte_cursor *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_allocator_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_allocator_is_valid","text":"aws_allocator_is_valid(alloc)\n\nInexpensive (constant time) check of data-structure invariants.\n\nPrototype\n\nbool aws_allocator_is_valid(const struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_apply_signing_result_to_http_request-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_apply_signing_result_to_http_request","text":"aws_apply_signing_result_to_http_request(request, allocator, result)\n\nPrototype\n\nint aws_apply_signing_result_to_http_request( struct aws_http_message *request, struct aws_allocator *allocator, const struct aws_signing_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_eq-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_array_eq","text":"aws_array_eq(array_a, len_a, array_b, len_b)\n\nCompare two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0.\n\nPrototype\n\nbool aws_array_eq(const void *const array_a, const size_t len_a, const void *array_b, const size_t len_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_eq_c_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_eq_c_str","text":"aws_array_eq_c_str(array, array_len, c_str)\n\nCompare an array and a null-terminated string. Returns true if their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0.\n\nPrototype\n\nbool aws_array_eq_c_str(const void *const array, const size_t array_len, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_eq_c_str_ignore_case-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_eq_c_str_ignore_case","text":"aws_array_eq_c_str_ignore_case(array, array_len, c_str)\n\nPerform a case-insensitive string comparison of an array and a null-terminated string. Return whether their contents are equivalent. The array should NOT contain a null-terminator, or the comparison will always return false. NULL may be passed as the array pointer if its length is declared to be 0. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_array_eq_c_str_ignore_case(const void *const array, const size_t array_len, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_eq_ignore_case-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_array_eq_ignore_case","text":"aws_array_eq_ignore_case(array_a, len_a, array_b, len_b)\n\nPerform a case-insensitive string comparison of two arrays. Return whether their contents are equivalent. NULL may be passed as the array pointer if its length is declared to be 0. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_array_eq_ignore_case( const void *const array_a, const size_t len_a, const void *const array_b, const size_t len_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_back-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_back","text":"aws_array_list_back(list, val)\n\nCopies the element at the end of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_back(const struct aws_array_list *AWS_RESTRICT list, void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_capacity-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_capacity","text":"aws_array_list_capacity(list)\n\nReturns the number of elements that can fit in the internal array. If list is initialized in dynamic mode, the capacity changes over time.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_array_list_capacity(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_clean_up","text":"aws_array_list_clean_up(list)\n\nDeallocates any memory that was allocated for this list, and resets list for reuse or deletion.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clean_up(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_clean_up_secure-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_clean_up_secure","text":"aws_array_list_clean_up_secure(list)\n\nErases and then deallocates any memory that was allocated for this list, and resets list for reuse or deletion.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clean_up_secure(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_clear","text":"aws_array_list_clear(list)\n\nClears all elements in the array and resets length to zero. Size does not change in this operation.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_clear(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_comparator_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_comparator_string","text":"aws_array_list_comparator_string(a, b)\n\nA convenience function for sorting lists of (const struct aws_string *) elements. This can be used as a comparator for aws_array_list_sort. It is just a simple wrapper around aws_string_compare.\n\nPrototype\n\nint aws_array_list_comparator_string(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_copy-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_copy","text":"aws_array_list_copy(from, to)\n\nCopies the elements from from to to. If to is in static mode, it must at least be the same length as from. Any data in to will be overwritten in this copy.\n\nPrototype\n\nint aws_array_list_copy(const struct aws_array_list *AWS_RESTRICT from, struct aws_array_list *AWS_RESTRICT to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_ensure_capacity-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_ensure_capacity","text":"aws_array_list_ensure_capacity(list, index)\n\nEnsures that the array list has enough capacity to store a value at the specified index. If there is not already enough capacity, and the list is in dynamic mode, this function will attempt to allocate more memory, expanding the list. In static mode, if 'index' is beyond the maximum index, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nint aws_array_list_ensure_capacity(struct aws_array_list *AWS_RESTRICT list, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_erase-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_erase","text":"aws_array_list_erase(list, index)\n\nDeletes the element this index in the list if it exists. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised. This call results in shifting all remaining elements towards the front. Avoid this call unless that is intended behavior.\n\nPrototype\n\nint aws_array_list_erase(struct aws_array_list *AWS_RESTRICT list, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_front-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_front","text":"aws_array_list_front(list, val)\n\nCopies the element at the front of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_front(const struct aws_array_list *AWS_RESTRICT list, void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_get_at-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_get_at","text":"aws_array_list_get_at(list, val, index)\n\nCopies the memory at index to val. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_get_at(const struct aws_array_list *AWS_RESTRICT list, void *val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_get_at_ptr-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_get_at_ptr","text":"aws_array_list_get_at_ptr(list, val, index)\n\nCopies the memory address of the element at index to *val. If element does not exist, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_get_at_ptr(const struct aws_array_list *AWS_RESTRICT list, void **val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_init_dynamic-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_init_dynamic","text":"aws_array_list_init_dynamic(list, alloc, initial_item_allocation, item_size)\n\nInitializes an array list with an array of size initial_item_allocation * item_size. In this mode, the array size will grow by a factor of 2 upon insertion if space is not available. initial_item_allocation is the number of elements you want space allocated for. item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_init_dynamic( struct aws_array_list *AWS_RESTRICT list, struct aws_allocator *alloc, size_t initial_item_allocation, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_init_static-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_init_static","text":"aws_array_list_init_static(list, raw_array, item_count, item_size)\n\nInitializes an array list with a preallocated array of void *. item_count is the number of elements in the array, and item_size is the size in bytes of each element. Mixing items types is not supported by this API. Once this list is full, new items will be rejected.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_init_static( struct aws_array_list *AWS_RESTRICT list, void *raw_array, size_t item_count, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_init_static_from_initialized-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_init_static_from_initialized","text":"aws_array_list_init_static_from_initialized(list, raw_array, item_count, item_size)\n\nInitializes an array list with a preallocated array of already-initialized elements. item_count is the number of elements in the array, and item_size is the size in bytes of each element.\n\nOnce initialized, nothing further can be added to the list, since it will be full and cannot resize.\n\nPrimary use case is to treat an already-initialized C array as an array list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_init_static_from_initialized( struct aws_array_list *AWS_RESTRICT list, void *raw_array, size_t item_count, size_t item_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_is_valid","text":"aws_array_list_is_valid(list)\n\nSet of properties of a valid aws_array_list.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_array_list_is_valid(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_length-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_length","text":"aws_array_list_length(list)\n\nReturns the number of elements in the internal array.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_array_list_length(const struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_pop_back-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_pop_back","text":"aws_array_list_pop_back(list)\n\nDeletes the element at the end of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_pop_back(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_pop_front-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_pop_front","text":"aws_array_list_pop_front(list)\n\nDeletes the element at the front of the list if it exists. If list is empty, AWS_ERROR_LIST_EMPTY will be raised. This call results in shifting all of the elements at the end of the array to the front. Avoid this call unless that is intended behavior.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_pop_front(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_pop_front_n-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_pop_front_n","text":"aws_array_list_pop_front_n(list, n)\n\nDelete N elements from the front of the list. Remaining elements are shifted to the front of the list. If the list has less than N elements, the list is cleared. This call is more efficient than calling aws_array_list_pop_front() N times.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_pop_front_n(struct aws_array_list *AWS_RESTRICT list, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_push_back-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_push_back","text":"aws_array_list_push_back(list, val)\n\nPushes the memory pointed to by val onto the end of internal list\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_push_back(struct aws_array_list *AWS_RESTRICT list, const void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_push_front-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_push_front","text":"aws_array_list_push_front(list, val)\n\nPushes the memory pointed to by val onto the front of internal list. This call results in shifting all of the elements in the list. Avoid this call unless that is intended behavior.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_push_front(struct aws_array_list *AWS_RESTRICT list, const void *val);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_set_at-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_set_at","text":"aws_array_list_set_at(list, val, index)\n\nCopies the the memory pointed to by val into the array at index. If in dynamic mode, the size will grow by a factor of two when the array is full. In static mode, AWS_ERROR_INVALID_INDEX will be raised if the index is past the bounds of the array.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_array_list_set_at(struct aws_array_list *AWS_RESTRICT list, const void *val, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_shrink_to_fit-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_array_list_shrink_to_fit","text":"aws_array_list_shrink_to_fit(list)\n\nIf in dynamic mode, shrinks the allocated array size to the minimum amount necessary to store its elements.\n\nPrototype\n\nint aws_array_list_shrink_to_fit(struct aws_array_list *AWS_RESTRICT list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_sort-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_sort","text":"aws_array_list_sort(list, compare_fn)\n\nSort elements in the list in-place according to the comparator function.\n\nPrototype\n\nvoid aws_array_list_sort(struct aws_array_list *AWS_RESTRICT list, aws_array_list_comparator_fn *compare_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_swap-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_swap","text":"aws_array_list_swap(list, a, b)\n\nSwap elements at the specified indices, which must be within the bounds of the array.\n\nPrototype\n\nvoid aws_array_list_swap(struct aws_array_list *AWS_RESTRICT list, size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_array_list_swap_contents-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_array_list_swap_contents","text":"aws_array_list_swap_contents(list_a, list_b)\n\nSwap contents between two dynamic lists. Both lists must use the same allocator.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_array_list_swap_contents( struct aws_array_list *AWS_RESTRICT list_a, struct aws_array_list *AWS_RESTRICT list_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_async_input_stream_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_async_input_stream_acquire","text":"aws_async_input_stream_acquire(stream)\n\nIncrement reference count. You may pass in NULL (has no effect). Returns whatever pointer was passed in.\n\nPrototype\n\nstruct aws_async_input_stream *aws_async_input_stream_acquire(struct aws_async_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_async_input_stream_init_base-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_async_input_stream_init_base","text":"aws_async_input_stream_init_base(stream, alloc, vtable, impl)\n\nInitialize aws_async_input_stream \"base class\"\n\nPrototype\n\nvoid aws_async_input_stream_init_base( struct aws_async_input_stream *stream, struct aws_allocator *alloc, const struct aws_async_input_stream_vtable *vtable, void *impl);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_async_input_stream_read-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_async_input_stream_read","text":"aws_async_input_stream_read(stream, dest)\n\nRead once from the async stream into the buffer. The read completes when at least 1 byte is read, the buffer is full, or EOF is reached. Depending on implementation, the read could complete at any time. It may complete synchronously. It may complete on another thread. Returns a future, which will contain an error code if something went wrong, or a result bool indicating whether EOF has been reached.\n\nWARNING: The buffer must have space available. WARNING: Do not read again until the previous read is complete.\n\nPrototype\n\nstruct aws_future_bool *aws_async_input_stream_read(struct aws_async_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_async_input_stream_read_to_fill-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_async_input_stream_read_to_fill","text":"aws_async_input_stream_read_to_fill(stream, dest)\n\nRead repeatedly from the async stream until the buffer is full, or EOF is reached. Depending on implementation, this could complete at any time. It may complete synchronously. It may complete on another thread. Returns a future, which will contain an error code if something went wrong, or a result bool indicating whether EOF has been reached.\n\nWARNING: The buffer must have space available. WARNING: Do not read again until the previous read is complete.\n\nPrototype\n\nstruct aws_future_bool *aws_async_input_stream_read_to_fill( struct aws_async_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_async_input_stream_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_async_input_stream_release","text":"aws_async_input_stream_release(stream)\n\nDecrement reference count. You may pass in NULL (has no effect). Always returns NULL.\n\nPrototype\n\nstruct aws_async_input_stream *aws_async_input_stream_release(struct aws_async_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_compare_exchange_int-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_compare_exchange_int","text":"aws_atomic_compare_exchange_int(var, expected, desired)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_int(volatile struct aws_atomic_var *var, size_t *expected, size_t desired);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_compare_exchange_int_explicit-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_compare_exchange_int_explicit","text":"aws_atomic_compare_exchange_int_explicit(var, expected, desired, order_success, order_failure)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure. order_failure must be no stronger than order_success, and must not be release or acq_rel.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_int_explicit( volatile struct aws_atomic_var *var, size_t *expected, size_t desired, enum aws_memory_order order_success, enum aws_memory_order order_failure);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_compare_exchange_ptr-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_compare_exchange_ptr","text":"aws_atomic_compare_exchange_ptr(var, expected, desired)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. Uses sequentially consistent memory ordering, regardless of success or failure. Returns true if the compare was successful and the variable updated to desired.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_ptr(volatile struct aws_atomic_var *var, void **expected, void *desired);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_compare_exchange_ptr_explicit-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_compare_exchange_ptr_explicit","text":"aws_atomic_compare_exchange_ptr_explicit(var, expected, desired, order_success, order_failure)\n\nAtomically compares *var to *expected; if they are equal, atomically sets *var = desired. Otherwise, *expected is set to the value in *var. On success, the memory ordering used was order_success; otherwise, it was order_failure. order_failure must be no stronger than order_success, and must not be release or acq_rel.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_atomic_compare_exchange_ptr_explicit( volatile struct aws_atomic_var *var, void **expected, void *desired, enum aws_memory_order order_success, enum aws_memory_order order_failure);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_exchange_int-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_exchange_int","text":"aws_atomic_exchange_int(var, n)\n\nExchanges an integer with the value in an atomic_var, using sequentially consistent ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_exchange_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_exchange_int_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_exchange_int_explicit","text":"aws_atomic_exchange_int_explicit(var, n, memory_order)\n\nExchanges an integer with the value in an atomic_var, using the specified ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_exchange_int_explicit( volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_exchange_ptr-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_exchange_ptr","text":"aws_atomic_exchange_ptr(var, p)\n\nExchanges an integer with the value in an atomic_var, using sequentially consistent ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_exchange_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_exchange_ptr_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_exchange_ptr_explicit","text":"aws_atomic_exchange_ptr_explicit(var, p, memory_order)\n\nExchanges a pointer with the value in an atomic_var, using the specified ordering. Returns the value that was previously in the atomic_var.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_exchange_ptr_explicit( volatile struct aws_atomic_var *var, void *p, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_add-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_add","text":"aws_atomic_fetch_add(var, n)\n\nAtomically adds n to *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_add(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_add_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_add_explicit","text":"aws_atomic_fetch_add_explicit(var, n, order)\n\nAtomically adds n to *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_add_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_and-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_and","text":"aws_atomic_fetch_and(var, n)\n\nAtomically ands n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_and(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_and_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_and_explicit","text":"aws_atomic_fetch_and_explicit(var, n, order)\n\nAtomically ANDs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_and_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_or-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_or","text":"aws_atomic_fetch_or(var, n)\n\nAtomically ors n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_or(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_or_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_or_explicit","text":"aws_atomic_fetch_or_explicit(var, n, order)\n\nAtomically ORs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_or_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_sub-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_sub","text":"aws_atomic_fetch_sub(var, n)\n\nAtomically subtracts n from *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_sub(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_sub_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_sub_explicit","text":"aws_atomic_fetch_sub_explicit(var, n, order)\n\nAtomically subtracts n from *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_sub_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_xor-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_xor","text":"aws_atomic_fetch_xor(var, n)\n\nAtomically xors n into *var, and returns the previous value of *var. Uses sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_xor(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_fetch_xor_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_fetch_xor_explicit","text":"aws_atomic_fetch_xor_explicit(var, n, order)\n\nAtomically XORs n with *var, and returns the previous value of *var.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_fetch_xor_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_init_int-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_init_int","text":"aws_atomic_init_int(var, n)\n\nInitializes an atomic variable with an integer value. This operation should be done before any other operations on this atomic variable, and must be done before attempting any parallel operations.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_init_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_init_ptr-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_init_ptr","text":"aws_atomic_init_ptr(var, p)\n\nInitializes an atomic variable with a pointer value. This operation should be done before any other operations on this atomic variable, and must be done before attempting any parallel operations.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_init_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_load_int-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_atomic_load_int","text":"aws_atomic_load_int(var)\n\nReads an atomic var as an integer, using sequentially consistent ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_load_int(volatile const struct aws_atomic_var *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_load_int_explicit-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_load_int_explicit","text":"aws_atomic_load_int_explicit(var, memory_order)\n\nReads an atomic var as an integer, using the specified ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_atomic_load_int_explicit(volatile const struct aws_atomic_var *var, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_load_ptr-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_atomic_load_ptr","text":"aws_atomic_load_ptr(var)\n\nReads an atomic var as a pointer, using sequentially consistent ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_load_ptr(volatile const struct aws_atomic_var *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_load_ptr_explicit-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_load_ptr_explicit","text":"aws_atomic_load_ptr_explicit(var, memory_order)\n\nReads an atomic var as a pointer, using the specified ordering, and returns the result.\n\nPrototype\n\nAWS_STATIC_IMPL void *aws_atomic_load_ptr_explicit(volatile const struct aws_atomic_var *var, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_priv_xlate_order-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_atomic_priv_xlate_order","text":"aws_atomic_priv_xlate_order(order)\n\nPrototype\n\nstatic inline int aws_atomic_priv_xlate_order(enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_store_int-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_store_int","text":"aws_atomic_store_int(var, n)\n\nStores an integer into an atomic var, using sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_int(volatile struct aws_atomic_var *var, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_store_int_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_store_int_explicit","text":"aws_atomic_store_int_explicit(var, n, memory_order)\n\nStores an integer into an atomic var, using the specified ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_int_explicit(volatile struct aws_atomic_var *var, size_t n, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_store_ptr-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_store_ptr","text":"aws_atomic_store_ptr(var, p)\n\nStores a pointer into an atomic var, using sequentially consistent ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_ptr(volatile struct aws_atomic_var *var, void *p);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_store_ptr_explicit-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_atomic_store_ptr_explicit","text":"aws_atomic_store_ptr_explicit(var, p, memory_order)\n\nStores an pointer into an atomic var, using the specified ordering.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_store_ptr_explicit(volatile struct aws_atomic_var *var, void *p, enum aws_memory_order memory_order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_atomic_thread_fence-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_atomic_thread_fence","text":"aws_atomic_thread_fence(order)\n\nProvides the same reordering guarantees as an atomic operation with the specified memory order, without needing to actually perform an atomic operation.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_atomic_thread_fence(enum aws_memory_order order);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_auth_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_auth_library_clean_up","text":"aws_auth_library_clean_up()\n\nClean up internal datastructures used by aws-c-auth. Must not be called until application is done using functionality in aws-c-auth.\n\nPrototype\n\nvoid aws_auth_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_auth_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_auth_library_init","text":"aws_auth_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-auth. Must be called before using any functionality in aws-c-auth.\n\nParameters\n\nallocator: memory allocator to use for any module-level memory allocation\n\nPrototype\n\nvoid aws_auth_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_backtrace-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_backtrace","text":"aws_backtrace(stack_frames, num_frames)\n\nPrototype\n\nsize_t aws_backtrace(void **stack_frames, size_t num_frames);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_backtrace_addr2line-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_backtrace_addr2line","text":"aws_backtrace_addr2line(stack_frames, stack_depth)\n\nPrototype\n\nchar **aws_backtrace_addr2line(void *const *stack_frames, size_t stack_depth);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_backtrace_log-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_backtrace_log","text":"aws_backtrace_log(log_level)\n\nPrototype\n\nvoid aws_backtrace_log(int log_level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_backtrace_print-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_backtrace_print","text":"aws_backtrace_print(fp, call_site_data)\n\nPrint a backtrace from either the current stack, or (if provided) the current exception/signal call_site_data is siginfo_t* on POSIX, and LPEXCEPTION_POINTERS on Windows, and can be null\n\nPrototype\n\nvoid aws_backtrace_print(FILE *fp, void *call_site_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_backtrace_symbols-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_backtrace_symbols","text":"aws_backtrace_symbols(stack_frames, stack_depth)\n\nPrototype\n\nchar **aws_backtrace_symbols(void *const *stack_frames, size_t stack_depth);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_base64_compute_decoded_len-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_base64_compute_decoded_len","text":"aws_base64_compute_decoded_len(to_decode, decoded_len)\n\nPrototype\n\nint aws_base64_compute_decoded_len(const struct aws_byte_cursor *AWS_RESTRICT to_decode, size_t *decoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_base64_compute_encoded_len-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_base64_compute_encoded_len","text":"aws_base64_compute_encoded_len(to_encode_len, encoded_len)\n\nPrototype\n\nint aws_base64_compute_encoded_len(size_t to_encode_len, size_t *encoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_base64_decode-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_base64_decode","text":"aws_base64_decode(to_decode, output)\n\nPrototype\n\nint aws_base64_decode(const struct aws_byte_cursor *AWS_RESTRICT to_decode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_base64_encode-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_base64_encode","text":"aws_base64_encode(to_encode, output)\n\nPrototype\n\nint aws_base64_encode(const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_advance-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_advance","text":"aws_byte_buf_advance(buffer, output, len)\n\nAppends a sub-buffer to the specified buffer.\n\nIf the buffer has at least len' bytes remaining (buffer->capacity - buffer->len >= len), then buffer->len is incremented by len, and an [awsbytebuf](@ref) is assigned to *output corresponding to the last len bytes of the input buffer. The [awsbytebuf`](@ref) at *output will have a null allocator, a zero initial length, and a capacity of 'len'. The function then returns true.\n\nIf there is insufficient space, then this function nulls all fields in *output and returns false.\n\nPrototype\n\nbool aws_byte_buf_advance( struct aws_byte_buf *const AWS_RESTRICT buffer, struct aws_byte_buf *const AWS_RESTRICT output, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append","text":"aws_byte_buf_append(to, from)\n\nCopies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest->len will contain the amount of data actually copied to dest.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_and_update-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_and_update","text":"aws_byte_buf_append_and_update(to, from_and_update)\n\nCopy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer. If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.\n\nThe cursor is permitted to reference memory from earlier in the buffer.\n\nPrototype\n\nint aws_byte_buf_append_and_update(struct aws_byte_buf *to, struct aws_byte_cursor *from_and_update);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_byte_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_byte_dynamic","text":"aws_byte_buf_append_byte_dynamic(buffer, value)\n\nCopies a single byte into to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nPrototype\n\nint aws_byte_buf_append_byte_dynamic(struct aws_byte_buf *buffer, uint8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_byte_dynamic_secure-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_byte_dynamic_secure","text":"aws_byte_buf_append_byte_dynamic_secure(buffer, value)\n\nCopies a single byte into to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the byte is appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nIf the buffer is grown, the old buffer will be securely cleared before getting freed.\n\nPrototype\n\nint aws_byte_buf_append_byte_dynamic_secure(struct aws_byte_buf *buffer, uint8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_decoding_uri-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_decoding_uri","text":"aws_byte_buf_append_decoding_uri(buffer, cursor)\n\nWrites the uri decoding of a UTF-8 cursor to a buffer, replacing xx escapes by their single byte equivalent. For example, reading \"a20b_c\" would write \"a b_c\".\n\nPrototype\n\nint aws_byte_buf_append_decoding_uri(struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_dynamic","text":"aws_byte_buf_append_dynamic(to, from)\n\nCopies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied to, before the new contents are appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append_dynamic(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_dynamic_secure-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_dynamic_secure","text":"aws_byte_buf_append_dynamic_secure(to, from)\n\nCopies from to to. If to is too small, the buffer will be grown appropriately and the old contents copied over, before the new contents are appended.\n\nIf the grow fails (overflow or OOM), then an error will be returned.\n\nIf the buffer is grown, the old buffer will be securely cleared before getting freed.\n\nfrom and to may be the same buffer, permitting copying a buffer into itself.\n\nPrototype\n\nint aws_byte_buf_append_dynamic_secure(struct aws_byte_buf *to, const struct aws_byte_cursor *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_encoding_uri_param-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_encoding_uri_param","text":"aws_byte_buf_append_encoding_uri_param(buffer, cursor)\n\nWrites the uri query param encoding (passthrough alnum + '-' '_' '~' '.') of a UTF-8 cursor to a buffer For example, reading \"a b_c\" would write \"a20b_c\".\n\nPrototype\n\nint aws_byte_buf_append_encoding_uri_param( struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_encoding_uri_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_encoding_uri_path","text":"aws_byte_buf_append_encoding_uri_path(buffer, cursor)\n\nWrites the uri path encoding of a cursor to a buffer. This is the modified version of rfc3986 used by sigv4 signing.\n\nPrototype\n\nint aws_byte_buf_append_encoding_uri_path( struct aws_byte_buf *buffer, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_json_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_json_string","text":"aws_byte_buf_append_json_string(value, output)\n\nAppends a unformatted JSON string representation of the aws_json_value into the passed byte buffer. The byte buffer is expected to be already initialized so the function can append the JSON into it.\n\nNote: The byte buffer will automatically have its size extended if the JSON string is over the byte buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\nNote: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free the memory used, as it will NOT be called automatically.\n\nParameters\n\nvalue: The aws_json_value to format.\noutput: The destination for the JSON string\n\nReturns\n\nAWS_OP_SUCCESS if the JSON string was allocated to output without any errors Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there was an error appending the JSON into the byte buffer.\n\nPrototype\n\nint aws_byte_buf_append_json_string(const struct aws_json_value *value, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_json_string_formatted-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_json_string_formatted","text":"aws_byte_buf_append_json_string_formatted(value, output)\n\nAppends a formatted JSON string representation of the aws_json_value into the passed byte buffer. The byte buffer is expected to already be initialized so the function can append the JSON into it.\n\nNote: The byte buffer will automatically have its size extended if the JSON string is over the byte buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\nNote: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free the memory used, as it will NOT be called automatically.\n\nParameters\n\nvalue: The aws_json_value to format.\noutput: The destination for the JSON string\n\nReturns\n\nAWS_OP_SUCCESS if the JSON string was allocated to output without any errors Will return AWS_ERROR_INVALID_ARGUMENT if the value passed is not an aws_json_value or if there aws an error appending the JSON into the byte buffer.\n\nPrototype\n\nint aws_byte_buf_append_json_string_formatted(const struct aws_json_value *value, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_null_terminator-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_null_terminator","text":"aws_byte_buf_append_null_terminator(buf)\n\nAppends '\\0' at the end of the buffer.\n\nPrototype\n\nint aws_byte_buf_append_null_terminator(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_resource_name-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_resource_name","text":"aws_byte_buf_append_resource_name(buf, arn)\n\nSerializes an ARN structure into the lexical string format\n\nPrototype\n\nint aws_byte_buf_append_resource_name(struct aws_byte_buf *buf, const struct aws_resource_name *arn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_append_with_lookup-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_append_with_lookup","text":"aws_byte_buf_append_with_lookup(to, from, lookup_table)\n\nCopies from to to while converting bytes via the passed in lookup table. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. to->len will contain its original size plus the amount of data actually copied to to.\n\nfrom and to should not be the same buffer (overlap is not handled) lookup_table must be at least 256 bytes\n\nPrototype\n\nint aws_byte_buf_append_with_lookup( struct aws_byte_buf *AWS_RESTRICT to, const struct aws_byte_cursor *AWS_RESTRICT from, const uint8_t *lookup_table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_clean_up","text":"aws_byte_buf_clean_up(buf)\n\nPrototype\n\nvoid aws_byte_buf_clean_up(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_clean_up_secure-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_clean_up_secure","text":"aws_byte_buf_clean_up_secure(buf)\n\nEquivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up on the buffer.\n\nPrototype\n\nvoid aws_byte_buf_clean_up_secure(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_eq","text":"aws_byte_buf_eq(a, b)\n\nCompare two aws_byte_buf structures. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_buf_eq(const struct aws_byte_buf *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_eq_c_str","text":"aws_byte_buf_eq_c_str(buf, c_str)\n\nCompare an aws_byte_buf and a null-terminated string. Returns true if their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false.\n\nPrototype\n\nbool aws_byte_buf_eq_c_str(const struct aws_byte_buf *const buf, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_eq_c_str_ignore_case","text":"aws_byte_buf_eq_c_str_ignore_case(buf, c_str)\n\nPerform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string. Return whether their contents are equivalent. The buffer should NOT contain a null-terminator, or the comparison will always return false. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_buf_eq_c_str_ignore_case(const struct aws_byte_buf *const buf, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_eq_ignore_case","text":"aws_byte_buf_eq_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of two aws_byte_buf structures. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_buf_eq_ignore_case(const struct aws_byte_buf *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_from_array-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_from_array","text":"aws_byte_buf_from_array(bytes, len)\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_array(const void *bytes, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_from_c_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_from_c_str","text":"aws_byte_buf_from_c_str(c_str)\n\nFor creating a byte buffer from a null-terminated string literal.\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_c_str(const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_from_empty_array-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_from_empty_array","text":"aws_byte_buf_from_empty_array(bytes, capacity)\n\nPrototype\n\nstruct aws_byte_buf aws_byte_buf_from_empty_array(const void *bytes, size_t capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_init","text":"aws_byte_buf_init(buf, allocator, capacity)\n\nPrototype\n\nint aws_byte_buf_init(struct aws_byte_buf *buf, struct aws_allocator *allocator, size_t capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_init_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_init_copy","text":"aws_byte_buf_init_copy(dest, allocator, src)\n\nInitializes an aws_byte_buf structure base on another valid one. Requires: *src and *allocator are valid objects. Ensures: *dest is a valid aws_byte_buf with a new backing array dest->buffer which is a copy of the elements from src->buffer.\n\nPrototype\n\nint aws_byte_buf_init_copy( struct aws_byte_buf *dest, struct aws_allocator *allocator, const struct aws_byte_buf *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_init_copy_from_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_init_copy_from_cursor","text":"aws_byte_buf_init_copy_from_cursor(dest, allocator, src)\n\nCopies src buffer into dest and sets the correct len and capacity. A new memory zone is allocated for dest->buffer. When dest is no longer needed it will have to be cleaned-up using aws_byte_buf_clean_up(dest). Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator. If src buffer is null the dest will have a null buffer with a len and a capacity of 0 Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated.\n\nPrototype\n\nint aws_byte_buf_init_copy_from_cursor( struct aws_byte_buf *dest, struct aws_allocator *allocator, struct aws_byte_cursor src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_init_from_file-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_init_from_file","text":"aws_byte_buf_init_from_file(out_buf, alloc, filename)\n\nReads 'filename' into 'out_buf'. If successful, 'out_buf' is allocated and filled with the data; It is your responsibility to call 'aws_byte_buf_clean_up()' on it. Otherwise, 'out_buf' remains unused. In the very unfortunate case where some API needs to treat out_buf as a c_string, a null terminator is appended, but is not included as part of the length field.\n\nPrototype\n\nint aws_byte_buf_init_from_file(struct aws_byte_buf *out_buf, struct aws_allocator *alloc, const char *filename);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_is_valid","text":"aws_byte_buf_is_valid(buf)\n\nEvaluates the set of properties that define the shape of all valid aws_byte_buf structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nbool aws_byte_buf_is_valid(const struct aws_byte_buf *const buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_reserve-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_reserve","text":"aws_byte_buf_reserve(buffer, requested_capacity)\n\nAttempts to increase the capacity of a buffer to the requested capacity\n\nIf the the buffer's capacity is currently larger than the request capacity, the function does nothing (no shrink is performed).\n\nPrototype\n\nint aws_byte_buf_reserve(struct aws_byte_buf *buffer, size_t requested_capacity);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_reserve_relative-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_reserve_relative","text":"aws_byte_buf_reserve_relative(buffer, additional_length)\n\nConvenience function that attempts to increase the capacity of a buffer relative to the current length.\n\naws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf->len + x)\n\nPrototype\n\nint aws_byte_buf_reserve_relative(struct aws_byte_buf *buffer, size_t additional_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_reset-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_reset","text":"aws_byte_buf_reset(buf, zero_contents)\n\nResets the len of the buffer to 0, but does not free the memory. The buffer can then be reused. Optionally zeroes the contents, if the \"zero_contents\" flag is true.\n\nPrototype\n\nvoid aws_byte_buf_reset(struct aws_byte_buf *buf, bool zero_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_secure_zero-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_secure_zero","text":"aws_byte_buf_secure_zero(buf)\n\nSets all bytes of buffer to zero and resets len to zero.\n\nPrototype\n\nvoid aws_byte_buf_secure_zero(struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write","text":"aws_byte_buf_write(buf, src, len)\n\nWrite specified number of bytes from array to byte buffer.\n\nOn success, returns true and updates the buffer length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write( struct aws_byte_buf *AWS_RESTRICT buf, const uint8_t *AWS_RESTRICT src, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_be16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_be16","text":"aws_byte_buf_write_be16(buf, x)\n\nWrites a 16-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be16(struct aws_byte_buf *buf, uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_be24-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_be24","text":"aws_byte_buf_write_be24(buf, x)\n\nWrites low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer. Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be24(struct aws_byte_buf *buf, uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_be32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_be32","text":"aws_byte_buf_write_be32(buf, x)\n\nWrites a 32-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be32(struct aws_byte_buf *buf, uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_be64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_be64","text":"aws_byte_buf_write_be64(buf, x)\n\nWrites a 64-bit integer in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_be64(struct aws_byte_buf *buf, uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_float_be32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_float_be32","text":"aws_byte_buf_write_float_be32(buf, x)\n\nWrites a 32-bit float in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_float_be32(struct aws_byte_buf *buf, float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_float_be64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_float_be64","text":"aws_byte_buf_write_float_be64(buf, x)\n\nWrites a 64-bit float in network byte order (big endian) to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_float_be64(struct aws_byte_buf *buf, double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_from_whole_buffer-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_from_whole_buffer","text":"aws_byte_buf_write_from_whole_buffer(buf, src)\n\nCopies all bytes from buffer to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_buffer( struct aws_byte_buf *AWS_RESTRICT buf, struct aws_byte_buf src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_from_whole_cursor-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_from_whole_cursor","text":"aws_byte_buf_write_from_whole_cursor(buf, src)\n\nCopies all bytes from buffer to buffer.\n\nOn success, returns true and updates the buffer /length accordingly. If there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_cursor( struct aws_byte_buf *AWS_RESTRICT buf, struct aws_byte_cursor src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_from_whole_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_from_whole_string","text":"aws_byte_buf_write_from_whole_string(buf, src)\n\nCopies all bytes from string to buf.\n\nOn success, returns true and updates the buf pointer/length accordingly. If there is insufficient space in the buf, returns false, leaving the buf unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_from_whole_string( struct aws_byte_buf *AWS_RESTRICT buf, const struct aws_string *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_to_capacity-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_to_capacity","text":"aws_byte_buf_write_to_capacity(buf, advancing_cursor)\n\nWithout increasing buf's capacity, write as much as possible from advancing_cursor into buf.\n\nbuf's len is updated accordingly. advancing_cursor is advanced so it contains the remaining unwritten parts. Returns the section of advancing_cursor which was written.\n\nThis function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length, then buf and advancing_cursor are not altered and a cursor with 0 length is returned.\n\nExample: Given a buf with 2 bytes of space available and advancing_cursor with contents \"abc\". \"ab\" will be written to buf and buf->len will increase 2 and become equal to buf->capacity. advancing_cursor will advance so its contents become the unwritten \"c\". The returned cursor's contents will be the \"ab\" from the original advancing_cursor.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_buf_write_to_capacity( struct aws_byte_buf *buf, struct aws_byte_cursor *advancing_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_u8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_u8","text":"aws_byte_buf_write_u8(buf, c)\n\nCopies one byte to buffer.\n\nOn success, returns true and updates the cursor /length accordingly.\n\nIf there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_u8(struct aws_byte_buf *AWS_RESTRICT buf, uint8_t c);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_buf_write_u8_n-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_buf_write_u8_n","text":"aws_byte_buf_write_u8_n(buf, c, count)\n\nWrites one byte repeatedly to buffer (like memset)\n\nIf there is insufficient space in the buffer, returns false, leaving the buffer unchanged.\n\nPrototype\n\nbool aws_byte_buf_write_u8_n(struct aws_byte_buf *buf, uint8_t c, size_t count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_advance-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_advance","text":"aws_byte_cursor_advance(cursor, len)\n\nTests if the given aws_byte_cursor has at least len bytes remaining. If so, *buf is advanced by len bytes (incrementing ->ptr and decrementing ->len), and an aws_byte_cursor referring to the first len bytes of the original *buf is returned. Otherwise, an aws_byte_cursor with ->ptr = NULL, ->len = 0 is returned.\n\nNote that if len is above (SIZE_MAX / 2), this function will also treat it as a buffer overflow, and return NULL without changing *buf.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_advance(struct aws_byte_cursor *const cursor, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_advance_nospec-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_advance_nospec","text":"aws_byte_cursor_advance_nospec(cursor, len)\n\nBehaves identically to aws_byte_cursor_advance, but avoids speculative execution potentially reading out-of-bounds pointers (by returning an empty ptr in such speculated paths).\n\nThis should generally be done when using an untrusted or data-dependent value for 'len', to avoid speculating into a path where cursor->ptr points outside the true ptr length.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_advance_nospec(struct aws_byte_cursor *const cursor, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_compare_lexical-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_compare_lexical","text":"aws_byte_cursor_compare_lexical(lhs, rhs)\n\nLexical (byte value) comparison of two byte cursors\n\nPrototype\n\nint aws_byte_cursor_compare_lexical(const struct aws_byte_cursor *lhs, const struct aws_byte_cursor *rhs);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_compare_lookup-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_compare_lookup","text":"aws_byte_cursor_compare_lookup(lhs, rhs, lookup_table)\n\nLexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first\n\nPrototype\n\nint aws_byte_cursor_compare_lookup( const struct aws_byte_cursor *lhs, const struct aws_byte_cursor *rhs, const uint8_t *lookup_table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq","text":"aws_byte_cursor_eq(a, b)\n\nCompare two aws_byte_cursor structures. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_cursor_eq(const struct aws_byte_cursor *a, const struct aws_byte_cursor *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq_byte_buf-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq_byte_buf","text":"aws_byte_cursor_eq_byte_buf(a, b)\n\nCompare an aws_byte_cursor and an aws_byte_buf. Return whether their contents are equivalent.\n\nPrototype\n\nbool aws_byte_cursor_eq_byte_buf(const struct aws_byte_cursor *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq_byte_buf_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq_byte_buf_ignore_case","text":"aws_byte_cursor_eq_byte_buf_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_byte_buf_ignore_case(const struct aws_byte_cursor *const a, const struct aws_byte_buf *const b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq_c_str","text":"aws_byte_cursor_eq_c_str(cursor, c_str)\n\nCompare an aws_byte_cursor and a null-terminated string. Returns true if their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false.\n\nPrototype\n\nbool aws_byte_cursor_eq_c_str(const struct aws_byte_cursor *const cursor, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq_c_str_ignore_case","text":"aws_byte_cursor_eq_c_str_ignore_case(cursor, c_str)\n\nPerform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string. Return whether their contents are equivalent. The cursor should NOT contain a null-terminator, or the comparison will always return false. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_c_str_ignore_case(const struct aws_byte_cursor *const cursor, const char *const c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_eq_ignore_case","text":"aws_byte_cursor_eq_ignore_case(a, b)\n\nPerform a case-insensitive string comparison of two aws_byte_cursor structures. Return whether their contents are equivalent. The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_eq_ignore_case(const struct aws_byte_cursor *a, const struct aws_byte_cursor *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_find_exact-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_find_exact","text":"aws_byte_cursor_find_exact(input_str, to_find, first_find)\n\nSearch for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS on successful match and first_find will be set to the offset in input_str, and length will be the remaining length from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised.\n\nPrototype\n\nint aws_byte_cursor_find_exact( const struct aws_byte_cursor *AWS_RESTRICT input_str, const struct aws_byte_cursor *AWS_RESTRICT to_find, struct aws_byte_cursor *first_find);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_from_array-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_from_array","text":"aws_byte_cursor_from_array(bytes, len)\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_array(const void *const bytes, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_from_buf-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_from_buf","text":"aws_byte_cursor_from_buf(buf)\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_buf(const struct aws_byte_buf *const buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_from_c_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_from_c_str","text":"aws_byte_cursor_from_c_str(c_str)\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_c_str(const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_from_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_from_string","text":"aws_byte_cursor_from_string(src)\n\nCreates an aws_byte_cursor from an existing string.\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_from_string(const struct aws_string *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_is_valid","text":"aws_byte_cursor_is_valid(cursor)\n\nEvaluates the set of properties that define the shape of all valid aws_byte_cursor structures. It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion).\n\nPrototype\n\nbool aws_byte_cursor_is_valid(const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_left_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_left_trim_pred","text":"aws_byte_cursor_left_trim_pred(source, predicate)\n\nShrinks a byte cursor from the left for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_left_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_next_split-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_next_split","text":"aws_byte_cursor_next_split(input_str, split_on, substr)\n\nNo copies, no buffer allocations. Iterates over input_str, and returns the next substring between split_on instances relative to previous substr. Behaves similar to strtok with substr being used as state for next split.\n\nReturns true each time substr is set and false when there is no more splits (substr is set to empty in that case).\n\nExample usage. struct aws_byte_cursor substr = {0}; while (aws_byte_cursor_next_split(&input_str, ';', &substr)) { // ...use substr... }\n\nNote: It is the user's responsibility zero-initialize substr before the first call.\n\nEdge case rules are as follows: empty input will have single empty split. ex. \"\" splits into \"\" if input starts with split_on then first split is empty. ex \";A\" splits into \"\", \"A\" adjacent split tokens result in empty split. ex \"A;;B\" splits into \"A\", \"\", \"B\" If the input ends with split_on, last split is empty. ex. \"A;\" splits into \"A\", \"\"\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nbool aws_byte_cursor_next_split( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, struct aws_byte_cursor *AWS_RESTRICT substr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read","text":"aws_byte_cursor_read(cur, dest, len)\n\nReads specified length of data from byte cursor and copies it to the destination array.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read( struct aws_byte_cursor *AWS_RESTRICT cur, void *AWS_RESTRICT dest, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_and_fill_buffer-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_and_fill_buffer","text":"aws_byte_cursor_read_and_fill_buffer(cur, dest)\n\nReads as many bytes from cursor as size of buffer, and copies them to buffer.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_and_fill_buffer( struct aws_byte_cursor *AWS_RESTRICT cur, struct aws_byte_buf *AWS_RESTRICT dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_be16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_be16","text":"aws_byte_cursor_read_be16(cur, var)\n\nReads a 16-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be16(struct aws_byte_cursor *cur, uint16_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_be24-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_be24","text":"aws_byte_cursor_read_be24(cur, var)\n\nReads an unsigned 24-bit value (3 bytes) in network byte order from cur, and places it in host byte order into 32-bit var. Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be24(struct aws_byte_cursor *cur, uint32_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_be32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_be32","text":"aws_byte_cursor_read_be32(cur, var)\n\nReads a 32-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be32(struct aws_byte_cursor *cur, uint32_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_be64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_be64","text":"aws_byte_cursor_read_be64(cur, var)\n\nReads a 64-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_be64(struct aws_byte_cursor *cur, uint64_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_float_be32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_float_be32","text":"aws_byte_cursor_read_float_be32(cur, var)\n\nReads a 32-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_float_be32(struct aws_byte_cursor *cur, float *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_float_be64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_float_be64","text":"aws_byte_cursor_read_float_be64(cur, var)\n\nReads a 64-bit value in network byte order from cur, and places it in host byte order into var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_float_be64(struct aws_byte_cursor *cur, double *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_hex_u8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_hex_u8","text":"aws_byte_cursor_read_hex_u8(cur, var)\n\nReads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number. Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'. For example: \"0F\" produces 15.\n\nOn success, returns true and advances the cursor by 2. If there is insufficient space in the cursor or an invalid character is encountered, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_hex_u8(struct aws_byte_cursor *cur, uint8_t *var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_read_u8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_read_u8","text":"aws_byte_cursor_read_u8(cur, var)\n\nReads a single byte from cursor, placing it in *var.\n\nOn success, returns true and updates the cursor pointer/length accordingly. If there is insufficient space in the cursor, returns false, leaving the cursor unchanged.\n\nPrototype\n\nbool aws_byte_cursor_read_u8(struct aws_byte_cursor *AWS_RESTRICT cur, uint8_t *AWS_RESTRICT var);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_right_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_right_trim_pred","text":"aws_byte_cursor_right_trim_pred(source, predicate)\n\nShrinks a byte cursor from the right for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_right_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_satisfies_pred-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_satisfies_pred","text":"aws_byte_cursor_satisfies_pred(source, predicate)\n\nReturns true if the byte cursor's range of bytes all satisfy the predicate\n\nPrototype\n\nbool aws_byte_cursor_satisfies_pred(const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_split_on_char-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_split_on_char","text":"aws_byte_cursor_split_on_char(input_str, split_on, output)\n\nNo copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is an offset into the input_str and len is the length of that string in the original buffer.\n\nEdge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output. if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.\n\nIt is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\nThe type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nint aws_byte_cursor_split_on_char( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, struct aws_array_list *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_split_on_char_n-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_split_on_char_n","text":"aws_byte_cursor_split_on_char_n(input_str, split_on, n, output)\n\nNo copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is an offset into the input_str and len is the length of that string in the original buffer. N is the max number of splits, if this value is zero, it will add all splits to the output.\n\nEdge case rules are as follows: if the input begins with split_on, an empty cursor will be the first entry in output if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output. if the input ends with split_on, an empty cursor will be appended to the output.\n\nIt is the user's responsibility to properly initialize output. Recommended number of preallocated elements from output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\nIf the output array is not large enough, input_str will be updated to point to the first character after the last processed split_on instance.\n\nThe type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\nIt is the user's responsibility to make sure the input buffer stays in memory long enough to use the results.\n\nPrototype\n\nint aws_byte_cursor_split_on_char_n( const struct aws_byte_cursor *AWS_RESTRICT input_str, char split_on, size_t n, struct aws_array_list *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_starts_with-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_starts_with","text":"aws_byte_cursor_starts_with(input, prefix)\n\nReturn true if the input starts with the prefix (exact byte comparison).\n\nPrototype\n\nbool aws_byte_cursor_starts_with(const struct aws_byte_cursor *input, const struct aws_byte_cursor *prefix);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_starts_with_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_starts_with_ignore_case","text":"aws_byte_cursor_starts_with_ignore_case(input, prefix)\n\nReturn true if the input starts with the prefix (case-insensitive). The \"C\" locale is used for comparing upper and lowercase letters. Data is assumed to be ASCII text, UTF-8 will work fine too.\n\nPrototype\n\nbool aws_byte_cursor_starts_with_ignore_case(const struct aws_byte_cursor *input, const struct aws_byte_cursor *prefix);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_trim_pred-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_trim_pred","text":"aws_byte_cursor_trim_pred(source, predicate)\n\nShrinks a byte cursor from both sides for as long as the supplied predicate is true\n\nPrototype\n\nstruct aws_byte_cursor aws_byte_cursor_trim_pred( const struct aws_byte_cursor *source, aws_byte_predicate_fn *predicate);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_utf8_parse_u64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_utf8_parse_u64","text":"aws_byte_cursor_utf8_parse_u64(cursor, dst)\n\nRead entire cursor as ASCII/UTF-8 unsigned base-10 number. Stricter than strtoull(), which allows whitespace and inputs that start with \"0x\"\n\nExamples: \"0\" -> 0 \"123\" -> 123 \"00004\" -> 4 // leading zeros ok\n\nRejects things like: \"-1\" // negative numbers not allowed \"1,000\" // only characters 0-9 allowed \"\" // blank string not allowed \" 0 \" // whitespace not allowed \"0x0\" // hex not allowed \"FF\" // hex not allowed \"999999999999999999999999999999999999999999\" // larger than max u64\n\nPrototype\n\nint aws_byte_cursor_utf8_parse_u64(struct aws_byte_cursor cursor, uint64_t *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_byte_cursor_utf8_parse_u64_hex-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_byte_cursor_utf8_parse_u64_hex","text":"aws_byte_cursor_utf8_parse_u64_hex(cursor, dst)\n\nRead entire cursor as ASCII/UTF-8 unsigned base-16 number with NO \"0x\" prefix.\n\nExamples: \"F\" -> 15 \"000000ff\" -> 255 // leading zeros ok \"Ff\" -> 255 // mixed case ok \"123\" -> 291 \"FFFFFFFFFFFFFFFF\" -> 18446744073709551616 // max u64\n\nRejects things like: \"0x0\" // 0x prefix not allowed \"\" // blank string not allowed \" F \" // whitespace not allowed \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" // larger than max u64\n\nPrototype\n\nint aws_byte_cursor_utf8_parse_u64_hex(struct aws_byte_cursor cursor, uint64_t *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_c_string_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_c_string_is_valid","text":"aws_c_string_is_valid(str)\n\nBest-effort checks aws_string invariants, when the str->len is unknown\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_c_string_is_valid(const char *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_base_default_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_base_default_clear","text":"aws_cache_base_default_clear(cache)\n\nPrototype\n\nvoid aws_cache_base_default_clear(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_base_default_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_base_default_destroy","text":"aws_cache_base_default_destroy(cache)\n\nPrototype\n\nvoid aws_cache_base_default_destroy(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_base_default_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_cache_base_default_find","text":"aws_cache_base_default_find(cache, key, p_value)\n\nPrototype\n\nint aws_cache_base_default_find(struct aws_cache *cache, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_base_default_get_element_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_base_default_get_element_count","text":"aws_cache_base_default_get_element_count(cache)\n\nPrototype\n\nsize_t aws_cache_base_default_get_element_count(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_base_default_remove-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_cache_base_default_remove","text":"aws_cache_base_default_remove(cache, key)\n\nPrototype\n\nint aws_cache_base_default_remove(struct aws_cache *cache, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_clear","text":"aws_cache_clear(cache)\n\nClears all items from the cache.\n\nPrototype\n\nvoid aws_cache_clear(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_destroy","text":"aws_cache_destroy(cache)\n\nCleans up the cache. Elements in the cache will be evicted and cleanup callbacks will be invoked.\n\nPrototype\n\nvoid aws_cache_destroy(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_cache_find","text":"aws_cache_find(cache, key, p_value)\n\nFinds element in the cache by key. If found, *p_value will hold the stored value, and AWS_OP_SUCCESS will be returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nIf any errors occur AWS_OP_ERR will be returned.\n\nPrototype\n\nint aws_cache_find(struct aws_cache *cache, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_get_element_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cache_get_element_count","text":"aws_cache_get_element_count(cache)\n\nReturns the number of elements in the cache.\n\nPrototype\n\nsize_t aws_cache_get_element_count(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_new_fifo-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_cache_new_fifo","text":"aws_cache_new_fifo(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the first-in-first-out cache. Sets up the underlying linked hash table. Once max_items elements have been added, the oldest(first-in) item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nstruct aws_cache *aws_cache_new_fifo( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_new_lifo-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_cache_new_lifo","text":"aws_cache_new_lifo(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the last-in-first-out cache. Sets up the underlying linked hash table. Once max_items elements have been added, the latest(last-in) item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nstruct aws_cache *aws_cache_new_lifo( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_new_lru-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_cache_new_lru","text":"aws_cache_new_lru(allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, max_items)\n\nInitializes the Least-recently-used cache. Sets up the underlying linked hash table. Once max_items elements have been added, the least recently used item will be removed. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.(Yes the one that was the answer to that interview question that one time).\n\nPrototype\n\nstruct aws_cache *aws_cache_new_lru( struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t max_items);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_put-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_cache_put","text":"aws_cache_put(cache, key, p_value)\n\nPuts p_value at key. If an element is already stored at key it will be replaced. If the cache is already full, an item will be removed based on the cache policy.\n\nPrototype\n\nint aws_cache_put(struct aws_cache *cache, const void *key, void *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cache_remove-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_cache_remove","text":"aws_cache_remove(cache, key)\n\nRemoves item at key from the cache.\n\nPrototype\n\nint aws_cache_remove(struct aws_cache *cache, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cal_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_cal_library_clean_up","text":"aws_cal_library_clean_up()\n\nPrototype\n\nvoid aws_cal_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cal_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cal_library_init","text":"aws_cal_library_init(allocator)\n\nPrototype\n\nvoid aws_cal_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cal_thread_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_cal_thread_clean_up","text":"aws_cal_thread_clean_up()\n\nPrototype\n\nvoid aws_cal_thread_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_acquire_hold-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_acquire_hold","text":"aws_channel_acquire_hold(channel)\n\nPrevent a channel's memory from being freed. Any number of users may acquire a hold to prevent a channel and its handlers from being unexpectedly freed. Any user which acquires a hold must release it via aws_channel_release_hold(). Memory will be freed once all holds are released and aws_channel_destroy() has been called.\n\nPrototype\n\nvoid aws_channel_acquire_hold(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_acquire_message_from_pool-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_acquire_message_from_pool","text":"aws_channel_acquire_message_from_pool(channel, message_type, size_hint)\n\nAcquires a message from the event loop's message pool. size_hint is merely a hint, it may be smaller than you requested and you are responsible for checking the bounds of it. If the returned message is not large enough, you must send multiple messages.\n\nPrototype\n\nstruct aws_io_message *aws_channel_acquire_message_from_pool( struct aws_channel *channel, enum aws_io_message_type message_type, size_t size_hint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_current_clock_time-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_current_clock_time","text":"aws_channel_current_clock_time(channel, time_nanos)\n\nFetches the current timestamp from the event-loop's clock, in nanoseconds.\n\nPrototype\n\nint aws_channel_current_clock_time(struct aws_channel *channel, uint64_t *time_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_destroy","text":"aws_channel_destroy(channel)\n\nMark the channel, along with all slots and handlers, for destruction. Must be called after shutdown has completed. Can be called from any thread assuming 'aws_channel_shutdown()' has completed. Note that memory will not be freed until all users which acquired holds on the channel via aws_channel_acquire_hold(), release them via aws_channel_release_hold().\n\nPrototype\n\nvoid aws_channel_destroy(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_fetch_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_fetch_local_object","text":"aws_channel_fetch_local_object(channel, key, obj)\n\nRetrieves an object by key from the event loop's local storage.\n\nPrototype\n\nint aws_channel_fetch_local_object( struct aws_channel *channel, const void *key, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_get_event_loop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_get_event_loop","text":"aws_channel_get_event_loop(channel)\n\nFetches the event loop the channel is a part of.\n\nPrototype\n\nstruct aws_event_loop *aws_channel_get_event_loop(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_get_first_slot-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_get_first_slot","text":"aws_channel_get_first_slot(channel)\n\nPrototype\n\nstruct aws_channel_slot *aws_channel_get_first_slot(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_destroy","text":"aws_channel_handler_destroy(handler)\n\nCalls destroy on handler's vtable\n\nPrototype\n\nvoid aws_channel_handler_destroy(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_increment_read_window-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_increment_read_window","text":"aws_channel_handler_increment_read_window(handler, slot, size)\n\nCalls on_window_update on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_increment_read_window( struct aws_channel_handler *handler, struct aws_channel_slot *slot, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_initial_window_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_initial_window_size","text":"aws_channel_handler_initial_window_size(handler)\n\nCalls initial_window_size on handler's vtable.\n\nPrototype\n\nsize_t aws_channel_handler_initial_window_size(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_process_read_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_process_read_message","text":"aws_channel_handler_process_read_message(handler, slot, message)\n\nCalls process_read_message on handler's vtable\n\nPrototype\n\nint aws_channel_handler_process_read_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_process_write_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_process_write_message","text":"aws_channel_handler_process_write_message(handler, slot, message)\n\nCalls process_write_message on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_process_write_message( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_handler_shutdown-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_channel_handler_shutdown","text":"aws_channel_handler_shutdown(handler, slot, dir, error_code, free_scarce_resources_immediately)\n\ncalls shutdown_direction on handler's vtable.\n\nPrototype\n\nint aws_channel_handler_shutdown( struct aws_channel_handler *handler, struct aws_channel_slot *slot, enum aws_channel_direction dir, int error_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_new","text":"aws_channel_new(allocator, creation_args)\n\nAllocates new channel, Unless otherwise specified all functions for channels and channel slots must be executed within that channel's event-loop's thread. channel_options are copied.\n\nPrototype\n\nstruct aws_channel *aws_channel_new(struct aws_allocator *allocator, const struct aws_channel_options *creation_args);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_put_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_put_local_object","text":"aws_channel_put_local_object(channel, key, obj)\n\nStores an object by key in the event loop's local storage.\n\nPrototype\n\nint aws_channel_put_local_object( struct aws_channel *channel, const void *key, const struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_release_hold-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_release_hold","text":"aws_channel_release_hold(channel)\n\nRelease a hold on the channel's memory, allowing it to be freed. This may be called before or after aws_channel_destroy().\n\nPrototype\n\nvoid aws_channel_release_hold(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_remove_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_remove_local_object","text":"aws_channel_remove_local_object(channel, key, removed_obj)\n\nRemoves an object by key from the event loop's local storage.\n\nPrototype\n\nint aws_channel_remove_local_object( struct aws_channel *channel, const void *key, struct aws_event_loop_local_object *removed_obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_schedule_task_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_schedule_task_future","text":"aws_channel_schedule_task_future(channel, task, run_at_nanos)\n\nSchedules a task to run on the event loop at the specified time. This is the ideal way to move a task into the correct thread. It's also handy for context switches. Use aws_channel_current_clock_time() to get the current time in nanoseconds. This function is safe to call from any thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_future( struct aws_channel *channel, struct aws_channel_task *task, uint64_t run_at_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_schedule_task_now-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_schedule_task_now","text":"aws_channel_schedule_task_now(channel, task)\n\nSchedules a task to run on the event loop as soon as possible. This is the ideal way to move a task into the correct thread. It's also handy for context switches. This function is safe to call from any thread.\n\nIf called from the channel's event loop, the task will get directly added to the run-now list. If called from outside the channel's event loop, the task will go into a cross-thread task queue.\n\nIf tasks must be serialized relative to some source synchronization, you may not want to use this API because tasks submitted from the event loop thread can \"jump ahead\" of tasks submitted from external threads due to this optimization. If this is a problem, you can either refactor your submission logic or use the aws_channel_schedule_task_now_serialized variant which does not perform this optimization.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_now(struct aws_channel *channel, struct aws_channel_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_schedule_task_now_serialized-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_schedule_task_now_serialized","text":"aws_channel_schedule_task_now_serialized(channel, task)\n\nSchedules a task to run on the event loop as soon as possible.\n\nThis variant always uses the cross thread queue rather than conditionally skipping it when already in the destination event loop. While not \"optimal\", this allows us to serialize task execution no matter where the task was submitted from: if you are submitting tasks from a critical section, the serialized order that you submit is guaranteed to be the order that they execute on the event loop.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_channel_schedule_task_now_serialized(struct aws_channel *channel, struct aws_channel_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_set_statistics_handler-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_set_statistics_handler","text":"aws_channel_set_statistics_handler(channel, handler)\n\nInstrument a channel with a statistics handler. While instrumented with a statistics handler, the channel will periodically report per-channel-handler-specific statistics about handler performance and state.\n\nAssigning a statistics handler to a channel is a transfer of ownership – the channel will clean up the handler appropriately. Statistics handlers may be changed dynamically (for example, the upgrade from a vanilla http channel to a websocket channel), but this function may only be called from the event loop thread that the channel is a part of.\n\nThe first possible hook to set a statistics handler is the channel's creation callback.\n\nPrototype\n\nint aws_channel_set_statistics_handler(struct aws_channel *channel, struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_setup_client_tls-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_setup_client_tls","text":"aws_channel_setup_client_tls(right_of_slot, tls_options)\n\n******************************* Misc TLS related ********************************\n\nPrototype\n\nint aws_channel_setup_client_tls( struct aws_channel_slot *right_of_slot, struct aws_tls_connection_options *tls_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_shutdown-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_shutdown","text":"aws_channel_shutdown(channel, error_code)\n\nInitiates shutdown of the channel. Shutdown will begin with the left-most slot. Each handler will invoke 'aws_channel_slot_on_handler_shutdown_complete' once they've finished their shutdown process for the read direction. Once the right-most slot has shutdown in the read direction, the process will start shutting down starting on the right-most slot. Once the left-most slot has shutdown in the write direction, 'callbacks->shutdown_completed' will be invoked in the event loop's thread.\n\nThis function can be called from any thread.\n\nPrototype\n\nint aws_channel_shutdown(struct aws_channel *channel, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_acquire_max_message_for_write-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_acquire_max_message_for_write","text":"aws_channel_slot_acquire_max_message_for_write(slot)\n\nConvenience function that invokes aws_channel_acquire_message_from_pool(), asking for the largest reasonable DATA message that can be sent in the write direction, with upstream overhead accounted for.\n\nPrototype\n\nstruct aws_io_message *aws_channel_slot_acquire_max_message_for_write(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_downstream_read_window-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_downstream_read_window","text":"aws_channel_slot_downstream_read_window(slot)\n\nFetches the downstream read window. This gives you the information necessary to honor the read window. If you call send_message() and it exceeds this window, the message will be rejected.\n\nPrototype\n\nsize_t aws_channel_slot_downstream_read_window(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_increment_read_window","text":"aws_channel_slot_increment_read_window(slot, window)\n\nIssues a window update notification upstream (to the left.)\n\nPrototype\n\nint aws_channel_slot_increment_read_window(struct aws_channel_slot *slot, size_t window);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_insert_end-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_insert_end","text":"aws_channel_slot_insert_end(channel, to_add)\n\nInserts to 'to_add' the end of the channel. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_end(struct aws_channel *channel, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_insert_left-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_insert_left","text":"aws_channel_slot_insert_left(slot, to_add)\n\ninserts 'to_add' to the position immediately to the left of slot. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_left(struct aws_channel_slot *slot, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_insert_right-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_insert_right","text":"aws_channel_slot_insert_right(slot, to_add)\n\ninserts 'to_add' to the position immediately to the right of slot. Note that the first call to aws_channel_slot_new() adds it to the channel implicitly.\n\nPrototype\n\nint aws_channel_slot_insert_right(struct aws_channel_slot *slot, struct aws_channel_slot *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_new","text":"aws_channel_slot_new(channel)\n\nAllocates and initializes a new slot for use with the channel. If this is the first slot in the channel, it will automatically be added to the channel as the first slot. For all subsequent calls on a given channel, the slot will need to be added to the channel via. the aws_channel_slot_insert_right(), aws_channel_slot_insert_end(), and aws_channel_slot_insert_left() APIs.\n\nPrototype\n\nstruct aws_channel_slot *aws_channel_slot_new(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_on_handler_shutdown_complete-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_on_handler_shutdown_complete","text":"aws_channel_slot_on_handler_shutdown_complete(slot, dir, err_code, free_scarce_resources_immediately)\n\nCalled by handlers once they have finished their shutdown in the 'dir' direction. Propagates the shutdown process to the next handler in the channel.\n\nPrototype\n\nint aws_channel_slot_on_handler_shutdown_complete( struct aws_channel_slot *slot, enum aws_channel_direction dir, int err_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_remove-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_remove","text":"aws_channel_slot_remove(slot)\n\nRemoves slot from the channel and deallocates the slot and its handler.\n\nPrototype\n\nint aws_channel_slot_remove(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_replace-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_replace","text":"aws_channel_slot_replace(remove, new_slot)\n\nReplaces remove with new_slot. Deallocates remove and its handler.\n\nPrototype\n\nint aws_channel_slot_replace(struct aws_channel_slot *remove, struct aws_channel_slot *new_slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_send_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_send_message","text":"aws_channel_slot_send_message(slot, message, dir)\n\nSends a message to the adjacent slot in the channel based on dir. Also does window size checking.\n\nNOTE: if this function returns an error code, it is the caller's responsibility to release message back to the pool. If this function returns AWS_OP_SUCCESS, the recipient of the message has taken ownership of the message. So, for example, don't release a message to the pool and then return an error. If you encounter an error condition in this case, shutdown the channel with the appropriate error code.\n\nPrototype\n\nint aws_channel_slot_send_message( struct aws_channel_slot *slot, struct aws_io_message *message, enum aws_channel_direction dir);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_set_handler-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_set_handler","text":"aws_channel_slot_set_handler(slot, handler)\n\nSets the handler for a slot, the slot will also call get_current_window_size() and propagate a window update upstream.\n\nPrototype\n\nint aws_channel_slot_set_handler(struct aws_channel_slot *slot, struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_shutdown-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_shutdown","text":"aws_channel_slot_shutdown(slot, dir, err_code, free_scarce_resources_immediately)\n\nInitiates shutdown on slot. callbacks->on_shutdown_completed will be called once the shutdown process is completed.\n\nPrototype\n\nint aws_channel_slot_shutdown( struct aws_channel_slot *slot, enum aws_channel_direction dir, int err_code, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_slot_upstream_message_overhead-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_slot_upstream_message_overhead","text":"aws_channel_slot_upstream_message_overhead(slot)\n\nFetches the current overhead of upstream handlers. This provides a hint to avoid fragmentation if you care.\n\nPrototype\n\nsize_t aws_channel_slot_upstream_message_overhead(struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_task_init-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_channel_task_init","text":"aws_channel_task_init(channel_task, task_fn, arg, type_tag)\n\nInitializes channel_task for use.\n\nPrototype\n\nvoid aws_channel_task_init( struct aws_channel_task *channel_task, aws_channel_task_fn *task_fn, void *arg, const char *type_tag);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_thread_is_callers_thread-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_thread_is_callers_thread","text":"aws_channel_thread_is_callers_thread(channel)\n\nReturns true if the caller is on the event loop's thread. If false, you likely need to use aws_channel_schedule_task(). This function is safe to call from any thread.\n\nPrototype\n\nbool aws_channel_thread_is_callers_thread(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_channel_trigger_read-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_channel_trigger_read","text":"aws_channel_trigger_read(channel)\n\nA way for external processes to force a read by the data-source channel handler. Necessary in certain cases, like when a server channel finishes setting up its initial handlers, a read may have already been triggered on the socket (the client's CLIENT_HELLO tls payload, for example) and absent further data/notifications, this data would never get processed.\n\nPrototype\n\nint aws_channel_trigger_read(struct aws_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_char_is_space-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_char_is_space","text":"aws_char_is_space(c)\n\nEvaluates if a char is a white character.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_char_is_space(uint8_t c);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_checksums_crc32-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_checksums_crc32","text":"aws_checksums_crc32(input, length, previousCrc32)\n\nThe entry point function to perform a CRC32 (Ethernet, gzip) computation. Selects a suitable implementation based on hardware capabilities. Pass 0 in the previousCrc32 parameter as an initial value unless continuing to update a running crc in a subsequent call.\n\nPrototype\n\nuint32_t aws_checksums_crc32(const uint8_t *input, int length, uint32_t previousCrc32);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_checksums_crc32c-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_checksums_crc32c","text":"aws_checksums_crc32c(input, length, previousCrc32)\n\nThe entry point function to perform a Castagnoli CRC32c (iSCSI) computation. Selects a suitable implementation based on hardware capabilities. Pass 0 in the previousCrc32 parameter as an initial value unless continuing to update a running crc in a subsequent call.\n\nPrototype\n\nuint32_t aws_checksums_crc32c(const uint8_t *input, int length, uint32_t previousCrc32);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cli_dispatch_on_subcommand-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_cli_dispatch_on_subcommand","text":"aws_cli_dispatch_on_subcommand(argc, argv, dispatch_table, table_length, user_data)\n\nDispatches the current command line arguments with a subcommand from the second input argument in argv[], if dispatch table contains a command that matches the argument. When the command is dispatched, argc and argv will be updated to reflect the new argument count. The cli options are required to come after the subcommand. If either, no dispatch was found or there was no argument passed to the program, this function will return AWS_OP_ERR. Check aws_last_error() for details on the error.\n\nParameters\n\nargc: number of arguments passed to int main()\nargv: the arguments passed to int main()\nparse_cb,: optional, specify NULL if you don't want to handle this. This argument is for parsing \"meta\" commands from the command line options prior to dispatch occurring.\ndispatch_table: table containing functions and command name to dispatch on.\ntable_length: number of entries in dispatch_table.\n\nReturns\n\nAWS_OP_SUCCESS(0) on success, AWS_OP_ERR(-1) on failure\n\nPrototype\n\nint aws_cli_dispatch_on_subcommand( int argc, char *const argv[], struct aws_cli_subcommand_dispatch *dispatch_table, int table_length, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cli_getopt_long-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_cli_getopt_long","text":"aws_cli_getopt_long(argc, argv, optstring, longopts, longindex)\n\nA mostly compliant implementation of posix getopt_long(). Parses command-line arguments. argc is the number of command line arguments passed in argv. optstring contains the legitimate option characters. The option characters correspond to aws_cli_option::val. If the character is followed by a :, the option requires an argument. If it is followed by '::', the argument is optional (not implemented yet).\n\nlongopts, is an array of struct aws_cli_option. These are the allowed options for the program. The last member of the array must be zero initialized.\n\nIf longindex is non-null, it will be set to the index in longopts, for the found option.\n\nReturns option val if it was found, '?' if an option was encountered that was not specified in the option string, 0x02 (START_OF_TEXT) will be returned if a positional argument was encountered. returns -1 when all arguments that can be parsed have been parsed.\n\nPrototype\n\nint aws_cli_getopt_long( int argc, char *const argv[], const char *optstring, const struct aws_cli_option *longopts, int *longindex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cli_reset_state-Tuple{}","page":"Home","title":"LibAWSCRT.aws_cli_reset_state","text":"aws_cli_reset_state()\n\nResets global parser state for use in another parser run for the application.\n\nPrototype\n\nvoid aws_cli_reset_state(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_client_bootstrap_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_acquire","text":"aws_client_bootstrap_acquire(bootstrap)\n\nIncrements a client bootstrap's ref count, allowing the caller to take a reference to it.\n\nReturns the same client bootstrap passed in.\n\nPrototype\n\nstruct aws_client_bootstrap *aws_client_bootstrap_acquire(struct aws_client_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_client_bootstrap_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_new","text":"aws_client_bootstrap_new(allocator, options)\n\nCreate the client bootstrap.\n\nPrototype\n\nstruct aws_client_bootstrap *aws_client_bootstrap_new( struct aws_allocator *allocator, const struct aws_client_bootstrap_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_client_bootstrap_new_socket_channel-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_new_socket_channel","text":"aws_client_bootstrap_new_socket_channel(options)\n\nSets up a client socket channel.\n\nPrototype\n\nint aws_client_bootstrap_new_socket_channel(struct aws_socket_channel_bootstrap_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_client_bootstrap_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_release","text":"aws_client_bootstrap_release(bootstrap)\n\nDecrements a client bootstrap's ref count. When the ref count drops to zero, the bootstrap will be destroyed.\n\nPrototype\n\nvoid aws_client_bootstrap_release(struct aws_client_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_client_bootstrap_set_alpn_callback-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_client_bootstrap_set_alpn_callback","text":"aws_client_bootstrap_set_alpn_callback(bootstrap, on_protocol_negotiated)\n\nWhen using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added to the channel.\n\nPrototype\n\nint aws_client_bootstrap_set_alpn_callback( struct aws_client_bootstrap *bootstrap, aws_channel_on_protocol_negotiated_fn *on_protocol_negotiated);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_clz_i32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_clz_i32","text":"aws_clz_i32(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_i32(int32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_clz_i64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_clz_i64","text":"aws_clz_i64(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_i64(int64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_clz_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_clz_size","text":"aws_clz_size(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_size(size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_clz_u32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_clz_u32","text":"aws_clz_u32(n)\n\nSearch from the MSB to LSB, looking for a 1\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_u32(uint32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_clz_u64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_clz_u64","text":"aws_clz_u64(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_clz_u64(uint64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_common_fatal_assert_library_initialized-Tuple{}","page":"Home","title":"LibAWSCRT.aws_common_fatal_assert_library_initialized","text":"aws_common_fatal_assert_library_initialized()\n\nPrototype\n\nvoid aws_common_fatal_assert_library_initialized(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_common_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_common_library_clean_up","text":"aws_common_library_clean_up()\n\nShuts down the internal data structures used by aws-c-common.\n\nPrototype\n\nvoid aws_common_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_common_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_common_library_init","text":"aws_common_library_init(allocator)\n\nInitializes internal data structures used by aws-c-common. Must be called before using any functionality in aws-c-common.\n\nPrototype\n\nvoid aws_common_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_compression_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_compression_library_clean_up","text":"aws_compression_library_clean_up()\n\nClean up internal datastructures used by aws-c-compression. Must not be called until application is done using functionality in aws-c-compression.\n\nPrototype\n\nvoid aws_compression_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_compression_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_compression_library_init","text":"aws_compression_library_init(alloc)\n\nInitializes internal datastructures used by aws-c-compression. Must be called before using any functionality in aws-c-compression.\n\nPrototype\n\nvoid aws_compression_library_init(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_clean_up","text":"aws_condition_variable_clean_up(condition_variable)\n\nCleans up a condition variable.\n\nPrototype\n\nvoid aws_condition_variable_clean_up(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_init","text":"aws_condition_variable_init(condition_variable)\n\nInitializes a condition variable.\n\nPrototype\n\nint aws_condition_variable_init(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_notify_all-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_notify_all","text":"aws_condition_variable_notify_all(condition_variable)\n\nNotifies/Wakes all waiting threads.\n\nPrototype\n\nint aws_condition_variable_notify_all(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_notify_one-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_notify_one","text":"aws_condition_variable_notify_one(condition_variable)\n\nNotifies/Wakes one waiting thread\n\nPrototype\n\nint aws_condition_variable_notify_one(struct aws_condition_variable *condition_variable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_wait","text":"aws_condition_variable_wait(condition_variable, mutex)\n\nWaits the calling thread on a notification from another thread.\n\nPrototype\n\nint aws_condition_variable_wait(struct aws_condition_variable *condition_variable, struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_wait_for-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_wait_for","text":"aws_condition_variable_wait_for(condition_variable, mutex, time_to_wait)\n\nWaits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in nanoseconds.\n\nPrototype\n\nint aws_condition_variable_wait_for( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, int64_t time_to_wait);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_wait_for_pred-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_wait_for_pred","text":"aws_condition_variable_wait_for_pred(condition_variable, mutex, time_to_wait, pred, pred_ctx)\n\nWaits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in nanoseconds. If predicate returns false, the wait is reentered, otherwise control returns to the caller.\n\nPrototype\n\nint aws_condition_variable_wait_for_pred( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, int64_t time_to_wait, aws_condition_predicate_fn *pred, void *pred_ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_condition_variable_wait_pred-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_condition_variable_wait_pred","text":"aws_condition_variable_wait_pred(condition_variable, mutex, pred, pred_ctx)\n\nWaits the calling thread on a notification from another thread. If predicate returns false, the wait is reentered, otherwise control returns to the caller.\n\nPrototype\n\nint aws_condition_variable_wait_pred( struct aws_condition_variable *condition_variable, struct aws_mutex *mutex, aws_condition_predicate_fn *pred, void *pred_ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_cpu_has_feature-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_cpu_has_feature","text":"aws_cpu_has_feature(feature_name)\n\nReturns true if a cpu feature is supported, false otherwise.\n\nPrototype\n\nbool aws_cpu_has_feature(enum aws_cpu_feature_name feature_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_acquire","text":"aws_credentials_acquire(credentials)\n\nAdd a reference to some credentials\n\nParameters\n\ncredentials: credentials to increment the ref count on\n\nPrototype\n\nvoid aws_credentials_acquire(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_get_access_key_id-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_get_access_key_id","text":"aws_credentials_get_access_key_id(credentials)\n\nGet the AWS access key id from a set of credentials\n\nParameters\n\ncredentials: credentials to get the access key id from\n\nReturns\n\na byte cursor to the access key id\n\nPrototype\n\nstruct aws_byte_cursor aws_credentials_get_access_key_id(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_get_ecc_key_pair-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_get_ecc_key_pair","text":"aws_credentials_get_ecc_key_pair(credentials)\n\nGet the elliptic curve key associated with this set of credentials\n\nParameters\n\ncredentials: credentials to get the the elliptic curve key for\n\nReturns\n\nthe elliptic curve key associated with the credentials, or NULL if no key is associated with these credentials\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_credentials_get_ecc_key_pair(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_get_expiration_timepoint_seconds-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_get_expiration_timepoint_seconds","text":"aws_credentials_get_expiration_timepoint_seconds(credentials)\n\nGet the expiration timepoint (in seconds since epoch) associated with a set of credentials\n\nParameters\n\ncredentials: credentials to get the expiration timepoint for\n\nReturns\n\nthe time, in seconds since epoch, the credentials will expire; UINT64_MAX for credentials without a specific expiration time\n\nPrototype\n\nuint64_t aws_credentials_get_expiration_timepoint_seconds(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_get_secret_access_key-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_get_secret_access_key","text":"aws_credentials_get_secret_access_key(credentials)\n\nGet the AWS secret access key from a set of credentials\n\nParameters\n\ncredentials: credentials to get the secret access key from\n\nReturns\n\na byte cursor to the secret access key\n\nPrototype\n\nstruct aws_byte_cursor aws_credentials_get_secret_access_key(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_get_session_token-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_get_session_token","text":"aws_credentials_get_session_token(credentials)\n\nGet the AWS session token from a set of credentials\n\nParameters\n\ncredentials: credentials to get the session token from\n\nReturns\n\na byte cursor to the session token or an empty byte cursor if there is no session token\n\nPrototype\n\nstruct aws_byte_cursor aws_credentials_get_session_token(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_is_anonymous-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_is_anonymous","text":"aws_credentials_is_anonymous(credentials)\n\nIf credentials are anonymous, then the signing process is skipped.\n\nParameters\n\ncredentials: credentials to check\n\nReturns\n\ntrue if the credentials are anonymous; false otherwise.\n\nPrototype\n\nbool aws_credentials_is_anonymous(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_new-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_new","text":"aws_credentials_new(allocator, access_key_id_cursor, secret_access_key_cursor, session_token_cursor, expiration_timepoint_seconds)\n\nCreates a new set of aws credentials\n\nParameters\n\nallocator: memory allocator to use\naccess_key_id_cursor: value for the aws access key id field\nsecret_access_key_cursor: value for the secret access key field\nsession_token_cursor: (optional) security token associated with the credentials\nexpiration_timepoint_seconds: timepoint, in seconds since epoch, that the credentials will no longer be valid past. For credentials that do not expire, use UINT64_MAX\n\nReturns\n\na valid credentials object, or NULL\n\nPrototype\n\nstruct aws_credentials *aws_credentials_new( struct aws_allocator *allocator, struct aws_byte_cursor access_key_id_cursor, struct aws_byte_cursor secret_access_key_cursor, struct aws_byte_cursor session_token_cursor, uint64_t expiration_timepoint_seconds);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_new_anonymous-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_new_anonymous","text":"aws_credentials_new_anonymous(allocator)\n\nCreates a new set of aws anonymous credentials. Use Anonymous credentials, when you want to skip the signing process.\n\nParameters\n\nallocator: memory allocator to use\n\nReturns\n\na valid credentials object, or NULL\n\nPrototype\n\nstruct aws_credentials *aws_credentials_new_anonymous(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_new_ecc-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_new_ecc","text":"aws_credentials_new_ecc(allocator, access_key_id, ecc_key, session_token, expiration_timepoint_in_seconds)\n\nCreates a set of AWS credentials that includes an ECC key pair. These credentials do not have a value for the secret access key; the ecc key takes over that field's role in sigv4a signing.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\naccess_key_id: access key id for the credential set\necc_key: ecc key to use during signing when using these credentials\nsession_token: (optional) session token associated with the credentials\nexpiration_timepoint_in_seconds: (optional) if session-based, time at which these credentials expire\n\nReturns\n\na new pair of AWS credentials, or NULL\n\nPrototype\n\nstruct aws_credentials *aws_credentials_new_ecc( struct aws_allocator *allocator, struct aws_byte_cursor access_key_id, struct aws_ecc_key_pair *ecc_key, struct aws_byte_cursor session_token, uint64_t expiration_timepoint_in_seconds);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_new_ecc_from_aws_credentials-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_new_ecc_from_aws_credentials","text":"aws_credentials_new_ecc_from_aws_credentials(allocator, credentials)\n\nPrototype\n\nstruct aws_credentials *aws_credentials_new_ecc_from_aws_credentials( struct aws_allocator *allocator, const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_new_from_string-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_new_from_string","text":"aws_credentials_new_from_string(allocator, access_key_id, secret_access_key, session_token, expiration_timepoint_seconds)\n\nCreates a new set of AWS credentials\n\nParameters\n\nallocator: memory allocator to use\naccess_key_id: value for the aws access key id field\nsecret_access_key: value for the secret access key field\nsession_token: (optional) security token associated with the credentials\nexpiration_timepoint_seconds: timepoint, in seconds since epoch, that the credentials will no longer be valid past. For credentials that do not expire, use UINT64_MAX\n\nReturns\n\na valid credentials object, or NULL\n\nPrototype\n\nstruct aws_credentials *aws_credentials_new_from_string( struct aws_allocator *allocator, const struct aws_string *access_key_id, const struct aws_string *secret_access_key, const struct aws_string *session_token, uint64_t expiration_timepoint_seconds);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_acquire","text":"aws_credentials_provider_acquire(provider)\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_acquire(struct aws_credentials_provider *provider);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_get_credentials-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_get_credentials","text":"aws_credentials_provider_get_credentials(provider, callback, user_data)\n\nPrototype\n\nint aws_credentials_provider_get_credentials( struct aws_credentials_provider *provider, aws_on_get_credentials_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_anonymous-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_anonymous","text":"aws_credentials_provider_new_anonymous(allocator, shutdown_options)\n\nCreates a simple anonymous credentials provider\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\nshutdown_options: an optional shutdown callback that gets invoked when the resources used by the provider are no longer in use.\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_anonymous( struct aws_allocator *allocator, const struct aws_credentials_provider_shutdown_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_cached-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_cached","text":"aws_credentials_provider_new_cached(allocator, options)\n\nCreates a provider that functions as a caching decorating of another provider.\n\nFor example, the default chain is implemented as:\n\nCachedProvider -> ProviderChain(EnvironmentProvider -> ProfileProvider -> ECS/EC2IMD etc...)\n\nA reference is taken on the target provider\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_cached( struct aws_allocator *allocator, const struct aws_credentials_provider_cached_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_chain-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_chain","text":"aws_credentials_provider_new_chain(allocator, options)\n\nCreates a provider that sources credentials from an ordered sequence of providers, with the overall result being from the first provider to return a valid set of credentials\n\nReferences are taken on all supplied providers\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_chain( struct aws_allocator *allocator, const struct aws_credentials_provider_chain_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_chain_default-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_chain_default","text":"aws_credentials_provider_new_chain_default(allocator, options)\n\nCreates the default provider chain used by most AWS SDKs.\n\nGenerally:\n\n(1) Environment (2) Profile (3) STS web identity (4) (conditional, off by default) ECS (5) (conditional, on by default) EC2 Instance Metadata\n\nSupport for environmental control of the default provider chain is not yet implemented.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_chain_default( struct aws_allocator *allocator, const struct aws_credentials_provider_chain_default_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_cognito-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_cognito","text":"aws_credentials_provider_new_cognito(allocator, options)\n\nCreates a provider that sources credentials from the Cognito-Identity service via an invocation of the GetCredentialsForIdentity API call.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_cognito( struct aws_allocator *allocator, const struct aws_credentials_provider_cognito_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_cognito_caching-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_cognito_caching","text":"aws_credentials_provider_new_cognito_caching(allocator, options)\n\nCreates a cognito-based provider that has a caching layer wrapped around it\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: cognito-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_cognito_caching( struct aws_allocator *allocator, const struct aws_credentials_provider_cognito_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_delegate-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_delegate","text":"aws_credentials_provider_new_delegate(allocator, options)\n\nCreate a credentials provider depends on provided vtable to fetch the credentials.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_delegate( struct aws_allocator *allocator, const struct aws_credentials_provider_delegate_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_ecs-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_ecs","text":"aws_credentials_provider_new_ecs(allocator, options)\n\nCreates a provider that sources credentials from the ecs role credentials service\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_ecs( struct aws_allocator *allocator, const struct aws_credentials_provider_ecs_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_environment-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_environment","text":"aws_credentials_provider_new_environment(allocator, options)\n\nCreates a provider that returns credentials sourced from the environment variables:\n\nAWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_environment( struct aws_allocator *allocator, const struct aws_credentials_provider_environment_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_imds-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_imds","text":"aws_credentials_provider_new_imds(allocator, options)\n\nCreates a provider that sources credentials from the ec2 instance metadata service\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_imds( struct aws_allocator *allocator, const struct aws_credentials_provider_imds_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_process-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_process","text":"aws_credentials_provider_new_process(allocator, options)\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_process( struct aws_allocator *allocator, const struct aws_credentials_provider_process_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_profile-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_profile","text":"aws_credentials_provider_new_profile(allocator, options)\n\nCreates a provider that sources credentials from key-value profiles loaded from the aws credentials file (\"~/.aws/credentials\" by default) and the aws config file (\"~/.aws/config\" by default)\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_profile( struct aws_allocator *allocator, const struct aws_credentials_provider_profile_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_sso-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_sso","text":"aws_credentials_provider_new_sso(allocator, options)\n\nCreates a provider that sources credentials from SSO using a SSOToken.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_sso( struct aws_allocator *allocator, const struct aws_credentials_provider_sso_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_static-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_static","text":"aws_credentials_provider_new_static(allocator, options)\n\nCreates a simple provider that just returns a fixed set of credentials\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_static( struct aws_allocator *allocator, const struct aws_credentials_provider_static_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_sts-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_sts","text":"aws_credentials_provider_new_sts(allocator, options)\n\nCreates a provider that assumes an IAM role via. STS AssumeRole() API. This provider will fetch new credentials upon each call to aws_credentials_provider_get_credentials().\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_sts( struct aws_allocator *allocator, const struct aws_credentials_provider_sts_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_sts_web_identity-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_sts_web_identity","text":"aws_credentials_provider_new_sts_web_identity(allocator, options)\n\nCreates a provider that sources credentials from STS using AssumeRoleWithWebIdentity\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_sts_web_identity( struct aws_allocator *allocator, const struct aws_credentials_provider_sts_web_identity_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_new_x509-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_new_x509","text":"aws_credentials_provider_new_x509(allocator, options)\n\nCreates a provider that sources credentials from IoT Core\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\noptions: provider-specific configuration options\n\nReturns\n\nthe newly-constructed credentials provider, or NULL if an error occurred.\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_new_x509( struct aws_allocator *allocator, const struct aws_credentials_provider_x509_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_provider_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_provider_release","text":"aws_credentials_provider_release(provider)\n\nRelease a reference to a credentials provider\n\nParameters\n\nprovider: provider to decrement the ref count on\n\nPrototype\n\nstruct aws_credentials_provider *aws_credentials_provider_release(struct aws_credentials_provider *provider);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_credentials_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_credentials_release","text":"aws_credentials_release(credentials)\n\nRemove a reference to some credentials\n\nParameters\n\ncredentials: credentials to decrement the ref count on\n\nPrototype\n\nvoid aws_credentials_release(const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_handler_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_handler_destroy","text":"aws_crt_statistics_handler_destroy(handler)\n\ncompletely destroys a statistics handler. The handler's cleanup function must clean up the impl portion completely (including its allocation, if done separately).\n\nPrototype\n\nvoid aws_crt_statistics_handler_destroy(struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_handler_get_report_interval_ms-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_handler_get_report_interval_ms","text":"aws_crt_statistics_handler_get_report_interval_ms(handler)\n\nQueries the frequency (via an interval in milliseconds) which a statistics handler would like to be informed of statistics.\n\nPrototype\n\nuint64_t aws_crt_statistics_handler_get_report_interval_ms(struct aws_crt_statistics_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_handler_process_statistics-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_handler_process_statistics","text":"aws_crt_statistics_handler_process_statistics(handler, interval, stats, context)\n\nSubmits a list of statistics objects to a statistics handler for processing\n\nhandler - the statistics handler that will process the statistics objects interval - time period over which the statistics were gathered stats - list of pointers to structures that can be case to aws_crt_statistics_base (i.e. have category as a first member) context - (optional) additional context specific to where the statistics handler has been attached\n\nPrototype\n\nvoid aws_crt_statistics_handler_process_statistics( struct aws_crt_statistics_handler *handler, struct aws_crt_statistics_sample_interval *interval, struct aws_array_list *stats, void *context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_http1_channel_cleanup-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http1_channel_cleanup","text":"aws_crt_statistics_http1_channel_cleanup(stats)\n\nCleans up a http channel handler statistics struct\n\nPrototype\n\nvoid aws_crt_statistics_http1_channel_cleanup(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_http1_channel_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http1_channel_init","text":"aws_crt_statistics_http1_channel_init(stats)\n\nInitializes a http channel handler statistics struct\n\nPrototype\n\nint aws_crt_statistics_http1_channel_init(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_http1_channel_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http1_channel_reset","text":"aws_crt_statistics_http1_channel_reset(stats)\n\nResets a http channel handler statistics struct's statistics\n\nPrototype\n\nvoid aws_crt_statistics_http1_channel_reset(struct aws_crt_statistics_http1_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_http2_channel_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http2_channel_init","text":"aws_crt_statistics_http2_channel_init(stats)\n\nInitializes a HTTP/2 channel handler statistics struct\n\nPrototype\n\nvoid aws_crt_statistics_http2_channel_init(struct aws_crt_statistics_http2_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_http2_channel_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_http2_channel_reset","text":"aws_crt_statistics_http2_channel_reset(stats)\n\nResets a HTTP/2 channel handler statistics struct's statistics\n\nPrototype\n\nvoid aws_crt_statistics_http2_channel_reset(struct aws_crt_statistics_http2_channel *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_socket_cleanup-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_socket_cleanup","text":"aws_crt_statistics_socket_cleanup(stats)\n\nCleans up socket channel handler statistics\n\nPrototype\n\nvoid aws_crt_statistics_socket_cleanup(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_socket_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_socket_init","text":"aws_crt_statistics_socket_init(stats)\n\nInitializes socket channel handler statistics\n\nPrototype\n\nint aws_crt_statistics_socket_init(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_socket_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_socket_reset","text":"aws_crt_statistics_socket_reset(stats)\n\nResets socket channel handler statistics for the next gather interval. Calculate-once results are left alone.\n\nPrototype\n\nvoid aws_crt_statistics_socket_reset(struct aws_crt_statistics_socket *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_tls_cleanup-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_tls_cleanup","text":"aws_crt_statistics_tls_cleanup(stats)\n\nCleans up tls channel handler statistics\n\nPrototype\n\nvoid aws_crt_statistics_tls_cleanup(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_tls_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_tls_init","text":"aws_crt_statistics_tls_init(stats)\n\nInitializes tls channel handler statistics\n\nPrototype\n\nint aws_crt_statistics_tls_init(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_crt_statistics_tls_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_crt_statistics_tls_reset","text":"aws_crt_statistics_tls_reset(stats)\n\nResets tls channel handler statistics for the next gather interval. Calculate-once results are left alone.\n\nPrototype\n\nvoid aws_crt_statistics_tls_reset(struct aws_crt_statistics_tls *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ctz_i32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ctz_i32","text":"aws_ctz_i32(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_i32(int32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ctz_i64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ctz_i64","text":"aws_ctz_i64(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_i64(int64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ctz_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ctz_size","text":"aws_ctz_size(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_size(size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ctz_u32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ctz_u32","text":"aws_ctz_u32(n)\n\nSearch from the LSB to MSB, looking for a 1\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_u32(uint32_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ctz_u64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ctz_u64","text":"aws_ctz_u64(n)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_ctz_u64(uint64_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_custom_key_op_handler_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_custom_key_op_handler_acquire","text":"aws_custom_key_op_handler_acquire(key_op_handler)\n\nIncreases the reference count for the passed-in aws_custom_key_op_handler and returns it.\n\nPrototype\n\nstruct aws_custom_key_op_handler *aws_custom_key_op_handler_acquire( struct aws_custom_key_op_handler *key_op_handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_custom_key_op_handler_perform_operation-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_custom_key_op_handler_perform_operation","text":"aws_custom_key_op_handler_perform_operation(key_op_handler, operation)\n\nCalls the on_key_operation vtable function. See aws_custom_key_op_handler_vtable for function details.\n\nPrototype\n\nvoid aws_custom_key_op_handler_perform_operation( struct aws_custom_key_op_handler *key_op_handler, struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_custom_key_op_handler_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_custom_key_op_handler_release","text":"aws_custom_key_op_handler_release(key_op_handler)\n\nDecreases the reference count for the passed-in aws_custom_key_op_handler and returns NULL.\n\nPrototype\n\nstruct aws_custom_key_op_handler *aws_custom_key_op_handler_release( struct aws_custom_key_op_handler *key_op_handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_as_epoch_secs-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_date_time_as_epoch_secs","text":"aws_date_time_as_epoch_secs(dt)\n\nPrototype\n\ndouble aws_date_time_as_epoch_secs(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_as_millis-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_date_time_as_millis","text":"aws_date_time_as_millis(dt)\n\nPrototype\n\nuint64_t aws_date_time_as_millis(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_as_nanos-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_date_time_as_nanos","text":"aws_date_time_as_nanos(dt)\n\nPrototype\n\nuint64_t aws_date_time_as_nanos(const struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_day_of_week-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_day_of_week","text":"aws_date_time_day_of_week(dt, local_time)\n\nPrototype\n\nenum aws_date_day_of_week aws_date_time_day_of_week(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_diff-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_diff","text":"aws_date_time_diff(a, b)\n\nreturns the difference of a and b (a - b) in seconds.\n\nPrototype\n\ntime_t aws_date_time_diff(const struct aws_date_time *a, const struct aws_date_time *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_dst-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_dst","text":"aws_date_time_dst(dt, local_time)\n\nPrototype\n\nbool aws_date_time_dst(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_hour-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_hour","text":"aws_date_time_hour(dt, local_time)\n\nPrototype\n\nuint8_t aws_date_time_hour(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_init_epoch_millis-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_init_epoch_millis","text":"aws_date_time_init_epoch_millis(dt, ms_since_epoch)\n\nInitializes dt to be the time represented in milliseconds since unix epoch.\n\nPrototype\n\nvoid aws_date_time_init_epoch_millis(struct aws_date_time *dt, uint64_t ms_since_epoch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_init_epoch_secs-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_init_epoch_secs","text":"aws_date_time_init_epoch_secs(dt, sec_ms)\n\nInitializes dt to be the time represented in seconds.millis since unix epoch.\n\nPrototype\n\nvoid aws_date_time_init_epoch_secs(struct aws_date_time *dt, double sec_ms);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_init_from_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_init_from_str","text":"aws_date_time_init_from_str(dt, date_str, fmt)\n\nInitializes dt to be the time represented by date_str in format 'fmt'. Returns AWS_OP_SUCCESS if the string was successfully parsed, returns AWS_OP_ERR if parsing failed.\n\nNotes for AWS_DATE_FORMAT_RFC822: If no time zone information is provided, it is assumed to be local time (please don't do this).\n\nIf the time zone is something other than something indicating Universal Time (e.g. Z, UT, UTC, or GMT) or an offset from UTC (e.g. +0100, -0700), parsing will fail.\n\nReally, it's just better if you always use Universal Time.\n\nPrototype\n\nint aws_date_time_init_from_str( struct aws_date_time *dt, const struct aws_byte_buf *date_str, enum aws_date_format fmt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_init_from_str_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_init_from_str_cursor","text":"aws_date_time_init_from_str_cursor(dt, date_str_cursor, fmt)\n\naws_date_time_init variant that takes a byte_cursor rather than a byte_buf\n\nPrototype\n\nint aws_date_time_init_from_str_cursor( struct aws_date_time *dt, const struct aws_byte_cursor *date_str_cursor, enum aws_date_format fmt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_init_now-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_date_time_init_now","text":"aws_date_time_init_now(dt)\n\nInitializes dt to be the current system time.\n\nPrototype\n\nvoid aws_date_time_init_now(struct aws_date_time *dt);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_minute-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_minute","text":"aws_date_time_minute(dt, local_time)\n\nPrototype\n\nuint8_t aws_date_time_minute(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_month-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_month","text":"aws_date_time_month(dt, local_time)\n\nPrototype\n\nenum aws_date_month aws_date_time_month(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_month_day-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_month_day","text":"aws_date_time_month_day(dt, local_time)\n\nPrototype\n\nuint8_t aws_date_time_month_day(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_second-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_second","text":"aws_date_time_second(dt, local_time)\n\nPrototype\n\nuint8_t aws_date_time_second(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_to_local_time_short_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_to_local_time_short_str","text":"aws_date_time_to_local_time_short_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted short date string in local time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_local_time_short_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_to_local_time_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_to_local_time_str","text":"aws_date_time_to_local_time_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted date string in local time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_local_time_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_to_utc_time_short_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_to_utc_time_short_str","text":"aws_date_time_to_utc_time_short_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted short date string in utc time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_utc_time_short_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_to_utc_time_str-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_to_utc_time_str","text":"aws_date_time_to_utc_time_str(dt, fmt, output_buf)\n\nCopies the current time as a formatted date string in utc time into output_buf. If buffer is too small, it will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not allowed.\n\nPrototype\n\nint aws_date_time_to_utc_time_str( const struct aws_date_time *dt, enum aws_date_format fmt, struct aws_byte_buf *output_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_date_time_year-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_date_time_year","text":"aws_date_time_year(dt, local_time)\n\nPrototype\n\nuint16_t aws_date_time_year(const struct aws_date_time *dt, bool local_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_debug_break-Tuple{}","page":"Home","title":"LibAWSCRT.aws_debug_break","text":"aws_debug_break()\n\nPrototype\n\nvoid aws_debug_break(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_decode_utf8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_decode_utf8","text":"aws_decode_utf8(bytes, options)\n\nDecode a complete string of UTF8/ASCII text. Text is always validated according to RFC-3629 (you may perform additional validation in the on_codepoint callback). The text does not need to begin with a UTF8 BOM. If you need to decode text incrementally as you receive it, use aws_utf8_decoder_new() instead.\n\nParameters\n\nbytes: Text to decode.\noptions: Options for decoding. If NULL is passed, the text is simply validated.\n\nReturns\n\nAWS_OP_SUCCESS if successful. An error is raised if the text is not valid, or the on_codepoint callback raises an error.\n\nPrototype\n\nint aws_decode_utf8(struct aws_byte_cursor bytes, const struct aws_utf8_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_default_allocator-Tuple{}","page":"Home","title":"LibAWSCRT.aws_default_allocator","text":"aws_default_allocator()\n\nPrototype\n\nstruct aws_allocator *aws_default_allocator(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_default_dns_resolve-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_default_dns_resolve","text":"aws_default_dns_resolve(allocator, host_name, output_addresses, user_data)\n\nWARNING! do not call this function directly (getaddrinfo()): it blocks. Provide a pointer to this function for other resolution functions.\n\nPrototype\n\nint aws_default_dns_resolve( struct aws_allocator *allocator, const struct aws_string *host_name, struct aws_array_list *output_addresses, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_default_thread_options-Tuple{}","page":"Home","title":"LibAWSCRT.aws_default_thread_options","text":"aws_default_thread_options()\n\nReturns an instance of system default thread options.\n\nPrototype\n\nconst struct aws_thread_options *aws_default_thread_options(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_buffer-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_device_random_buffer","text":"aws_device_random_buffer(output)\n\nFill the rest of a buffer with unpredictably random bytes, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_buffer(struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_buffer_append-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_device_random_buffer_append","text":"aws_device_random_buffer_append(output, n)\n\nWrite N unpredictably random bytes to a buffer, suitable for cryptographic use. If there is insufficient space in the buffer, AWS_ERROR_SHORT_BUFFER is raised and the buffer will be unchanged.\n\nPrototype\n\nint aws_device_random_buffer_append(struct aws_byte_buf *output, size_t n);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_u16-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_device_random_u16","text":"aws_device_random_u16(output)\n\nGet an unpredictably random 16bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u16(uint16_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_u32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_device_random_u32","text":"aws_device_random_u32(output)\n\nGet an unpredictably random 32bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u32(uint32_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_u64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_device_random_u64","text":"aws_device_random_u64(output)\n\nGet an unpredictably random 64bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u64(uint64_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_device_random_u8-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_device_random_u8","text":"aws_device_random_u8(output)\n\nGet an unpredictably random 8bit number, suitable for cryptographic use.\n\nPrototype\n\nint aws_device_random_u8(uint8_t *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_create-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_create","text":"aws_directory_create(dir_path)\n\nCreates a directory if it doesn't currently exist. If the directory already exists, it's ignored and assumed successful.\n\nReturns AWS_OP_SUCCESS on success. Otherwise, check aws_last_error().\n\nPrototype\n\nint aws_directory_create(const struct aws_string *dir_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_delete-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_directory_delete","text":"aws_directory_delete(dir_path, recursive)\n\nDeletes a directory. If the directory is not empty, this will fail unless the recursive parameter is set to true. If recursive is true then the entire directory and all of its contents will be deleted. If it is set to false, the directory will be deleted only if it is empty. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred. If the directory doesn't exist, AWS_OP_SUCCESS is still returned.\n\nPrototype\n\nint aws_directory_delete(const struct aws_string *dir_path, bool recursive);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_entry_iterator_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_entry_iterator_destroy","text":"aws_directory_entry_iterator_destroy(iterator)\n\nCleanup and deallocate iterator\n\nPrototype\n\nvoid aws_directory_entry_iterator_destroy(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_entry_iterator_get_value-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_entry_iterator_get_value","text":"aws_directory_entry_iterator_get_value(iterator)\n\nGets the aws_directory_entry value for iterator at the current position. Returns NULL if the iterator contains no entries.\n\nPrototype\n\nconst struct aws_directory_entry *aws_directory_entry_iterator_get_value( const struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_entry_iterator_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_directory_entry_iterator_new","text":"aws_directory_entry_iterator_new(allocator, path)\n\nCreates a read-only iterator of a directory starting at path. If path is invalid or there's any other error condition, NULL will be returned. Call aws_last_error() for the exact error in that case.\n\nPrototype\n\nstruct aws_directory_iterator *aws_directory_entry_iterator_new( struct aws_allocator *allocator, const struct aws_string *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_entry_iterator_next-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_entry_iterator_next","text":"aws_directory_entry_iterator_next(iterator)\n\nMoves the iterator to the next entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available.\n\nPrototype\n\nint aws_directory_entry_iterator_next(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_entry_iterator_previous-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_entry_iterator_previous","text":"aws_directory_entry_iterator_previous(iterator)\n\nMoves the iterator to the previous entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available.\n\nPrototype\n\nint aws_directory_entry_iterator_previous(struct aws_directory_iterator *iterator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_exists-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_directory_exists","text":"aws_directory_exists(dir_path)\n\nReturns true if the directory currently exists. Otherwise, it returns false.\n\nPrototype\n\nbool aws_directory_exists(const struct aws_string *dir_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_or_file_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_directory_or_file_move","text":"aws_directory_or_file_move(from, to)\n\nMoves directory at from to to. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred.\n\nPrototype\n\nint aws_directory_or_file_move(const struct aws_string *from, const struct aws_string *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_directory_traverse-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_directory_traverse","text":"aws_directory_traverse(allocator, path, recursive, on_entry, user_data)\n\nTraverse a directory starting at path.\n\nIf you want the traversal to recurse the entire directory, pass recursive as true. Passing false for this parameter will only iterate the contents of the directory, but will not descend into any directories it encounters.\n\nIf recursive is set to true, the traversal is performed post-order, depth-first (for practical reasons such as deleting a directory that contains subdirectories or files).\n\nreturns AWS_OP_SUCCESS(0) on success.\n\nPrototype\n\nint aws_directory_traverse( struct aws_allocator *allocator, const struct aws_string *path, bool recursive, aws_on_directory_entry *on_entry, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_curve_name_from_oid-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_curve_name_from_oid","text":"aws_ecc_curve_name_from_oid(oid, curve_name)\n\nGet the curve name from the oid. OID here is the payload of the DER encoded ASN.1 part (doesn't include type specifier or length. On success, the value of curve_name will be set.\n\nPrototype\n\nint aws_ecc_curve_name_from_oid(struct aws_byte_cursor *oid, enum aws_ecc_curve_name *curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_coordinate_byte_size_from_curve_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_coordinate_byte_size_from_curve_name","text":"aws_ecc_key_coordinate_byte_size_from_curve_name(curve_name)\n\nPrototype\n\nsize_t aws_ecc_key_coordinate_byte_size_from_curve_name(enum aws_ecc_curve_name curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_new_from_hex_coordinates-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_new_from_hex_coordinates","text":"aws_ecc_key_new_from_hex_coordinates(allocator, curve_name, pub_x_hex_cursor, pub_y_hex_cursor)\n\nCreates an Elliptic curve public key from x and y coordinates encoded as hex strings Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_new_from_hex_coordinates( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, struct aws_byte_cursor pub_x_hex_cursor, struct aws_byte_cursor pub_y_hex_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_acquire","text":"aws_ecc_key_pair_acquire(key_pair)\n\nAdds one to an ecc key pair's ref count.\n\nPrototype\n\nvoid aws_ecc_key_pair_acquire(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_derive_public_key-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_derive_public_key","text":"aws_ecc_key_pair_derive_public_key(key_pair)\n\nDerives a public key from the private key if supported by this operating system (not supported on OSX). key_pair::pub_x and key_pair::pub_y will be set with the raw key buffers.\n\nPrototype\n\nint aws_ecc_key_pair_derive_public_key(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_get_private_key-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_get_private_key","text":"aws_ecc_key_pair_get_private_key(key_pair, private_d)\n\nPrototype\n\nvoid aws_ecc_key_pair_get_private_key( const struct aws_ecc_key_pair *key_pair, struct aws_byte_cursor *private_d);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_get_public_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_get_public_key","text":"aws_ecc_key_pair_get_public_key(key_pair, pub_x, pub_y)\n\nPrototype\n\nvoid aws_ecc_key_pair_get_public_key( const struct aws_ecc_key_pair *key_pair, struct aws_byte_cursor *pub_x, struct aws_byte_cursor *pub_y);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_new_ecdsa_p256_key_from_aws_credentials-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_new_ecdsa_p256_key_from_aws_credentials","text":"aws_ecc_key_pair_new_ecdsa_p256_key_from_aws_credentials(allocator, credentials)\n\nDerives an ecc key pair (based on the nist P256 curve) from the access key id and secret access key components of a set of AWS credentials using an internal key derivation specification. Used to perform sigv4a signing in the hybrid mode based on AWS credentials.\n\nParameters\n\nallocator: memory allocator to use for all memory allocation\ncredentials: AWS credentials to derive the ECC key from using the AWS sigv4a key deriviation specification\n\nReturns\n\na new ecc key pair or NULL on failure\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_ecdsa_p256_key_from_aws_credentials( struct aws_allocator *allocator, const struct aws_credentials *credentials);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_new_from_asn1-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_new_from_asn1","text":"aws_ecc_key_pair_new_from_asn1(allocator, encoded_keys)\n\nCreates an Elliptic Curve public/private key pair from a DER encoded key pair. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Whether or not signing or verification can be perform depends on if encoded_keys is a public/private pair or a public key.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_asn1( struct aws_allocator *allocator, const struct aws_byte_cursor *encoded_keys);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_new_from_private_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_new_from_private_key","text":"aws_ecc_key_pair_new_from_private_key(allocator, curve_name, priv_key)\n\nCreates an Elliptic Curve private key that can be used for signing. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Note: priv_key::len must match the appropriate length for the selected curve_name.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_private_key( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, const struct aws_byte_cursor *priv_key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_new_from_public_key-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_new_from_public_key","text":"aws_ecc_key_pair_new_from_public_key(allocator, curve_name, public_key_x, public_key_y)\n\nCreates an Elliptic Curve public key that can be used for verifying. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL. Note: public_key_x::len and public_key_y::len must match the appropriate length for the selected curve_name.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_from_public_key( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name, const struct aws_byte_cursor *public_key_x, const struct aws_byte_cursor *public_key_y);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_new_generate_random-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_new_generate_random","text":"aws_ecc_key_pair_new_generate_random(allocator, curve_name)\n\nCreates an Elliptic Curve public/private key pair that can be used for signing and verifying. Returns a new instance of aws_ecc_key_pair if the key was successfully built. Otherwise returns NULL.\n\nPrototype\n\nstruct aws_ecc_key_pair *aws_ecc_key_pair_new_generate_random( struct aws_allocator *allocator, enum aws_ecc_curve_name curve_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_release","text":"aws_ecc_key_pair_release(key_pair)\n\nSubtracts one from an ecc key pair's ref count. If ref count reaches zero, the key pair is destroyed.\n\nPrototype\n\nvoid aws_ecc_key_pair_release(struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_sign_message-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_sign_message","text":"aws_ecc_key_pair_sign_message(key_pair, message, signature)\n\nUses the key_pair's private key to sign message. The output will be in signature. Signature must be large enough to hold the signature. Check aws_ecc_key_pair_signature_length() for the appropriate size. Signature will be DER encoded.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nPrototype\n\nint aws_ecc_key_pair_sign_message( const struct aws_ecc_key_pair *key_pair, const struct aws_byte_cursor *message, struct aws_byte_buf *signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_signature_length-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_signature_length","text":"aws_ecc_key_pair_signature_length(key_pair)\n\nPrototype\n\nsize_t aws_ecc_key_pair_signature_length(const struct aws_ecc_key_pair *key_pair);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_key_pair_verify_signature-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_key_pair_verify_signature","text":"aws_ecc_key_pair_verify_signature(key_pair, message, signature)\n\nUses the key_pair's public key to verify signature of message. Signature should be DER encoded.\n\nIt is the callers job to make sure message is the appropriate cryptographic digest for this operation. It's usually something like a SHA256.\n\nreturns AWS_OP_SUCCESS if the signature is valid.\n\nPrototype\n\nint aws_ecc_key_pair_verify_signature( const struct aws_ecc_key_pair *key_pair, const struct aws_byte_cursor *message, const struct aws_byte_cursor *signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ecc_oid_from_curve_name-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ecc_oid_from_curve_name","text":"aws_ecc_oid_from_curve_name(curve_name, oid)\n\nGet the DER encoded OID from the curve_name. The OID in this case will not contain the type or the length specifier.\n\nPrototype\n\nint aws_ecc_oid_from_curve_name(enum aws_ecc_curve_name curve_name, struct aws_byte_cursor *oid);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_get_supported_ruleset_version-Tuple{}","page":"Home","title":"LibAWSCRT.aws_endpoints_get_supported_ruleset_version","text":"aws_endpoints_get_supported_ruleset_version()\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_get_supported_ruleset_version(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_built_in-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_built_in","text":"aws_endpoints_parameter_get_built_in(parameter)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_parameter_get_built_in( const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_default_boolean-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_default_boolean","text":"aws_endpoints_parameter_get_default_boolean(parameter, out_bool)\n\nPrototype\n\nint aws_endpoints_parameter_get_default_boolean( const struct aws_endpoints_parameter *parameter, const bool **out_bool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_default_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_default_string","text":"aws_endpoints_parameter_get_default_string(parameter, out_cursor)\n\nPrototype\n\nint aws_endpoints_parameter_get_default_string( const struct aws_endpoints_parameter *parameter, struct aws_byte_cursor *out_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_deprecated_message-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_deprecated_message","text":"aws_endpoints_parameter_get_deprecated_message(parameter)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_parameter_get_deprecated_message( const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_deprecated_since-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_deprecated_since","text":"aws_endpoints_parameter_get_deprecated_since(parameter)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_parameter_get_deprecated_since( const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_documentation-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_documentation","text":"aws_endpoints_parameter_get_documentation(parameter)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_parameter_get_documentation( const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_is_required-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_is_required","text":"aws_endpoints_parameter_get_is_required(parameter)\n\nPrototype\n\nbool aws_endpoints_parameter_get_is_required(const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameter_get_type-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameter_get_type","text":"aws_endpoints_parameter_get_type(parameter)\n\nPrototype\n\nenum aws_endpoints_parameter_type aws_endpoints_parameter_get_type( const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_parameters_get_is_deprecated-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_parameters_get_is_deprecated","text":"aws_endpoints_parameters_get_is_deprecated(parameter)\n\nPrototype\n\nbool aws_endpoints_parameters_get_is_deprecated(const struct aws_endpoints_parameter *parameter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_request_context_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_request_context_acquire","text":"aws_endpoints_request_context_acquire(request_context)\n\nPrototype\n\nstruct aws_endpoints_request_context *aws_endpoints_request_context_acquire( struct aws_endpoints_request_context *request_context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_request_context_add_boolean-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_request_context_add_boolean","text":"aws_endpoints_request_context_add_boolean(allocator, context, name, value)\n\nPrototype\n\nint aws_endpoints_request_context_add_boolean( struct aws_allocator *allocator, struct aws_endpoints_request_context *context, struct aws_byte_cursor name, bool value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_request_context_add_string-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_request_context_add_string","text":"aws_endpoints_request_context_add_string(allocator, context, name, value)\n\nPrototype\n\nint aws_endpoints_request_context_add_string( struct aws_allocator *allocator, struct aws_endpoints_request_context *context, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_request_context_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_request_context_new","text":"aws_endpoints_request_context_new(allocator)\n\nPrototype\n\nstruct aws_endpoints_request_context *aws_endpoints_request_context_new( struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_request_context_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_request_context_release","text":"aws_endpoints_request_context_release(request_context)\n\nPrototype\n\nstruct aws_endpoints_request_context *aws_endpoints_request_context_release( struct aws_endpoints_request_context *request_context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_acquire","text":"aws_endpoints_resolved_endpoint_acquire(resolved_endpoint)\n\nPrototype\n\nstruct aws_endpoints_resolved_endpoint *aws_endpoints_resolved_endpoint_acquire( struct aws_endpoints_resolved_endpoint *resolved_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_get_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_get_error","text":"aws_endpoints_resolved_endpoint_get_error(resolved_endpoint, out_error)\n\nPrototype\n\nint aws_endpoints_resolved_endpoint_get_error( const struct aws_endpoints_resolved_endpoint *resolved_endpoint, struct aws_byte_cursor *out_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_get_headers-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_get_headers","text":"aws_endpoints_resolved_endpoint_get_headers(resolved_endpoint, out_headers)\n\nPrototype\n\nint aws_endpoints_resolved_endpoint_get_headers( const struct aws_endpoints_resolved_endpoint *resolved_endpoint, const struct aws_hash_table **out_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_get_properties-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_get_properties","text":"aws_endpoints_resolved_endpoint_get_properties(resolved_endpoint, out_properties)\n\nPrototype\n\nint aws_endpoints_resolved_endpoint_get_properties( const struct aws_endpoints_resolved_endpoint *resolved_endpoint, struct aws_byte_cursor *out_properties);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_get_type-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_get_type","text":"aws_endpoints_resolved_endpoint_get_type(resolved_endpoint)\n\nPrototype\n\nenum aws_endpoints_resolved_endpoint_type aws_endpoints_resolved_endpoint_get_type( const struct aws_endpoints_resolved_endpoint *resolved_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_get_url-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_get_url","text":"aws_endpoints_resolved_endpoint_get_url(resolved_endpoint, out_url)\n\nPrototype\n\nint aws_endpoints_resolved_endpoint_get_url( const struct aws_endpoints_resolved_endpoint *resolved_endpoint, struct aws_byte_cursor *out_url);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_resolved_endpoint_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_resolved_endpoint_release","text":"aws_endpoints_resolved_endpoint_release(resolved_endpoint)\n\nPrototype\n\nstruct aws_endpoints_resolved_endpoint *aws_endpoints_resolved_endpoint_release( struct aws_endpoints_resolved_endpoint *resolved_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_rule_engine_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_rule_engine_acquire","text":"aws_endpoints_rule_engine_acquire(rule_engine)\n\nPrototype\n\nstruct aws_endpoints_rule_engine *aws_endpoints_rule_engine_acquire( struct aws_endpoints_rule_engine *rule_engine);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_rule_engine_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_rule_engine_new","text":"aws_endpoints_rule_engine_new(allocator, ruleset, partitions_config)\n\nCreate new rule engine for a given ruleset. In cases of failure NULL is returned and last error is set.\n\nPrototype\n\nstruct aws_endpoints_rule_engine *aws_endpoints_rule_engine_new( struct aws_allocator *allocator, struct aws_endpoints_ruleset *ruleset, struct aws_partitions_config *partitions_config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_rule_engine_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_rule_engine_release","text":"aws_endpoints_rule_engine_release(rule_engine)\n\nPrototype\n\nstruct aws_endpoints_rule_engine *aws_endpoints_rule_engine_release( struct aws_endpoints_rule_engine *rule_engine);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_rule_engine_resolve-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_rule_engine_resolve","text":"aws_endpoints_rule_engine_resolve(engine, context, out_resolved_endpoint)\n\nPrototype\n\nint aws_endpoints_rule_engine_resolve( struct aws_endpoints_rule_engine *engine, const struct aws_endpoints_request_context *context, struct aws_endpoints_resolved_endpoint **out_resolved_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_acquire","text":"aws_endpoints_ruleset_acquire(ruleset)\n\nPrototype\n\nstruct aws_endpoints_ruleset *aws_endpoints_ruleset_acquire(struct aws_endpoints_ruleset *ruleset);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_get_parameters-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_get_parameters","text":"aws_endpoints_ruleset_get_parameters(ruleset)\n\nPrototype\n\nconst struct aws_hash_table *aws_endpoints_ruleset_get_parameters( struct aws_endpoints_ruleset *ruleset);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_get_service_id-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_get_service_id","text":"aws_endpoints_ruleset_get_service_id(ruleset)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_ruleset_get_service_id( const struct aws_endpoints_ruleset *ruleset);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_get_version-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_get_version","text":"aws_endpoints_ruleset_get_version(ruleset)\n\nPrototype\n\nstruct aws_byte_cursor aws_endpoints_ruleset_get_version(const struct aws_endpoints_ruleset *ruleset);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_new_from_string","text":"aws_endpoints_ruleset_new_from_string(allocator, ruleset_json)\n\nPrototype\n\nstruct aws_endpoints_ruleset *aws_endpoints_ruleset_new_from_string( struct aws_allocator *allocator, struct aws_byte_cursor ruleset_json);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_endpoints_ruleset_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_endpoints_ruleset_release","text":"aws_endpoints_ruleset_release(ruleset)\n\nPrototype\n\nstruct aws_endpoints_ruleset *aws_endpoints_ruleset_release(struct aws_endpoints_ruleset *ruleset);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_error_debug_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_error_debug_str","text":"aws_error_debug_str(err)\n\nPrototype\n\nconst char *aws_error_debug_str(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_error_lib_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_error_lib_name","text":"aws_error_lib_name(err)\n\nPrototype\n\nconst char *aws_error_lib_name(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_error_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_error_name","text":"aws_error_name(err)\n\nPrototype\n\nconst char *aws_error_name(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_error_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_error_str","text":"aws_error_str(err)\n\nPrototype\n\nconst char *aws_error_str(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_cancel_task","text":"aws_event_loop_cancel_task(event_loop, task)\n\nCancels task. This function must be called from the event loop's thread, and is only guaranteed to work properly on tasks scheduled from within the event loop's thread. The task will be executed with the AWS_TASK_STATUS_CANCELED status inside this call.\n\nPrototype\n\nvoid aws_event_loop_cancel_task(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_clean_up_base-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_clean_up_base","text":"aws_event_loop_clean_up_base(event_loop)\n\nCommon cleanup code for all implementations. This is only called from the *destroy() function of event loop implementations.\n\nPrototype\n\nvoid aws_event_loop_clean_up_base(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_current_clock_time-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_current_clock_time","text":"aws_event_loop_current_clock_time(event_loop, time_nanos)\n\nGets the current timestamp for the event loop's clock, in nanoseconds. This function is thread-safe.\n\nPrototype\n\nint aws_event_loop_current_clock_time(struct aws_event_loop *event_loop, uint64_t *time_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_destroy","text":"aws_event_loop_destroy(event_loop)\n\nInvokes the destroy() fn for the event loop implementation. If the event loop is still in a running state, this function will block waiting on the event loop to shutdown. If you do not want this function to block, call aws_event_loop_stop() manually first. If the event loop is shared by multiple threads then destroy must be called by exactly one thread. All other threads must ensure their API calls to the event loop happen-before the call to destroy.\n\nPrototype\n\nvoid aws_event_loop_destroy(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_fetch_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_fetch_local_object","text":"aws_event_loop_fetch_local_object(event_loop, key, obj)\n\nFetches an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_fetch_local_object( struct aws_event_loop *event_loop, void *key, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_free_io_event_resources-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_free_io_event_resources","text":"aws_event_loop_free_io_event_resources(event_loop, handle)\n\nCleans up resources (user_data) associated with the I/O eventing subsystem for a given handle. This should only ever be necessary in the case where you are cleaning up an event loop during shutdown and its thread has already been joined.\n\nPrototype\n\nvoid aws_event_loop_free_io_event_resources(struct aws_event_loop *event_loop, struct aws_io_handle *handle);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_get_load_factor-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_get_load_factor","text":"aws_event_loop_get_load_factor(event_loop)\n\nReturns the current load factor (however that may be calculated). If the event-loop is not invoking aws_event_loop_register_tick_start() and aws_event_loop_register_tick_end(), this value will always be 0.\n\nPrototype\n\nsize_t aws_event_loop_get_load_factor(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_acquire","text":"aws_event_loop_group_acquire(el_group)\n\nIncrements the reference count on the event loop group, allowing the caller to take a reference to it.\n\nReturns the same event loop group passed in.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_acquire(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_get_loop_at-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_get_loop_at","text":"aws_event_loop_group_get_loop_at(el_group, index)\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_group_get_loop_at(struct aws_event_loop_group *el_group, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_get_loop_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_get_loop_count","text":"aws_event_loop_group_get_loop_count(el_group)\n\nPrototype\n\nsize_t aws_event_loop_group_get_loop_count(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_get_next_loop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_get_next_loop","text":"aws_event_loop_group_get_next_loop(el_group)\n\nFetches the next loop for use. The purpose is to enable load balancing across loops. You should not depend on how this load balancing is done as it is subject to change in the future. Currently it uses the \"best-of-two\" algorithm based on the load factor of each loop.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_group_get_next_loop(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_new-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_new","text":"aws_event_loop_group_new(alloc, clock, el_count, new_loop_fn, new_loop_user_data, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, and the function to call for creating a new event loop.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new( struct aws_allocator *alloc, aws_io_clock_fn *clock, uint16_t el_count, aws_new_event_loop_fn *new_loop_fn, void *new_loop_user_data, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_new_default-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_new_default","text":"aws_event_loop_group_new_default(alloc, max_threads, shutdown_options)\n\nInitializes an event loop group with platform defaults. If max_threads == 0, then the loop count will be the number of available processors on the machine / 2 (to exclude hyper-threads). Otherwise, max_threads will be the number of event loops in the group.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_default( struct aws_allocator *alloc, uint16_t max_threads, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_new_default_pinned_to_cpu_group-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_new_default_pinned_to_cpu_group","text":"aws_event_loop_group_new_default_pinned_to_cpu_group(alloc, max_threads, cpu_group, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, the function to call for creating a new event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note: If el_count exceeds the number of hw threads in the cpu_group it will be clamped to the number of hw threads on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node.\n\nIf max_threads == 0, then the loop count will be the number of available processors in the cpu_group / 2 (to exclude hyper-threads)\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_default_pinned_to_cpu_group( struct aws_allocator *alloc, uint16_t max_threads, uint16_t cpu_group, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_new_pinned_to_cpu_group-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_new_pinned_to_cpu_group","text":"aws_event_loop_group_new_pinned_to_cpu_group(alloc, clock, el_count, cpu_group, new_loop_fn, new_loop_user_data, shutdown_options)\n\nCreates an event loop group, with clock, number of loops to manage, the function to call for creating a new event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note: If el_count exceeds the number of hw threads in the cpu_group it will be ignored on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node.\n\nPrototype\n\nstruct aws_event_loop_group *aws_event_loop_group_new_pinned_to_cpu_group( struct aws_allocator *alloc, aws_io_clock_fn *clock, uint16_t el_count, uint16_t cpu_group, aws_new_event_loop_fn *new_loop_fn, void *new_loop_user_data, const struct aws_shutdown_callback_options *shutdown_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_group_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_group_release","text":"aws_event_loop_group_release(el_group)\n\nDecrements an event loop group's ref count. When the ref count drops to zero, the event loop group will be destroyed.\n\nPrototype\n\nvoid aws_event_loop_group_release(struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_init_base-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_init_base","text":"aws_event_loop_init_base(event_loop, alloc, clock)\n\nInitializes common event-loop data structures. This is only called from the *new() function of event loop implementations.\n\nPrototype\n\nint aws_event_loop_init_base(struct aws_event_loop *event_loop, struct aws_allocator *alloc, aws_io_clock_fn *clock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_new_default-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_new_default","text":"aws_event_loop_new_default(alloc, clock)\n\nCreates an instance of the default event loop implementation for the current architecture and operating system.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_new_default(struct aws_allocator *alloc, aws_io_clock_fn *clock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_new_default_with_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_new_default_with_options","text":"aws_event_loop_new_default_with_options(alloc, options)\n\nCreates an instance of the default event loop implementation for the current architecture and operating system using extendable options.\n\nPrototype\n\nstruct aws_event_loop *aws_event_loop_new_default_with_options( struct aws_allocator *alloc, const struct aws_event_loop_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_put_local_object-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_put_local_object","text":"aws_event_loop_put_local_object(event_loop, obj)\n\nPuts an item object the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. The lifetime of item must live until remove or a put item overrides it. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_put_local_object(struct aws_event_loop *event_loop, struct aws_event_loop_local_object *obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_register_tick_end-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_register_tick_end","text":"aws_event_loop_register_tick_end(event_loop)\n\nFor event-loop implementations to use for providing metrics info to the base event-loop. This enables the event-loop load balancer to take into account load when vending another event-loop to a caller.\n\nCall this function at the end of your event-loop tick: after processing IO and tasks.\n\nPrototype\n\nvoid aws_event_loop_register_tick_end(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_register_tick_start-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_register_tick_start","text":"aws_event_loop_register_tick_start(event_loop)\n\nFor event-loop implementations to use for providing metrics info to the base event-loop. This enables the event-loop load balancer to take into account load when vending another event-loop to a caller.\n\nCall this function at the beginning of your event-loop tick: after wake-up, but before processing any IO or tasks.\n\nPrototype\n\nvoid aws_event_loop_register_tick_start(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_remove_local_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_remove_local_object","text":"aws_event_loop_remove_local_object(event_loop, key, removed_obj)\n\nRemoves an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to by key. If removed_item is not null, the removed item will be moved to it if it exists. Otherwise, the default deallocation strategy will be used. This function is not thread safe and should be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_remove_local_object( struct aws_event_loop *event_loop, void *key, struct aws_event_loop_local_object *removed_obj);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_run-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_run","text":"aws_event_loop_run(event_loop)\n\nTriggers the running of the event loop. This function must not block. The event loop is not active until this function is invoked. This function can be called again on an event loop after calling aws_event_loop_stop() and aws_event_loop_wait_for_stop_completion().\n\nPrototype\n\nint aws_event_loop_run(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_schedule_task_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_schedule_task_future","text":"aws_event_loop_schedule_task_future(event_loop, task, run_at_nanos)\n\nThe event loop will schedule the task and run it at the specified time. Use aws_event_loop_current_clock_time() to query the current time in nanoseconds. Note that cancelled tasks may execute outside the event loop thread. This function may be called from outside or inside the event loop thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_event_loop_schedule_task_future( struct aws_event_loop *event_loop, struct aws_task *task, uint64_t run_at_nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_schedule_task_now-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_schedule_task_now","text":"aws_event_loop_schedule_task_now(event_loop, task)\n\nThe event loop will schedule the task and run it on the event loop thread as soon as possible. Note that cancelled tasks may execute outside the event loop thread. This function may be called from outside or inside the event loop thread.\n\nThe task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_event_loop_schedule_task_now(struct aws_event_loop *event_loop, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_stop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_stop","text":"aws_event_loop_stop(event_loop)\n\nTriggers the event loop to stop, but does not wait for the loop to stop completely. This function may be called from outside or inside the event loop thread. It is safe to call multiple times. This function is called from destroy().\n\nIf you do not call destroy(), an event loop can be run again by calling stop(), wait_for_stop_completion(), run().\n\nPrototype\n\nint aws_event_loop_stop(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_subscribe_to_io_events-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_subscribe_to_io_events","text":"aws_event_loop_subscribe_to_io_events(event_loop, handle, events, on_event, user_data)\n\nSubscribes on_event to events on the event-loop for handle. events is a bitwise concatenation of the events that were received. The definition for these values can be found in aws_io_event_type. Currently, only AWS_IO_EVENT_TYPE_READABLE and AWS_IO_EVENT_TYPE_WRITABLE are honored. You always are registered for error conditions and closure. This function may be called from outside or inside the event loop thread. However, the unsubscribe function must be called inside the event-loop's thread.\n\nPrototype\n\nint aws_event_loop_subscribe_to_io_events( struct aws_event_loop *event_loop, struct aws_io_handle *handle, int events, aws_event_loop_on_event_fn *on_event, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_thread_is_callers_thread-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_thread_is_callers_thread","text":"aws_event_loop_thread_is_callers_thread(event_loop)\n\nReturns true if the event loop's thread is the same thread that called this function, otherwise false.\n\nPrototype\n\nbool aws_event_loop_thread_is_callers_thread(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_unsubscribe_from_io_events-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_unsubscribe_from_io_events","text":"aws_event_loop_unsubscribe_from_io_events(event_loop, handle)\n\nUnsubscribes handle from event-loop notifications. This function is not thread safe and should be called inside the event-loop's thread.\n\nNOTE: if you are using io completion ports, this is a risky call. We use it in places, but only when we're certain there's no pending events. If you want to use it, it's your job to make sure you don't have pending events before calling it.\n\nPrototype\n\nint aws_event_loop_unsubscribe_from_io_events(struct aws_event_loop *event_loop, struct aws_io_handle *handle);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_loop_wait_for_stop_completion-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_loop_wait_for_stop_completion","text":"aws_event_loop_wait_for_stop_completion(event_loop)\n\nBlocks until the event loop stops completely. If you want to call aws_event_loop_run() again, you must call this after aws_event_loop_stop(). It is not safe to call this function from inside the event loop thread.\n\nPrototype\n\nint aws_event_loop_wait_for_stop_completion(struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_bool_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_bool_header","text":"aws_event_stream_add_bool_header(headers, name, name_len, value)\n\nAdds a bool header to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_bool_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_bool_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_bool_header_by_cursor","text":"aws_event_stream_add_bool_header_by_cursor(headers, name, value)\n\nAdds a boolean-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_bool_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, bool value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_byte_buf_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_byte_buf_header_by_cursor","text":"aws_event_stream_add_byte_buf_header_by_cursor(headers, name, value)\n\nAdds a byte_buf-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_byte_buf_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_byte_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_byte_header","text":"aws_event_stream_add_byte_header(headers, name, name_len, value)\n\nAdds a byte header to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_byte_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_byte_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_byte_header_by_cursor","text":"aws_event_stream_add_byte_header_by_cursor(headers, name, value)\n\nAdds a byte-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_byte_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_bytebuf_header-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_bytebuf_header","text":"aws_event_stream_add_bytebuf_header(headers, name, name_len, value, value_len, copy)\n\nAdds a byte-buffer header to the list of headers. If copy is set to true, this will result in an allocation for the header value. Otherwise, the value will be set to the memory address of 'value'.\n\nPrototype\n\nint aws_event_stream_add_bytebuf_header( struct aws_array_list *headers, const char *name, uint8_t name_len, uint8_t *value, uint16_t value_len, int8_t copy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_header","text":"aws_event_stream_add_header(headers, header)\n\nAdds a generic header to the list of headers. Makes a copy of the underlaying data.\n\nPrototype\n\nint aws_event_stream_add_header( struct aws_array_list *headers, const struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int16_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int16_header","text":"aws_event_stream_add_int16_header(headers, name, name_len, value)\n\nadds a 16 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int16_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int16_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int16_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int16_header_by_cursor","text":"aws_event_stream_add_int16_header_by_cursor(headers, name, value)\n\nAdds a int16-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int16_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int16_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int32_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int32_header","text":"aws_event_stream_add_int32_header(headers, name, name_len, value)\n\nadds a 32 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int32_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int32_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int32_header_by_cursor","text":"aws_event_stream_add_int32_header_by_cursor(headers, name, value)\n\nAdds a int32-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int32_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int64_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int64_header","text":"aws_event_stream_add_int64_header(headers, name, name_len, value)\n\nadds a 64 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int64_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_int64_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_int64_header_by_cursor","text":"aws_event_stream_add_int64_header_by_cursor(headers, name, value)\n\nAdds a int64-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int64_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_string_header-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_string_header","text":"aws_event_stream_add_string_header(headers, name, name_len, value, value_len, copy)\n\nAdds a string header to the list of headers. If copy is set to true, this will result in an allocation for the header value. Otherwise, the value will be set to the memory address of 'value'.\n\nPrototype\n\nint aws_event_stream_add_string_header( struct aws_array_list *headers, const char *name, uint8_t name_len, const char *value, uint16_t value_len, int8_t copy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_string_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_string_header_by_cursor","text":"aws_event_stream_add_string_header_by_cursor(headers, name, value)\n\nAdds a string-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_string_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_timestamp_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_timestamp_header","text":"aws_event_stream_add_timestamp_header(headers, name, name_len, value)\n\nadds a 64 bit integer representing milliseconds since unix epoch to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_timestamp_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_timestamp_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_timestamp_header_by_cursor","text":"aws_event_stream_add_timestamp_header_by_cursor(headers, name, value)\n\nAdds a timestamp-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_timestamp_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_uuid_header-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_uuid_header","text":"aws_event_stream_add_uuid_header(headers, name, name_len, value)\n\nadds a uuid buffer to the list of headers. Value must always be 16 bytes long.\n\nPrototype\n\nint aws_event_stream_add_uuid_header( struct aws_array_list *headers, const char *name, uint8_t name_len, const uint8_t *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_add_uuid_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_add_uuid_header_by_cursor","text":"aws_event_stream_add_uuid_header_by_cursor(headers, name, value)\n\nAdds a uuid-valued header to a header list\n\nParameters\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_uuid_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_get_user_data-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_get_user_data","text":"aws_event_stream_channel_handler_get_user_data(handler)\n\nPrototype\n\nvoid *aws_event_stream_channel_handler_get_user_data(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_increment_read_window","text":"aws_event_stream_channel_handler_increment_read_window(handler, window_update_size)\n\nUpdates the read window for the channel if automatic_window_managemanet was set to false.\n\nPrototype\n\nvoid aws_event_stream_channel_handler_increment_read_window( struct aws_channel_handler *handler, size_t window_update_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_new","text":"aws_event_stream_channel_handler_new(allocator, handler_options)\n\nAllocates and initializes a new channel handler for processing aws_event_stream_message() events. Handler options must not be null.\n\nPrototype\n\nstruct aws_channel_handler *aws_event_stream_channel_handler_new( struct aws_allocator *allocator, const struct aws_event_stream_channel_handler_options *handler_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_channel_handler_write_message-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_channel_handler_write_message","text":"aws_event_stream_channel_handler_write_message(handler, message, on_message_written, user_data)\n\nWrites an aws_event_stream_message() to the channel. Once the channel flushes or an error occurs, on_message_written will be invoked. message should stay valid until the callback is invoked. If an error an occurs, the channel will automatically be shutdown.\n\nPrototype\n\nint aws_event_stream_channel_handler_write_message( struct aws_channel_handler *handler, struct aws_event_stream_message *message, aws_event_stream_channel_handler_on_message_written_fn *on_message_written, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_compute_headers_required_buffer_len-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_compute_headers_required_buffer_len","text":"aws_event_stream_compute_headers_required_buffer_len(headers)\n\nPrototype\n\nuint32_t aws_event_stream_compute_headers_required_buffer_len(const struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_create_int32_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_create_int32_header","text":"aws_event_stream_create_int32_header(name, value)\n\nPrototype\n\nstruct aws_event_stream_header_value_pair aws_event_stream_create_int32_header( struct aws_byte_cursor name, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_create_string_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_create_string_header","text":"aws_event_stream_create_string_header(name, value)\n\nPrototype\n\nstruct aws_event_stream_header_value_pair aws_event_stream_create_string_header( struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_name","text":"aws_event_stream_header_name(header)\n\nReturns the header name. Note: this value is not null terminated\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_name( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_bool-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_bool","text":"aws_event_stream_header_value_as_bool(header)\n\nReturns the header value as a boolean value.\n\nPrototype\n\nint8_t aws_event_stream_header_value_as_bool(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_byte-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_byte","text":"aws_event_stream_header_value_as_byte(header)\n\nReturns the header value as a byte\n\nPrototype\n\nint8_t aws_event_stream_header_value_as_byte(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_bytebuf-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_bytebuf","text":"aws_event_stream_header_value_as_bytebuf(header)\n\nReturns the header value as a pointer to a byte buffer, call aws_event_stream_header_value_length to determine the length of the buffer.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_bytebuf( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_int16-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_int16","text":"aws_event_stream_header_value_as_int16(header)\n\nReturns the header value as a 16 bit integer.\n\nPrototype\n\nint16_t aws_event_stream_header_value_as_int16(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_int32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_int32","text":"aws_event_stream_header_value_as_int32(header)\n\nReturns the header value as a 32 bit integer.\n\nPrototype\n\nint32_t aws_event_stream_header_value_as_int32(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_int64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_int64","text":"aws_event_stream_header_value_as_int64(header)\n\nReturns the header value as a 64 bit integer.\n\nPrototype\n\nint64_t aws_event_stream_header_value_as_int64(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_string","text":"aws_event_stream_header_value_as_string(header)\n\nReturns the header value as a string. Note: this value is not null terminated.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_string( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_timestamp-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_timestamp","text":"aws_event_stream_header_value_as_timestamp(header)\n\nReturns the header value as a 64 bit integer representing milliseconds since unix epoch.\n\nPrototype\n\nint64_t aws_event_stream_header_value_as_timestamp(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_as_uuid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_as_uuid","text":"aws_event_stream_header_value_as_uuid(header)\n\nReturns the header value a byte buffer which is 16 bytes long. Represents a UUID.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_uuid( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_header_value_length-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_header_value_length","text":"aws_event_stream_header_value_length(header)\n\nReturns the length of the header value buffer. This is mostly intended for string and byte buffer types.\n\nPrototype\n\nuint16_t aws_event_stream_header_value_length(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_headers_list_cleanup-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_headers_list_cleanup","text":"aws_event_stream_headers_list_cleanup(headers)\n\nCleans up the headers list. Also deallocates any headers that were the result of a copy flag for strings or buffer.\n\nPrototype\n\nvoid aws_event_stream_headers_list_cleanup(struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_headers_list_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_headers_list_init","text":"aws_event_stream_headers_list_init(headers, allocator)\n\ninitializes a headers list for you. It will default to a capacity of 4 in dynamic mode.\n\nPrototype\n\nint aws_event_stream_headers_list_init( struct aws_array_list *headers, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_event_stream_library_clean_up","text":"aws_event_stream_library_clean_up()\n\nClean up internal datastructures used by aws-c-event-stream. Must not be called until application is done using functionality in aws-c-event-stream.\n\nPrototype\n\nvoid aws_event_stream_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_library_init","text":"aws_event_stream_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-event-stream. Must be called before using any functionality in aws-c-event-stream.\n\nPrototype\n\nvoid aws_event_stream_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_buffer-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_buffer","text":"aws_event_stream_message_buffer(message)\n\nReturns the message as a buffer ready for transport.\n\nPrototype\n\nconst uint8_t *aws_event_stream_message_buffer(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_clean_up","text":"aws_event_stream_message_clean_up(message)\n\nCleans up any internally allocated memory. Always call this for API compatibility reasons, even if you only used the aws_aws_event_stream_message_from_buffer function.\n\nPrototype\n\nvoid aws_event_stream_message_clean_up(struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_from_buffer-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_from_buffer","text":"aws_event_stream_message_from_buffer(message, alloc, buffer)\n\nZero allocation, Zero copy. The message will simply wrap the buffer. The message functions are only useful as long as buffer is referencable memory.\n\nPrototype\n\nint aws_event_stream_message_from_buffer( struct aws_event_stream_message *message, struct aws_allocator *alloc, struct aws_byte_buf *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_from_buffer_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_from_buffer_copy","text":"aws_event_stream_message_from_buffer_copy(message, alloc, buffer)\n\nAllocates memory and copies buffer. Otherwise the same as aws_aws_event_stream_message_from_buffer. This is slower, but possibly safer.\n\nPrototype\n\nint aws_event_stream_message_from_buffer_copy( struct aws_event_stream_message *message, struct aws_allocator *alloc, const struct aws_byte_buf *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_headers-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_headers","text":"aws_event_stream_message_headers(message, headers)\n\nAdds the headers for the message to list. The memory in each header is owned as part of the message, do not free it or pass its address around.\n\nPrototype\n\nint aws_event_stream_message_headers( const struct aws_event_stream_message *message, struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_headers_len-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_headers_len","text":"aws_event_stream_message_headers_len(message)\n\nReturns the length of the headers portion of the message.\n\nPrototype\n\nuint32_t aws_event_stream_message_headers_len(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_init-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_init","text":"aws_event_stream_message_init(message, alloc, headers, payload)\n\nInitializes with a list of headers, the payload, and a payload length. CRCs will be computed for you. If headers or payload is NULL, then the fields will be appropriately set to indicate no headers and/or no payload. Both payload and headers will result in an allocation.\n\nPrototype\n\nint aws_event_stream_message_init( struct aws_event_stream_message *message, struct aws_allocator *alloc, const struct aws_array_list *headers, const struct aws_byte_buf *payload);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_message_crc-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_message_crc","text":"aws_event_stream_message_message_crc(message)\n\nReturns the checksum of the entire message (crc32)\n\nPrototype\n\nuint32_t aws_event_stream_message_message_crc(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_payload-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_payload","text":"aws_event_stream_message_payload(message)\n\nReturns a pointer to the beginning of the message payload.\n\nPrototype\n\nconst uint8_t *aws_event_stream_message_payload(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_payload_len-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_payload_len","text":"aws_event_stream_message_payload_len(message)\n\nReturns the length of the message payload.\n\nPrototype\n\nuint32_t aws_event_stream_message_payload_len(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_prelude_crc-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_prelude_crc","text":"aws_event_stream_message_prelude_crc(message)\n\nReturns the prelude crc (crc32)\n\nPrototype\n\nuint32_t aws_event_stream_message_prelude_crc(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_to_debug_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_to_debug_str","text":"aws_event_stream_message_to_debug_str(fd, message)\n\nWrites the message to fd in json format. All strings and binary fields are base64 encoded.\n\nPrototype\n\nint aws_event_stream_message_to_debug_str( FILE *fd, const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_message_total_length-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_message_total_length","text":"aws_event_stream_message_total_length(message)\n\nReturns the total length of the message (including the length field).\n\nPrototype\n\nuint32_t aws_event_stream_message_total_length(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_read_headers_from_buffer-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_read_headers_from_buffer","text":"aws_event_stream_read_headers_from_buffer(headers, buffer, headers_len)\n\nGet the headers from the buffer, store them in the headers list. the user's responsibility to cleanup the list when they are finished with it. no buffer copies happen here, the lifetime of the buffer, must outlive the usage of the headers. returns error codes defined in the public interface.\n\nPrototype\n\nint aws_event_stream_read_headers_from_buffer( struct aws_array_list *headers, const uint8_t *buffer, size_t headers_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_acquire","text":"aws_event_stream_rpc_client_connection_acquire(connection)\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_acquire( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_close-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_close","text":"aws_event_stream_rpc_client_connection_close(connection, shutdown_error_code)\n\nCloses the connection if it is open and aws_event_stream_rpc_client_connection_options::on_connection_shutdown will be invoked upon shutdown. shutdown_error_code will indicate the reason for shutdown. For a graceful shutdown pass 0 or AWS_ERROR_SUCCESS.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_close( struct aws_event_stream_rpc_client_connection *connection, int shutdown_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_connect-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_connect","text":"aws_event_stream_rpc_client_connection_connect(allocator, conn_options)\n\nInitiate a new connection. If this function returns AWS_OP_SUCESSS, the aws_event_stream_rpc_client_connection_options::on_connection_setup is guaranteed to be called exactly once. If that callback successfully creates a connection, aws_event_stream_rpc_client_connection_options::on_connection_shutdown will be invoked upon connection closure. However if the connection was never successfully setup, aws_event_stream_rpc_client_connection_options::on_connection_shutdown will not be invoked later.\n\nPrototype\n\nint aws_event_stream_rpc_client_connection_connect( struct aws_allocator *allocator, const struct aws_event_stream_rpc_client_connection_options *conn_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_is_open-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_is_open","text":"aws_event_stream_rpc_client_connection_is_open(connection)\n\nReturns true if the connection is open, false otherwise.\n\nPrototype\n\nbool aws_event_stream_rpc_client_connection_is_open( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_new_stream-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_new_stream","text":"aws_event_stream_rpc_client_connection_new_stream(connection, continuation_options)\n\nCreate a new stream. continuation_option's callbacks will not be invoked, and nothing will be sent across the wire until aws_event_stream_rpc_client_continuation_activate() is invoked.\n\nreturns an instance of a aws_event_stream_rpc_client_continuation_token on success with a reference count of 1. You must call aws_event_stream_rpc_client_continuation_release() when you're finished with it. Returns NULL on failure.\n\nPrototype\n\nstruct aws_event_stream_rpc_client_continuation_token * aws_event_stream_rpc_client_connection_new_stream( struct aws_event_stream_rpc_client_connection *connection, const struct aws_event_stream_rpc_client_stream_continuation_options *continuation_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_release","text":"aws_event_stream_rpc_client_connection_release(connection)\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_release( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_connection_send_protocol_message-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_connection_send_protocol_message","text":"aws_event_stream_rpc_client_connection_send_protocol_message(connection, message_args, flush_fn, user_data)\n\nSends a message on the connection. These must be connection level messages (not application messages).\n\nflush_fn will be invoked when the message has been successfully writen to the wire or when it fails.\n\nreturns AWS_OP_SUCCESS if the message was successfully created and queued, and in that case flush_fn will always be invoked. Otherwise, flush_fn will not be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_client_connection_send_protocol_message( struct aws_event_stream_rpc_client_connection *connection, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_acquire","text":"aws_event_stream_rpc_client_continuation_acquire(continuation)\n\nPrototype\n\nvoid aws_event_stream_rpc_client_continuation_acquire( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_activate-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_activate","text":"aws_event_stream_rpc_client_continuation_activate(continuation, operation_name, message_args, flush_fn, user_data)\n\nActually sends the initial stream to the peer. Callbacks from aws_event_stream_rpc_client_connection_new_stream() will actually be invoked if this function returns AWS_OP_SUCCESS, otherwise, the stream has not been queued and no callbacks will be invoked.\n\noperation_name is the name to identify which logical rpc call you want to kick off with the peer. It must be non-empty. flush_fn will be invoked once the message has either been written to the wire or it fails.\n\nPrototype\n\nint aws_event_stream_rpc_client_continuation_activate( struct aws_event_stream_rpc_client_continuation_token *continuation, struct aws_byte_cursor operation_name, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_get_user_data-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_get_user_data","text":"aws_event_stream_rpc_client_continuation_get_user_data(continuation)\n\nPrototype\n\nvoid *aws_event_stream_rpc_client_continuation_get_user_data( struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_is_closed-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_is_closed","text":"aws_event_stream_rpc_client_continuation_is_closed(continuation)\n\nreturns true if the continuation has been closed.\n\nPrototype\n\nbool aws_event_stream_rpc_client_continuation_is_closed( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_release","text":"aws_event_stream_rpc_client_continuation_release(continuation)\n\nPrototype\n\nvoid aws_event_stream_rpc_client_continuation_release( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_client_continuation_send_message-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_client_continuation_send_message","text":"aws_event_stream_rpc_client_continuation_send_message(continuation, message_args, flush_fn, user_data)\n\nSends a message on the continuation. aws_event_stream_rpc_client_continuation_activate() must be successfully invoked prior to calling this function.\n\nIf this function returns AWS_OP_SUCCESS, flush_fn will be invoked once the message has either been written to the wire or it fails.\n\nPrototype\n\nint aws_event_stream_rpc_client_continuation_send_message( struct aws_event_stream_rpc_client_continuation_token *continuation, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_acquire","text":"aws_event_stream_rpc_server_connection_acquire(connection)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_acquire( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_close-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_close","text":"aws_event_stream_rpc_server_connection_close(connection, shutdown_error_code)\n\nCloses the connection (including all continuations on the connection), and releases the connection ref count. shutdown_error_code is the error code to use when shutting down the channel. Use AWS_ERROR_SUCCESS for non-error cases.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_close( struct aws_event_stream_rpc_server_connection *connection, int shutdown_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_from_existing_channel-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_from_existing_channel","text":"aws_event_stream_rpc_server_connection_from_existing_channel(server, channel, connection_options)\n\nBypasses server, and creates a connection on an already existing channel. No connection lifetime callbacks will be invoked on the returned connection. Returns NULL if an error occurs. If and only if, you use this API, the returned connection is already ref counted and you must call aws_event_stream_rpc_server_connection_release() even if you did not explictly call aws_event_stream_rpc_server_connection_acquire()\n\nPrototype\n\nstruct aws_event_stream_rpc_server_connection * aws_event_stream_rpc_server_connection_from_existing_channel( struct aws_event_stream_rpc_server_listener *server, struct aws_channel *channel, const struct aws_event_stream_rpc_connection_options *connection_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_get_user_data-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_get_user_data","text":"aws_event_stream_rpc_server_connection_get_user_data(connection)\n\nPrototype\n\nvoid *aws_event_stream_rpc_server_connection_get_user_data( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_is_open-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_is_open","text":"aws_event_stream_rpc_server_connection_is_open(connection)\n\nreturns true if the connection is open. False otherwise.\n\nPrototype\n\nbool aws_event_stream_rpc_server_connection_is_open( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_release","text":"aws_event_stream_rpc_server_connection_release(connection)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_release( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_connection_send_protocol_message-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_connection_send_protocol_message","text":"aws_event_stream_rpc_server_connection_send_protocol_message(connection, message_args, flush_fn, user_data)\n\nSends a protocol message on the connection (not application data). If the message is valid and successfully written to the channel, flush_fn will be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_server_connection_send_protocol_message( struct aws_event_stream_rpc_server_connection *connection, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_server_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_continuation_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_continuation_acquire","text":"aws_event_stream_rpc_server_continuation_acquire(continuation)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_continuation_acquire( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_continuation_is_closed-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_continuation_is_closed","text":"aws_event_stream_rpc_server_continuation_is_closed(continuation)\n\nreturns true if the continuation is still in an open state.\n\nPrototype\n\nbool aws_event_stream_rpc_server_continuation_is_closed( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_continuation_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_continuation_release","text":"aws_event_stream_rpc_server_continuation_release(continuation)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_continuation_release( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_continuation_send_message-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_continuation_send_message","text":"aws_event_stream_rpc_server_continuation_send_message(continuation, message_args, flush_fn, user_data)\n\nSends an application message on the continuation. If the message is valid and successfully written to the channel, flush_fn will be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_server_continuation_send_message( struct aws_event_stream_rpc_server_continuation_token *continuation, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_server_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_listener_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_listener_acquire","text":"aws_event_stream_rpc_server_listener_acquire(listener)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_listener_acquire( struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_listener_get_bound_port-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_listener_get_bound_port","text":"aws_event_stream_rpc_server_listener_get_bound_port(listener)\n\nGet the local port which the listener's socket is bound to.\n\nPrototype\n\nuint16_t aws_event_stream_rpc_server_listener_get_bound_port( const struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_listener_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_listener_release","text":"aws_event_stream_rpc_server_listener_release(listener)\n\nPrototype\n\nvoid aws_event_stream_rpc_server_listener_release( struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_rpc_server_new_listener-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_rpc_server_new_listener","text":"aws_event_stream_rpc_server_new_listener(allocator, options)\n\nCreates a listener with a ref count of 1. You are responsible for calling aws_event_stream_rpc_server_listener_release() when you're finished with the listener. Returns NULL if an error occurs.\n\nPrototype\n\nstruct aws_event_stream_rpc_server_listener *aws_event_stream_rpc_server_new_listener( struct aws_allocator *allocator, struct aws_event_stream_rpc_server_listener_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_streaming_decoder_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_streaming_decoder_clean_up","text":"aws_event_stream_streaming_decoder_clean_up(decoder)\n\nCurrently, no memory is allocated inside aws_aws_event_stream_streaming_decoder, but for future API compatibility, you should call this when finished with it.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_clean_up( struct aws_event_stream_streaming_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_streaming_decoder_init-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_streaming_decoder_init","text":"aws_event_stream_streaming_decoder_init(decoder, alloc, on_payload_segment, on_prelude, on_header, on_error, user_data)\n\nDeprecated. Use aws_event_stream_streaming_decoder_init_from_options instead. Initialize a streaming decoder for messages with callbacks for usage and an optional user context pointer.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_init( struct aws_event_stream_streaming_decoder *decoder, struct aws_allocator *alloc, aws_event_stream_process_on_payload_segment_fn *on_payload_segment, aws_event_stream_prelude_received_fn *on_prelude, aws_event_stream_header_received_fn *on_header, aws_event_stream_on_error_fn *on_error, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_streaming_decoder_init_from_options-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_streaming_decoder_init_from_options","text":"aws_event_stream_streaming_decoder_init_from_options(decoder, allocator, options)\n\nInitialize a streaming decoder for messages with callbacks for usage and an optional user context pointer.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_init_from_options( struct aws_event_stream_streaming_decoder *decoder, struct aws_allocator *allocator, const struct aws_event_stream_streaming_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_streaming_decoder_pump-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_streaming_decoder_pump","text":"aws_event_stream_streaming_decoder_pump(decoder, data)\n\nThe main driver of the decoder. Pass data that should be decoded with its length. A likely use-case here is in response to a read event from an io-device\n\nPrototype\n\nint aws_event_stream_streaming_decoder_pump( struct aws_event_stream_streaming_decoder *decoder, const struct aws_byte_buf *data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_write_headers_to_buffer-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_write_headers_to_buffer","text":"aws_event_stream_write_headers_to_buffer(headers, buffer)\n\nDeprecated in favor of 'aws_event_stream_write_headers_to_buffer_safe' as this API is unsafe.\n\nWrites headers to buffer and returns the length of bytes written to buffer. Assumes buffer is large enough to store the headers.\n\nPrototype\n\nsize_t aws_event_stream_write_headers_to_buffer(const struct aws_array_list *headers, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_event_stream_write_headers_to_buffer_safe-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_event_stream_write_headers_to_buffer_safe","text":"aws_event_stream_write_headers_to_buffer_safe(headers, buf)\n\nWrites headers to buf assuming buf is large enough to hold the data. Prefer this function over the unsafe variant 'aws_event_stream_write_headers_to_buffer'.\n\nReturns AWS_OP_SUCCESS if the headers were successfully and completely written and AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_event_stream_write_headers_to_buffer_safe( const struct aws_array_list *headers, struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_fatal_assert-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_fatal_assert","text":"aws_fatal_assert(cond_str, file, line)\n\nPrototype\n\nvoid aws_fatal_assert(const char *cond_str, const char *file, int line) AWS_ATTRIBUTE_NORETURN;\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_file_delete-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_file_delete","text":"aws_file_delete(file_path)\n\nDeletes a file. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise, aws_last_error() will contain the error that occurred. If the file doesn't exist, AWS_OP_SUCCESS is still returned.\n\nPrototype\n\nint aws_file_delete(const struct aws_string *file_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_file_get_length-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_file_get_length","text":"aws_file_get_length(file, length)\n\nPrototype\n\nint aws_file_get_length(FILE *file, int64_t *length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_fopen-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_fopen","text":"aws_fopen(file_path, mode)\n\nDeprecated - Use aws_fopen_safe() instead, avoid const char * in public APIs. Opens file at file_path using mode. Returns the FILE pointer if successful. Otherwise, aws_last_error() will contain the error that occurred\n\nPrototype\n\nFILE *aws_fopen(const char *file_path, const char *mode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_fopen_safe-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_fopen_safe","text":"aws_fopen_safe(file_path, mode)\n\nOpens file at file_path using mode. Returns the FILE pointer if successful. Otherwise, aws_last_error() will contain the error that occurred\n\nPrototype\n\nFILE *aws_fopen_safe(const struct aws_string *file_path, const struct aws_string *mode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_fseek-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_fseek","text":"aws_fseek(file, offset, whence)\n\nPrototype\n\nint aws_fseek(FILE *file, int64_t offset, int whence);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_acquire","text":"aws_future_bool_acquire(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_get_error","text":"aws_future_bool_get_error(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_get_result-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_get_result","text":"aws_future_bool_get_result(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_is_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_is_done","text":"aws_future_bool_is_done(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_new","text":"aws_future_bool_new(alloc)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_register_callback","text":"aws_future_bool_register_callback(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_register_callback_if_not_done","text":"aws_future_bool_register_callback_if_not_done(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_register_channel_callback","text":"aws_future_bool_register_channel_callback(future, channel, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_register_event_loop_callback","text":"aws_future_bool_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_release","text":"aws_future_bool_release(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_set_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_set_error","text":"aws_future_bool_set_error(future, error_code)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_set_result-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_set_result","text":"aws_future_bool_set_result(future, result)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_bool_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_bool_wait","text":"aws_future_bool_wait(future, timeout_ns)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_bool, bool, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_acquire","text":"aws_future_http_message_acquire(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_get_error","text":"aws_future_http_message_get_error(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_get_result_by_move-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_get_result_by_move","text":"aws_future_http_message_get_result_by_move(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_is_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_is_done","text":"aws_future_http_message_is_done(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_new","text":"aws_future_http_message_new(alloc)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_peek_result-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_peek_result","text":"aws_future_http_message_peek_result(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_register_callback","text":"aws_future_http_message_register_callback(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_register_callback_if_not_done","text":"aws_future_http_message_register_callback_if_not_done(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_register_channel_callback","text":"aws_future_http_message_register_channel_callback(future, channel, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_register_event_loop_callback","text":"aws_future_http_message_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_release","text":"aws_future_http_message_release(future)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_set_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_set_error","text":"aws_future_http_message_set_error(future, error_code)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_set_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_set_result_by_move","text":"aws_future_http_message_set_result_by_move(future, pointer_address)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_http_message_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_http_message_wait","text":"aws_future_http_message_wait(future, timeout_ns)\n\nPrototype\n\nAWS_FUTURE_T_POINTER_WITH_RELEASE_DECLARATION(aws_future_http_message, struct aws_http_message, AWS_HTTP_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_acquire","text":"aws_future_impl_acquire(promise)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_acquire(struct aws_future_impl *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_get_error","text":"aws_future_impl_get_error(future)\n\nPrototype\n\nint aws_future_impl_get_error(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_get_result_address-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_get_result_address","text":"aws_future_impl_get_result_address(future)\n\nPrototype\n\nvoid *aws_future_impl_get_result_address(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_get_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_get_result_by_move","text":"aws_future_impl_get_result_by_move(future, dst_address)\n\nPrototype\n\nvoid aws_future_impl_get_result_by_move(struct aws_future_impl *future, void *dst_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_is_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_is_done","text":"aws_future_impl_is_done(future)\n\nPrototype\n\nbool aws_future_impl_is_done(const struct aws_future_impl *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_new_by_value-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_new_by_value","text":"aws_future_impl_new_by_value(alloc, sizeof_result)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_by_value(struct aws_allocator *alloc, size_t sizeof_result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_new_by_value_with_clean_up-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_new_by_value_with_clean_up","text":"aws_future_impl_new_by_value_with_clean_up(alloc, sizeof_result, result_clean_up)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_by_value_with_clean_up( struct aws_allocator *alloc, size_t sizeof_result, aws_future_impl_result_clean_up_fn *result_clean_up);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_new_pointer-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_new_pointer","text":"aws_future_impl_new_pointer(alloc)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_new_pointer_with_destroy-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_new_pointer_with_destroy","text":"aws_future_impl_new_pointer_with_destroy(alloc, result_destroy)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer_with_destroy( struct aws_allocator *alloc, aws_future_impl_result_destroy_fn *result_destroy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_new_pointer_with_release-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_new_pointer_with_release","text":"aws_future_impl_new_pointer_with_release(alloc, result_release)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_new_pointer_with_release( struct aws_allocator *alloc, aws_future_impl_result_release_fn *result_release);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_register_callback","text":"aws_future_impl_register_callback(future, on_done, user_data)\n\nPrototype\n\nvoid aws_future_impl_register_callback( struct aws_future_impl *future, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_register_callback_if_not_done","text":"aws_future_impl_register_callback_if_not_done(future, on_done, user_data)\n\nPrototype\n\nbool aws_future_impl_register_callback_if_not_done( struct aws_future_impl *future, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_register_channel_callback","text":"aws_future_impl_register_channel_callback(future, channel, on_done, user_data)\n\nPrototype\n\nvoid aws_future_impl_register_channel_callback( struct aws_future_impl *future, struct aws_channel *channel, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_register_event_loop_callback","text":"aws_future_impl_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nPrototype\n\nvoid aws_future_impl_register_event_loop_callback( struct aws_future_impl *future, struct aws_event_loop *event_loop, aws_future_callback_fn *on_done, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_release","text":"aws_future_impl_release(promise)\n\nPrototype\n\nstruct aws_future_impl *aws_future_impl_release(struct aws_future_impl *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_set_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_set_error","text":"aws_future_impl_set_error(promise, error_code)\n\nPrototype\n\nvoid aws_future_impl_set_error(struct aws_future_impl *promise, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_set_result_by_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_set_result_by_move","text":"aws_future_impl_set_result_by_move(promise, src_address)\n\nPrototype\n\nvoid aws_future_impl_set_result_by_move(struct aws_future_impl *promise, void *src_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_impl_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_impl_wait","text":"aws_future_impl_wait(future, timeout_ns)\n\nPrototype\n\nbool aws_future_impl_wait(const struct aws_future_impl *future, uint64_t timeout_ns);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_acquire","text":"aws_future_size_acquire(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_get_error","text":"aws_future_size_get_error(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_get_result-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_get_result","text":"aws_future_size_get_result(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_is_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_is_done","text":"aws_future_size_is_done(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_new","text":"aws_future_size_new(alloc)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_register_callback","text":"aws_future_size_register_callback(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_register_callback_if_not_done","text":"aws_future_size_register_callback_if_not_done(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_register_channel_callback","text":"aws_future_size_register_channel_callback(future, channel, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_register_event_loop_callback","text":"aws_future_size_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_size_release","text":"aws_future_size_release(future)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_set_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_set_error","text":"aws_future_size_set_error(future, error_code)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_set_result-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_set_result","text":"aws_future_size_set_result(future, result)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_size_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_size_wait","text":"aws_future_size_wait(future, timeout_ns)\n\nPrototype\n\nAWS_FUTURE_T_BY_VALUE_DECLARATION(aws_future_size, size_t, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_acquire","text":"aws_future_void_acquire(future)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_get_error","text":"aws_future_void_get_error(future)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_is_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_is_done","text":"aws_future_void_is_done(future)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_new","text":"aws_future_void_new(alloc)\n\naws_future<void>\n\nPrototype\n\nstruct aws_future_void *aws_future_void_new(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_register_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_register_callback","text":"aws_future_void_register_callback(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_register_callback_if_not_done-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_register_callback_if_not_done","text":"aws_future_void_register_callback_if_not_done(future, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_register_channel_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_register_channel_callback","text":"aws_future_void_register_channel_callback(future, channel, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_register_event_loop_callback-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_register_event_loop_callback","text":"aws_future_void_register_event_loop_callback(future, event_loop, on_done, user_data)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_release","text":"aws_future_void_release(future)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_set_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_set_error","text":"aws_future_void_set_error(future, error_code)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_set_result-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_future_void_set_result","text":"aws_future_void_set_result(future)\n\nPrototype\n\nvoid aws_future_void_set_result(struct aws_future_void *future);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_future_void_wait-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_future_void_wait","text":"aws_future_void_wait(future, timeout_ns)\n\nPrototype\n\nAWS_FUTURE_T_DECLARATION_END(aws_future_void, AWS_IO_API);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_config_file_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_get_config_file_path","text":"aws_get_config_file_path(allocator, override_path)\n\nComputes the final platform-specific path for the profile config file. Does limited home directory expansion/resolution.\n\noverride_path, if not null, will be searched first instead of using the standard home directory config path\n\nPrototype\n\nstruct aws_string *aws_get_config_file_path( struct aws_allocator *allocator, const struct aws_byte_cursor *override_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_cpu_count_for_group-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_get_cpu_count_for_group","text":"aws_get_cpu_count_for_group(group_idx)\n\nFor a group, returns the number of CPUs it contains.\n\nPrototype\n\nsize_t aws_get_cpu_count_for_group(uint16_t group_idx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_cpu_group_count-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_cpu_group_count","text":"aws_get_cpu_group_count()\n\nReturns the logical processor groupings on the system (such as multiple numa nodes).\n\nPrototype\n\nuint16_t aws_get_cpu_group_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_cpu_ids_for_group-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_get_cpu_ids_for_group","text":"aws_get_cpu_ids_for_group(group_idx, cpu_ids_array, cpu_ids_array_length)\n\nFills in cpu_ids_array with the cpu_id's for the group. To obtain the size to allocate for cpu_ids_array and the value for argument for cpu_ids_array_length, call aws_get_cpu_count_for_group().\n\nPrototype\n\nvoid aws_get_cpu_ids_for_group(uint16_t group_idx, struct aws_cpu_info *cpu_ids_array, size_t cpu_ids_array_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_credentials_file_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_get_credentials_file_path","text":"aws_get_credentials_file_path(allocator, override_path)\n\nComputes the final platform-specific path for the profile credentials file. Does limited home directory expansion/resolution.\n\noverride_path, if not null, will be searched first instead of using the standard home directory config path\n\nPrototype\n\nstruct aws_string *aws_get_credentials_file_path( struct aws_allocator *allocator, const struct aws_byte_cursor *override_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_environment_value-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_get_environment_value","text":"aws_get_environment_value(allocator, variable_name, value_out)\n\nPrototype\n\nint aws_get_environment_value( struct aws_allocator *allocator, const struct aws_string *variable_name, struct aws_string **value_out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_hard_limit_io_handles-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_hard_limit_io_handles","text":"aws_get_hard_limit_io_handles()\n\nReturns the hard limit for max io handles (max fds in unix terminology). This limit is one more than the actual limit. This limit cannot be increased without sudo permissions.\n\nPrototype\n\nsize_t aws_get_hard_limit_io_handles(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_home_directory-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_get_home_directory","text":"aws_get_home_directory(allocator)\n\nReturns the current user's home directory.\n\nPrototype\n\nstruct aws_string *aws_get_home_directory(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_pid-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_pid","text":"aws_get_pid()\n\nReturns the current process's PID (process id).\n\nReturns\n\nPID as int\n\nPrototype\n\nint aws_get_pid(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_platform_build_os-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_platform_build_os","text":"aws_get_platform_build_os()\n\nPrototype\n\nenum aws_platform_os aws_get_platform_build_os(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_platform_directory_separator-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_platform_directory_separator","text":"aws_get_platform_directory_separator()\n\nReturns the directory separator used by the local platform\n\nPrototype\n\nchar aws_get_platform_directory_separator(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_profile_name-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_get_profile_name","text":"aws_get_profile_name(allocator, override_name)\n\nComputes the profile to use for credentials lookups based on profile resolution rules\n\nPrototype\n\nstruct aws_string *aws_get_profile_name(struct aws_allocator *allocator, const struct aws_byte_cursor *override_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_get_soft_limit_io_handles-Tuple{}","page":"Home","title":"LibAWSCRT.aws_get_soft_limit_io_handles","text":"aws_get_soft_limit_io_handles()\n\nReturns the soft limit for max io handles (max fds in unix terminology). This limit is one more than the actual limit. The soft limit can be changed up to the hard limit by any process regardless of permissions.\n\nPrototype\n\nsize_t aws_get_soft_limit_io_handles(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_gmtime-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_gmtime","text":"aws_gmtime(time, t)\n\nCross platform friendly version of gmtime_r\n\nPrototype\n\nvoid aws_gmtime(time_t time, struct tm *t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_array_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_array_ignore_case","text":"aws_hash_array_ignore_case(array, len)\n\nCase-insensitive hash function for array containing ASCII or UTF-8 text.\n\nPrototype\n\nuint64_t aws_hash_array_ignore_case(const void *array, const size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_byte_cursor_ptr-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_byte_cursor_ptr","text":"aws_hash_byte_cursor_ptr(item)\n\nConvenience hash function for struct aws_byte_cursor. Hash is same as used on the string bytes by aws_hash_c_string.\n\nPrototype\n\nuint64_t aws_hash_byte_cursor_ptr(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_byte_cursor_ptr_ignore_case-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_byte_cursor_ptr_ignore_case","text":"aws_hash_byte_cursor_ptr_ignore_case(item)\n\nCase-insensitive hash function for aws_byte_cursors stored in an aws_hash_table. For case-sensitive hashing, use aws_hash_byte_cursor_ptr().\n\nPrototype\n\nuint64_t aws_hash_byte_cursor_ptr_ignore_case(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_c_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_c_string","text":"aws_hash_c_string(item)\n\nConvenience hash function for NULL-terminated C-strings\n\nPrototype\n\nuint64_t aws_hash_c_string(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_callback_c_str_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_callback_c_str_eq","text":"aws_hash_callback_c_str_eq(a, b)\n\nConvenience eq callback for NULL-terminated C-strings\n\nPrototype\n\nbool aws_hash_callback_c_str_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_callback_string_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_callback_string_destroy","text":"aws_hash_callback_string_destroy(a)\n\nConvenience destroy callback for AWS strings\n\nPrototype\n\nvoid aws_hash_callback_string_destroy(void *a);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_callback_string_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_callback_string_eq","text":"aws_hash_callback_string_eq(a, b)\n\nConvenience eq callback for AWS strings\n\nPrototype\n\nbool aws_hash_callback_string_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_combine-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_combine","text":"aws_hash_combine(item1, item2)\n\nPrototype\n\nuint64_t aws_hash_combine(uint64_t item1, uint64_t item2);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_destroy","text":"aws_hash_destroy(hash)\n\nCleans up and deallocates hash.\n\nPrototype\n\nvoid aws_hash_destroy(struct aws_hash *hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_finalize-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_finalize","text":"aws_hash_finalize(hash, output, truncate_to)\n\nCompletes the hash computation and writes the final digest to output. Allocation of output is the caller's responsibility. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_hash_finalize(struct aws_hash *hash, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_iter_begin-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_iter_begin","text":"aws_hash_iter_begin(map)\n\nReturns an iterator to be used for iterating through a hash table. Iterator will already point to the first element of the table it finds, which can be accessed as iter.element.\n\nThis function cannot fail, but if there are no elements in the table, the returned iterator will return true for aws_hash_iter_done(&iter).\n\nPrototype\n\nstruct aws_hash_iter aws_hash_iter_begin(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_iter_delete-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_iter_delete","text":"aws_hash_iter_delete(iter, destroy_contents)\n\nDeletes the element currently pointed-to by the hash iterator. After calling this method, the element member of the iterator should not be accessed until the next call to aws_hash_iter_next.\n\nParameters\n\ndestroy_contents: If true, the destructors for the key and value will be called.\n\nPrototype\n\nvoid aws_hash_iter_delete(struct aws_hash_iter *iter, bool destroy_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_iter_done-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_iter_done","text":"aws_hash_iter_done(iter)\n\nReturns true if iterator is done iterating through table, false otherwise. If this is true, the iterator will not include an element of the table.\n\nPrototype\n\nbool aws_hash_iter_done(const struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_iter_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_iter_is_valid","text":"aws_hash_iter_is_valid(iter)\n\nGiven a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants.\n\nPrototype\n\nbool aws_hash_iter_is_valid(const struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_iter_next-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_iter_next","text":"aws_hash_iter_next(iter)\n\nUpdates iterator so that it points to next element of hash table.\n\nThis and the two previous functions are designed to be used together with the following idiom:\n\nfor (struct aws_hash_iter iter = aws_hash_iter_begin(&map); (Image: `aws_hash_iter_done`)(&iter); aws_hash_iter_next(&iter)) { const key_type key = *(const key_type *)iter.element.key; value_type value = *(value_type *)iter.element.value; // etc. }\n\nNote that calling this on an iter which is \"done\" is idempotent: i.e. it will return another iter which is \"done\".\n\nPrototype\n\nvoid aws_hash_iter_next(struct aws_hash_iter *iter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_ptr-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_ptr","text":"aws_hash_ptr(item)\n\nConvenience hash function which hashes the pointer value directly, without dereferencing. This can be used in cases where pointer identity is desired, or where a uintptr_t is encoded into a const void *.\n\nPrototype\n\nuint64_t aws_hash_ptr(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_string","text":"aws_hash_string(item)\n\nConvenience hash function for struct aws_strings. Hash is same as used on the string bytes by aws_hash_c_string.\n\nPrototype\n\nuint64_t aws_hash_string(const void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_clean_up","text":"aws_hash_table_clean_up(map)\n\nDeletes every element from map and frees all associated memory. destroy_fn will be called for each element. aws_hash_table_init must be called before reusing the hash table.\n\nThis method is idempotent.\n\nPrototype\n\nvoid aws_hash_table_clean_up(struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_clear","text":"aws_hash_table_clear(map)\n\nRemoves every element from the hash map. destroy_fn will be called for each element.\n\nPrototype\n\nvoid aws_hash_table_clear(struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_create-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_create","text":"aws_hash_table_create(map, key, p_elem, was_created)\n\nAttempts to locate an element at key. If no such element was found, creates a new element, with value initialized to NULL. In either case, a pointer to the element is placed in *p_elem.\n\nIf was_created is non-NULL, *was_created is set to 0 if an existing element was found, or 1 is a new element was created.\n\nReturns AWS_OP_SUCCESS if an item was found or created. Raises AWS_ERROR_OOM if hash table expansion was required and memory allocation failed.\n\nPrototype\n\nint aws_hash_table_create( struct aws_hash_table *map, const void *key, struct aws_hash_element **p_elem, int *was_created);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_eq-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_eq","text":"aws_hash_table_eq(a, b, value_eq)\n\nCompares two hash tables for equality. Both hash tables must have equivalent key comparators; values will be compared using the comparator passed into this function. The key hash function does not need to be equivalent between the two hash tables.\n\nPrototype\n\nbool aws_hash_table_eq( const struct aws_hash_table *a, const struct aws_hash_table *b, aws_hash_callback_eq_fn *value_eq);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_find","text":"aws_hash_table_find(map, key, p_elem)\n\nAttempts to locate an element at key. If the element is found, a pointer to the value is placed in *p_elem; if it is not found, *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.\n\nThis method does not change the state of the hash table. Therefore, it is safe to call _find from multiple threads on the same hash table, provided no mutating operations happen in parallel.\n\nCalling code may update the value in the hash table by modifying **pElem after a successful find. However, this pointer is not guaranteed to remain usable after a subsequent call to _put, _delete, _clear, or _clean_up.\n\nPrototype\n\nint aws_hash_table_find(const struct aws_hash_table *map, const void *key, struct aws_hash_element **p_elem);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_foreach-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_foreach","text":"aws_hash_table_foreach(map, callback, context)\n\nIterates through every element in the map and invokes the callback on that item. Iteration is performed in an arbitrary, implementation-defined order, and is not guaranteed to be consistent across invocations.\n\nThe callback may change the value associated with the key by overwriting the value pointed-to by value. In this case, the on_element_removed callback will not be invoked, unless the callback invokes AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed is given the updated value).\n\nThe callback must return a bitmask of zero or more of the following values ORed together:\n\nAWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next element (if not set, iteration stops) # AWS_COMMON_HASH_TABLE_ITER_DELETE - Deletes the current value and continues iteration. destroy_fn will NOT be invoked. # AWS_COMMON_HASH_TABLE_ITER_ERROR - Stop iteration with error. No action will be taken for the current value and the value before this. No rolling back. The deleted value before will NOT be back. aws_hash_table_foreach returns AWS_OP_ERR after stropping the iteration.\n\nInvoking any method which may change the contents of the hashtable during iteration results in undefined behavior. However, you may safely invoke non-mutating operations during an iteration.\n\nThis operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE is returned at some point during iteration. Otherwise, it is non-mutating and is safe to invoke in parallel with other non-mutating operations.\n\nPrototype\n\nint aws_hash_table_foreach( struct aws_hash_table *map, int (*callback)(void *context, struct aws_hash_element *p_element), void *context);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_get_entry_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_get_entry_count","text":"aws_hash_table_get_entry_count(map)\n\nReturns the current number of entries in the table.\n\nPrototype\n\nsize_t aws_hash_table_get_entry_count(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_init-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_init","text":"aws_hash_table_init(map, alloc, size, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn)\n\nInitializes a hash map with initial capacity for 'size' elements without resizing. Uses hash_fn to compute the hash of each element. equals_fn to compute equality of two keys. Whenever an element is removed without being returned, destroy_key_fn is run on the pointer to the key and destroy_value_fn is run on the pointer to the value. Either or both may be NULL if a callback is not desired in this case.\n\nPrototype\n\nint aws_hash_table_init( struct aws_hash_table *map, struct aws_allocator *alloc, size_t size, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_is_valid","text":"aws_hash_table_is_valid(map)\n\nBest-effort check of hash_table_state data-structure invariants\n\nPrototype\n\nbool aws_hash_table_is_valid(const struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_move","text":"aws_hash_table_move(to, from)\n\nMoves the hash table in 'from' to 'to'. After this move, 'from' will be identical to the state of the original 'to' hash table, and 'to' will be in the same state as if it had been passed to aws_hash_table_clean_up (that is, it will have no memory allocated, and it will be safe to either discard it or call aws_hash_table_clean_up again).\n\nNote that 'to' will not be cleaned up. You should make sure that 'to' is either uninitialized or cleaned up before moving a hashtable into it.\n\nPrototype\n\nvoid aws_hash_table_move(struct aws_hash_table *AWS_RESTRICT to, struct aws_hash_table *AWS_RESTRICT from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_put-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_put","text":"aws_hash_table_put(map, key, value, was_created)\n\nInserts a new element at key, with the given value. If another element exists at that key, the old element will be overwritten; both old key and value objects will be destroyed.\n\nIf was_created is non-NULL, *was_created is set to 0 if an existing element was found, or 1 is a new element was created.\n\nReturns AWS_OP_SUCCESS if an item was found or created. Raises AWS_ERROR_OOM if hash table expansion was required and memory\n\nPrototype\n\nint aws_hash_table_put(struct aws_hash_table *map, const void *key, void *value, int *was_created);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_remove-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_remove","text":"aws_hash_table_remove(map, key, p_value, was_present)\n\nRemoves element at key. Always returns AWS_OP_SUCCESS.\n\nIf pValue is non-NULL, the existing value (if any) is moved into (*value) before removing from the table, and destroy_fn is _not_ invoked. If pValue is NULL, then (if the element existed) destroy_fn will be invoked on the element being removed.\n\nIf was_present is non-NULL, it is set to 0 if the element was not present, or 1 if it was present (and is now removed).\n\nPrototype\n\nint aws_hash_table_remove( struct aws_hash_table *map, const void *key, struct aws_hash_element *p_value, int *was_present);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_remove_element-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_remove_element","text":"aws_hash_table_remove_element(map, p_value)\n\nRemoves element already known (typically by find()).\n\np_value should point to a valid element returned by create() or find().\n\nNOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return AWS_COMMON_HASH_TABLE_ITER_DELETE instead.\n\nPrototype\n\nint aws_hash_table_remove_element(struct aws_hash_table *map, struct aws_hash_element *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_table_swap-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_table_swap","text":"aws_hash_table_swap(a, b)\n\nSafely swaps two hash tables. Note that we swap the entirety of the hash table, including which allocator is associated.\n\nNeither hash table is required to be initialized; if one or both is uninitialized, then the uninitialized state is also swapped.\n\nPrototype\n\nvoid aws_hash_table_swap(struct aws_hash_table *AWS_RESTRICT a, struct aws_hash_table *AWS_RESTRICT b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hash_update-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hash_update","text":"aws_hash_update(hash, to_hash)\n\nUpdates the running hash with to_hash. this can be called multiple times.\n\nPrototype\n\nint aws_hash_update(struct aws_hash *hash, const struct aws_byte_cursor *to_hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hex_compute_decoded_len-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hex_compute_decoded_len","text":"aws_hex_compute_decoded_len(to_decode_len, decoded_len)\n\nPrototype\n\nint aws_hex_compute_decoded_len(size_t to_decode_len, size_t *decoded_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hex_compute_encoded_len-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hex_compute_encoded_len","text":"aws_hex_compute_encoded_len(to_encode_len, encoded_length)\n\nPrototype\n\nint aws_hex_compute_encoded_len(size_t to_encode_len, size_t *encoded_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hex_decode-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hex_decode","text":"aws_hex_decode(to_decode, output)\n\nPrototype\n\nint aws_hex_decode(const struct aws_byte_cursor *AWS_RESTRICT to_decode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hex_encode-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hex_encode","text":"aws_hex_encode(to_encode, output)\n\nPrototype\n\nint aws_hex_encode(const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hex_encode_append_dynamic-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hex_encode_append_dynamic","text":"aws_hex_encode_append_dynamic(to_encode, output)\n\nPrototype\n\nint aws_hex_encode_append_dynamic( const struct aws_byte_cursor *AWS_RESTRICT to_encode, struct aws_byte_buf *AWS_RESTRICT output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_high_res_clock_get_ticks-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_high_res_clock_get_ticks","text":"aws_high_res_clock_get_ticks(timestamp)\n\nGet ticks in nanoseconds (usually 100 nanosecond precision) on the high resolution clock (most-likely TSC). This clock has no bearing on the actual system time. On success, timestamp will be set.\n\nPrototype\n\nint aws_high_res_clock_get_ticks(uint64_t *timestamp);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hmac_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hmac_destroy","text":"aws_hmac_destroy(hmac)\n\nCleans up and deallocates hmac.\n\nPrototype\n\nvoid aws_hmac_destroy(struct aws_hmac *hmac);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hmac_finalize-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_hmac_finalize","text":"aws_hmac_finalize(hmac, output, truncate_to)\n\nCompletes the hmac computation and writes the final digest to output. Allocation of output is the caller's responsibility. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_hmac_finalize(struct aws_hmac *hmac, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hmac_update-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_hmac_update","text":"aws_hmac_update(hmac, to_hmac)\n\nUpdates the running hmac with to_hash. this can be called multiple times.\n\nPrototype\n\nint aws_hmac_update(struct aws_hmac *hmac, const struct aws_byte_cursor *to_hmac);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_address_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_host_address_clean_up","text":"aws_host_address_clean_up(address)\n\nCleans up the memory for address\n\nPrototype\n\nvoid aws_host_address_clean_up(struct aws_host_address *address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_address_copy-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_address_copy","text":"aws_host_address_copy(from, to)\n\nCopies from to to.\n\nPrototype\n\nint aws_host_address_copy(const struct aws_host_address *from, struct aws_host_address *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_address_move-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_address_move","text":"aws_host_address_move(from, to)\n\nMoves from to to. After this call, from is no longer usable. Though, it could be resused for another move or copy operation.\n\nPrototype\n\nvoid aws_host_address_move(struct aws_host_address *from, struct aws_host_address *to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_acquire","text":"aws_host_resolver_acquire(resolver)\n\nIncrements the reference count on the host resolver, allowing the caller to take a reference to it.\n\nReturns the same host resolver passed in.\n\nPrototype\n\nstruct aws_host_resolver *aws_host_resolver_acquire(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_get_host_address_count-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_get_host_address_count","text":"aws_host_resolver_get_host_address_count(resolver, host_name, flags)\n\nget number of addresses for a given host.\n\nPrototype\n\nsize_t aws_host_resolver_get_host_address_count( struct aws_host_resolver *resolver, const struct aws_string *host_name, uint32_t flags);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_init_default_resolution_config-Tuple{}","page":"Home","title":"LibAWSCRT.aws_host_resolver_init_default_resolution_config","text":"aws_host_resolver_init_default_resolution_config()\n\nReturns the default host resolution config used internally if none specified.\n\nReturns\n\ndefault host resolution config\n\nPrototype\n\nstruct aws_host_resolution_config aws_host_resolver_init_default_resolution_config(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_new_default-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_new_default","text":"aws_host_resolver_new_default(allocator, options)\n\nCreates a host resolver with the default behavior. Here's the behavior:\n\nSince there's not a reliable way to do non-blocking DNS without a ton of risky work that would need years of testing on every Unix system in existence, we work around it by doing a threaded implementation.\n\nWhen you request an address, it checks the cache. If the entry isn't in the cache it creates a new one. Each entry has a potentially short lived back-ground thread based on ttl for the records. Once we've populated the cache and you keep the resolver active, the resolution callback will be invoked immediately. When it's idle, it will take a little while in the background thread to fetch more, evaluate TTLs etc... In that case your callback will be invoked from the background thread.\n\n\n\nA few things to note about TTLs and connection failures.\n\nWe attempt to honor your max ttl but will not honor it if dns queries are failing or all of your connections are marked as failed. Once we are able to query dns again, we will re-evaluate the TTLs.\n\nUpon notification connection failures, we move them to a separate list. Eventually we retry them when it's likely that the endpoint is healthy again or we don't really have another choice, but we try to keep them out of your hot path.\n\n\n\nFinally, this entire design attempts to prevent problems where developers have to choose between large TTLs and thus sticky hosts or short TTLs and good fleet utilization but now higher latencies. In this design, we resolve every second in the background (only while you're actually using the record), but we do not expire the earlier resolved addresses until max ttl has passed.\n\nThis for example, should enable you to hit thousands of hosts in the Amazon S3 fleet instead of just one or two.\n\nPrototype\n\nstruct aws_host_resolver *aws_host_resolver_new_default( struct aws_allocator *allocator, const struct aws_host_resolver_default_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_purge_cache-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_purge_cache","text":"aws_host_resolver_purge_cache(resolver)\n\n\\deprecated Use purge_cache_with_callback instead calls purge_cache on the vtable.\n\nPrototype\n\nint aws_host_resolver_purge_cache(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_purge_cache_with_callback-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_purge_cache_with_callback","text":"aws_host_resolver_purge_cache_with_callback(resolver, on_purge_cache_complete_callback, user_data)\n\nCalls aws_host_resolver_purge_cache_with_callback on the vtable which will wipe out everything host resolver has cached.\n\nPrototype\n\nint aws_host_resolver_purge_cache_with_callback( struct aws_host_resolver *resolver, aws_simple_completion_callback *on_purge_cache_complete_callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_purge_host_cache-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_purge_host_cache","text":"aws_host_resolver_purge_host_cache(resolver, options)\n\nRemoves the cache for a host asynchronously.\n\nPrototype\n\nint aws_host_resolver_purge_host_cache( struct aws_host_resolver *resolver, const struct aws_host_resolver_purge_host_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_record_connection_failure-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_record_connection_failure","text":"aws_host_resolver_record_connection_failure(resolver, address)\n\ncalls record_connection_failure on the vtable.\n\nPrototype\n\nint aws_host_resolver_record_connection_failure( struct aws_host_resolver *resolver, const struct aws_host_address *address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_release","text":"aws_host_resolver_release(resolver)\n\nDecrements a host resolver's ref count. When the ref count drops to zero, the resolver will be destroyed.\n\nPrototype\n\nvoid aws_host_resolver_release(struct aws_host_resolver *resolver);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_host_resolver_resolve_host-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_host_resolver_resolve_host","text":"aws_host_resolver_resolve_host(resolver, host_name, res, config, user_data)\n\ncalls resolve_host on the vtable. config will be copied.\n\nPrototype\n\nint aws_host_resolver_resolve_host( struct aws_host_resolver *resolver, const struct aws_string *host_name, aws_on_host_resolved_result_fn *res, const struct aws_host_resolution_config *config, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hton16-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hton16","text":"aws_hton16(x)\n\nConvert 16 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_hton16(uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hton32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hton32","text":"aws_hton32(x)\n\nConvert 32 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_hton32(uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_hton64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_hton64","text":"aws_hton64(x)\n\nConvert 64 bit integer from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_hton64(uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_htonf32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_htonf32","text":"aws_htonf32(x)\n\nConvert 32 bit float from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_htonf32(float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_htonf64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_htonf64","text":"aws_htonf64(x)\n\nConvert 64 bit double from host to network byte order.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_htonf64(double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http1_stream_add_chunked_trailer-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http1_stream_add_chunked_trailer","text":"aws_http1_stream_add_chunked_trailer(http1_stream, trailing_headers)\n\nAdd a list of headers to be added as trailing headers sent after the last chunk is sent. a \"Trailer\" header field which indicates the fields present in the trailer.\n\nCertain headers are forbidden in the trailer (e.g., Transfer-Encoding, Content-Length, Host). See RFC-7541 Section 4.1.2 for more details.\n\nFor client streams, activate() must be called before any chunks are submitted.\n\nFor server streams, the response must be submitted before the trailer can be added\n\naws_http1_stream_add_chunked_trailer must be called before the final size 0 chunk, and at the moment can only be called once, though this could change if need be.\n\nReturns AWS_OP_SUCCESS if the chunk has been submitted.\n\nPrototype\n\nint aws_http1_stream_add_chunked_trailer( struct aws_http_stream *http1_stream, const struct aws_http_headers *trailing_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http1_stream_write_chunk-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http1_stream_write_chunk","text":"aws_http1_stream_write_chunk(http1_stream, options)\n\nSubmit a chunk of data to be sent on an HTTP/1.1 stream. The stream must have specified \"chunked\" in a \"transfer-encoding\" header. For client streams, activate() must be called before any chunks are submitted. For server streams, the response must be submitted before any chunks. A final chunk with size 0 must be submitted to successfully complete the HTTP-stream.\n\nReturns AWS_OP_SUCCESS if the chunk has been submitted. The chunk's completion callback will be invoked when the HTTP-stream is done with the chunk data, whether or not it was successfully sent (see aws_http1_stream_write_chunk_complete_fn). The chunk data must remain valid until the completion callback is invoked.\n\nReturns AWS_OP_ERR and raises an error if the chunk could not be submitted. In this case, the chunk's completion callback will never be invoked. Note that it is always possible for the HTTP-stream to terminate unexpectedly prior to this call being made, in which case the error raised is AWS_ERROR_HTTP_STREAM_HAS_COMPLETED.\n\nPrototype\n\nint aws_http1_stream_write_chunk( struct aws_http_stream *http1_stream, const struct aws_http1_chunk_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_change_settings-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_change_settings","text":"aws_http2_connection_change_settings(http2_connection, settings_array, num_settings, on_completed, user_data)\n\nSend a SETTINGS frame (HTTP/2 only). SETTINGS will be applied locally when SETTINGS ACK is received from peer.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nsettings_array: The array of settings to change. Note: each setting has its boundary.\nnum_settings: The num of settings to change in settings_array.\non_completed: Optional callback, see aws_http2_on_change_settings_complete_fn.\nuser_data: User-data pass to on_completed callback.\n\nPrototype\n\nint aws_http2_connection_change_settings( struct aws_http_connection *http2_connection, const struct aws_http2_setting *settings_array, size_t num_settings, aws_http2_on_change_settings_complete_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_get_local_settings-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_get_local_settings","text":"aws_http2_connection_get_local_settings(http2_connection, out_settings)\n\nGet the local settings we are using to affect the decoding.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nout_settings: fixed size array of aws_http2_setting gets set to the local settings\n\nPrototype\n\nvoid aws_http2_connection_get_local_settings( const struct aws_http_connection *http2_connection, struct aws_http2_setting out_settings[AWS_HTTP2_SETTINGS_COUNT]);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_get_received_goaway-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_get_received_goaway","text":"aws_http2_connection_get_received_goaway(http2_connection, out_http2_error, out_last_stream_id)\n\nGet data about the latest GOAWAY frame received from peer (HTTP/2 only). If no GOAWAY has been received, or the GOAWAY payload is still in transmitting, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nout_http2_error: Gets set to HTTP/2 error code received in most recent GOAWAY.\nout_last_stream_id: Gets set to Last-Stream-ID received in most recent GOAWAY.\n\nPrototype\n\nint aws_http2_connection_get_received_goaway( struct aws_http_connection *http2_connection, uint32_t *out_http2_error, uint32_t *out_last_stream_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_get_remote_settings-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_get_remote_settings","text":"aws_http2_connection_get_remote_settings(http2_connection, out_settings)\n\nGet the settings received from remote peer, which we are using to restricts the message to send.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nout_settings: fixed size array of aws_http2_setting gets set to the remote settings\n\nPrototype\n\nvoid aws_http2_connection_get_remote_settings( const struct aws_http_connection *http2_connection, struct aws_http2_setting out_settings[AWS_HTTP2_SETTINGS_COUNT]);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_get_sent_goaway-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_get_sent_goaway","text":"aws_http2_connection_get_sent_goaway(http2_connection, out_http2_error, out_last_stream_id)\n\nGet data about the latest GOAWAY frame sent to peer (HTTP/2 only). If no GOAWAY has been sent, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE will be raised. Note that GOAWAY frames are typically sent automatically by the connection during shutdown.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nout_http2_error: Gets set to HTTP/2 error code sent in most recent GOAWAY.\nout_last_stream_id: Gets set to Last-Stream-ID sent in most recent GOAWAY.\n\nPrototype\n\nint aws_http2_connection_get_sent_goaway( struct aws_http_connection *http2_connection, uint32_t *out_http2_error, uint32_t *out_last_stream_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_ping-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_ping","text":"aws_http2_connection_ping(http2_connection, optional_opaque_data, on_completed, user_data)\n\nSend a PING frame (HTTP/2 only). Round-trip-time is calculated when PING ACK is received from peer.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\noptional_opaque_data: Optional payload for PING frame. Must be NULL, or exactly 8 bytes (AWS_HTTP2_PING_DATA_SIZE). If NULL, the 8 byte payload will be all zeroes.\non_completed: Optional callback, invoked when PING ACK is received from peer, or when a connection error prevents the PING ACK from being received. Callback always fires on the connection's event-loop thread.\nuser_data: User-data pass to on_completed callback.\n\nPrototype\n\nint aws_http2_connection_ping( struct aws_http_connection *http2_connection, const struct aws_byte_cursor *optional_opaque_data, aws_http2_on_ping_complete_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_send_goaway-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_send_goaway","text":"aws_http2_connection_send_goaway(http2_connection, http2_error, allow_more_streams, optional_debug_data)\n\nSend a custom GOAWAY frame (HTTP/2 only).\n\nNote that the connection automatically attempts to send a GOAWAY during shutdown (unless a GOAWAY with a valid Last-Stream-ID has already been sent).\n\nThis call can be used to gracefully warn the peer of an impending shutdown (http2_error=0, allow_more_streams=true), or to customize the final GOAWAY frame that is sent by this connection.\n\nThe other end may not receive the goaway, if the connection already closed.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nhttp2_error: The HTTP/2 error code (RFC-7540 section 7) to send. enum [awshttp2error_code](@ref) lists official codes.\nallow_more_streams: If true, new peer-initiated streams will continue to be acknowledged and the GOAWAY's Last-Stream-ID will be set to a max value. If false, new peer-initiated streams will be ignored and the GOAWAY's Last-Stream-ID will be set to the latest acknowledged stream.\noptional_debug_data: Optional debug data to send. Size must not exceed 16KB.\n\nPrototype\n\nvoid aws_http2_connection_send_goaway( struct aws_http_connection *http2_connection, uint32_t http2_error, bool allow_more_streams, const struct aws_byte_cursor *optional_debug_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_connection_update_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_connection_update_window","text":"aws_http2_connection_update_window(http2_connection, increment_size)\n\nIncrement the connection's flow-control window to keep data flowing (HTTP/2 only).\n\nIf the connection was created with conn_manual_window_management set true, the flow-control window of the connection will shrink as body data is received for all the streams created on it. (headers, padding, and other metadata do not affect the window). The initial connection flow-control window is 65,535. Once the connection's flow-control window reaches to 0, all the streams on the connection stop receiving any further data.\n\nIf conn_manual_window_management is false, this call will have no effect. The connection maintains its flow-control windows such that no back-pressure is applied and data arrives as fast as possible.\n\nIf you are not connected, this call will have no effect.\n\nCrashes when the connection is not http2 connection. The limit of the Maximum Size is 2**31 - 1. If the increment size cause the connection flow window exceeds the Maximum size, this call will result in the connection lost.\n\nParameters\n\nhttp2_connection: HTTP/2 connection.\nincrement_size: The size to increment for the connection's flow control window\n\nPrototype\n\nvoid aws_http2_connection_update_window(struct aws_http_connection *http2_connection, uint32_t increment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_get_request_authority-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_get_request_authority","text":"aws_http2_headers_get_request_authority(h2_headers, out_authority)\n\nPrototype\n\nint aws_http2_headers_get_request_authority( const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_authority);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_get_request_method-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_get_request_method","text":"aws_http2_headers_get_request_method(h2_headers, out_method)\n\nGet the :method value (HTTP/2 headers only).\n\nPrototype\n\nint aws_http2_headers_get_request_method(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_get_request_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_get_request_path","text":"aws_http2_headers_get_request_path(h2_headers, out_path)\n\nPrototype\n\nint aws_http2_headers_get_request_path(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_get_request_scheme-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_get_request_scheme","text":"aws_http2_headers_get_request_scheme(h2_headers, out_scheme)\n\nPrototype\n\nint aws_http2_headers_get_request_scheme(const struct aws_http_headers *h2_headers, struct aws_byte_cursor *out_scheme);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_get_response_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_get_response_status","text":"aws_http2_headers_get_response_status(h2_headers, out_status_code)\n\nGet :status (response pseudo headers only). If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised.\n\nPrototype\n\nint aws_http2_headers_get_response_status(const struct aws_http_headers *h2_headers, int *out_status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_set_request_authority-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_set_request_authority","text":"aws_http2_headers_set_request_authority(h2_headers, authority)\n\nSet :authority (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_authority(struct aws_http_headers *h2_headers, struct aws_byte_cursor authority);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_set_request_method-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_set_request_method","text":"aws_http2_headers_set_request_method(h2_headers, method)\n\nSet :method (HTTP/2 headers only). The headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_method(struct aws_http_headers *h2_headers, struct aws_byte_cursor method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_set_request_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_set_request_path","text":"aws_http2_headers_set_request_path(h2_headers, path)\n\nSet :path (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_path(struct aws_http_headers *h2_headers, struct aws_byte_cursor path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_set_request_scheme-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_set_request_scheme","text":"aws_http2_headers_set_request_scheme(h2_headers, scheme)\n\nSet :scheme (request pseudo headers only). The pseudo headers makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http2_headers_set_request_scheme(struct aws_http_headers *h2_headers, struct aws_byte_cursor scheme);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_headers_set_response_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_headers_set_response_status","text":"aws_http2_headers_set_response_status(h2_headers, status_code)\n\nSet :status (response pseudo headers only).\n\nPrototype\n\nint aws_http2_headers_set_response_status(struct aws_http_headers *h2_headers, int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_message_new_from_http1-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_message_new_from_http1","text":"aws_http2_message_new_from_http1(alloc, http1_msg)\n\nCreate an HTTP/2 message from HTTP/1.1 message. pseudo headers will be created from the context and added to the headers of new message. Normal headers will be copied to the headers of new message. Note: - if host exist, it will be removed and :authority will be added using the information. - :scheme always defaults to \"https\". To use a different scheme create the HTTP/2 message directly\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_from_http1( struct aws_allocator *alloc, const struct aws_http_message *http1_msg);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_message_new_request-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http2_message_new_request","text":"aws_http2_message_new_request(allocator)\n\nCreate a new HTTP/2 request message. pseudo headers need to be set from aws_http2_headers_set_request_* to the headers of the aws_http_message. Will be errored out if used in HTTP/1.1 connection.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_request(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_message_new_response-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http2_message_new_response","text":"aws_http2_message_new_response(allocator)\n\nCreate a new HTTP/2 response message. pseudo headers need to be set from aws_http2_headers_set_response_status to the headers of the aws_http_message. Will be errored out if used in HTTP/1.1 connection.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http2_message_new_response(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_get_received_reset_error_code-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_get_received_reset_error_code","text":"aws_http2_stream_get_received_reset_error_code(http2_stream, out_http2_error)\n\nGet the error code received in rst_stream. Only valid if the stream has completed, and an RST_STREAM frame has received.\n\nParameters\n\nhttp2_stream: HTTP/2 stream.\nout_http2_error: Gets to set to HTTP/2 error code received in rst_stream.\n\nPrototype\n\nint aws_http2_stream_get_received_reset_error_code(struct aws_http_stream *http2_stream, uint32_t *out_http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_get_sent_reset_error_code-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_get_sent_reset_error_code","text":"aws_http2_stream_get_sent_reset_error_code(http2_stream, out_http2_error)\n\nGet the HTTP/2 error code sent in the RST_STREAM frame (HTTP/2 only). Only valid if the stream has completed, and has sent an RST_STREAM frame.\n\nParameters\n\nhttp2_stream: HTTP/2 stream.\nout_http2_error: Gets to set to HTTP/2 error code sent in rst_stream.\n\nPrototype\n\nint aws_http2_stream_get_sent_reset_error_code(struct aws_http_stream *http2_stream, uint32_t *out_http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_manager_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_acquire","text":"aws_http2_stream_manager_acquire(manager)\n\nAcquire a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero. NULL is acceptable. Initial refcount after new is 1.\n\nParameters\n\nmanager:\n\nReturns\n\nThe same pointer acquiring.\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_acquire(struct aws_http2_stream_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_manager_acquire_stream-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_acquire_stream","text":"aws_http2_stream_manager_acquire_stream(http2_stream_manager, acquire_stream_option)\n\nAcquire a stream from stream manager asynchronously.\n\nParameters\n\nhttp2_stream_manager:\nacquire_stream_option: see aws_http2_stream_manager_acquire_stream_options\n\nPrototype\n\nvoid aws_http2_stream_manager_acquire_stream( struct aws_http2_stream_manager *http2_stream_manager, const struct aws_http2_stream_manager_acquire_stream_options *acquire_stream_option);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_manager_fetch_metrics-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_fetch_metrics","text":"aws_http2_stream_manager_fetch_metrics(http2_stream_manager, out_metrics)\n\nFetch the current metrics from stream manager.\n\nParameters\n\nhttp2_stream_manager:\nout_metrics: The metrics to be fetched\n\nPrototype\n\nvoid aws_http2_stream_manager_fetch_metrics( const struct aws_http2_stream_manager *http2_stream_manager, struct aws_http_manager_metrics *out_metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_manager_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_new","text":"aws_http2_stream_manager_new(allocator, options)\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_new( struct aws_allocator *allocator, const struct aws_http2_stream_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_manager_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_manager_release","text":"aws_http2_stream_manager_release(manager)\n\nRelease a refcount from the stream manager, stream manager will start to destroy after the refcount drops to zero. NULL is acceptable. Initial refcount after new is 1.\n\nParameters\n\nmanager:\n\nReturns\n\nNULL\n\nPrototype\n\nstruct aws_http2_stream_manager *aws_http2_stream_manager_release(struct aws_http2_stream_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_reset-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_reset","text":"aws_http2_stream_reset(http2_stream, http2_error)\n\nReset the HTTP/2 stream (HTTP/2 only). Note that if the stream closes before this async call is fully processed, the RST_STREAM frame will not be sent.\n\nParameters\n\nhttp2_stream: HTTP/2 stream.\nhttp2_error: aws_http2_error_code. Reason to reset the stream.\n\nPrototype\n\nint aws_http2_stream_reset(struct aws_http_stream *http2_stream, uint32_t http2_error);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http2_stream_write_data-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http2_stream_write_data","text":"aws_http2_stream_write_data(http2_stream, options)\n\nThe stream must have specified http2_use_manual_data_writes during request creation. For client streams, activate() must be called before any frames are submitted. For server streams, the response headers must be submitted before any frames. A write with options that has end_stream set to be true will end the stream and prevent any further write.\n\nTypical usage will be something like: options.http2_use_manual_data_writes = true; stream = aws_http_connection_make_request(connection, &options); aws_http_stream_activate(stream); ... struct aws_http2_stream_write_data_options write; aws_http2_stream_write_data(stream, &write); ... struct aws_http2_stream_write_data_options last_write; last_write.end_stream = true; aws_http2_stream_write_data(stream, &write); ... aws_http_stream_release(stream);\n\nReturns\n\nAWS_OP_SUCCESS if the write was queued AWS_OP_ERROR indicating the attempt raised an error code. AWS_ERROR_INVALID_STATE will be raised for invalid usage. AWS_ERROR_HTTP_STREAM_HAS_COMPLETED will be raised if the stream ended for reasons behind the scenes.\n\nPrototype\n\nint aws_http2_stream_write_data( struct aws_http_stream *http2_stream, const struct aws_http2_stream_write_data_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_alpn_map_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_alpn_map_init","text":"aws_http_alpn_map_init(allocator, map)\n\nInitialize an empty hash-table that maps struct [awsstring](@ref) * to enum [awshttpversion](@ref). This map can used in aws\\http_client_connections_options.alpn_string_map.\n\nPrototype\n\nint aws_http_alpn_map_init(struct aws_allocator *allocator, struct aws_hash_table *map);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_alpn_map_init_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_alpn_map_init_copy","text":"aws_http_alpn_map_init_copy(allocator, dest, src)\n\nInitialize an map copied from the *src map, which maps struct [awsstring](@ref) * to enum [awshttp_version](@ref).\n\nPrototype\n\nint aws_http_alpn_map_init_copy( struct aws_allocator *allocator, struct aws_hash_table *dest, struct aws_hash_table *src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_client_connect-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_client_connect","text":"aws_http_client_connect(options)\n\nAsynchronously establish a client connection. The on_setup callback is invoked when the operation has created a connection or failed.\n\nPrototype\n\nint aws_http_client_connect(const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_close-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_close","text":"aws_http_connection_close(connection)\n\nBegin shutdown sequence of the connection if it hasn't already started. This will schedule shutdown tasks on the EventLoop that may send HTTP/TLS/TCP shutdown messages to peers if necessary, and will eventually cause internal connection memory to stop being accessed and on_shutdown() callback to be called.\n\nIt's safe to call this function regardless of the connection state as long as you hold a reference to the connection.\n\nPrototype\n\nvoid aws_http_connection_close(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_configure_server-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_configure_server","text":"aws_http_connection_configure_server(connection, options)\n\nConfigure a server connection. This must be called from the server's on_incoming_connection callback.\n\nPrototype\n\nint aws_http_connection_configure_server( struct aws_http_connection *connection, const struct aws_http_server_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_get_channel-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_get_channel","text":"aws_http_connection_get_channel(connection)\n\nReturns the channel hosting the HTTP connection. Do not expose this function to language bindings.\n\nPrototype\n\nstruct aws_channel *aws_http_connection_get_channel(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_get_remote_endpoint-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_get_remote_endpoint","text":"aws_http_connection_get_remote_endpoint(connection)\n\nReturns the remote endpoint of the HTTP connection.\n\nPrototype\n\nconst struct aws_socket_endpoint *aws_http_connection_get_remote_endpoint(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_get_version-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_get_version","text":"aws_http_connection_get_version(connection)\n\nPrototype\n\nenum aws_http_version aws_http_connection_get_version(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_is_client-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_is_client","text":"aws_http_connection_is_client(connection)\n\nReturns true if this is a client connection.\n\nPrototype\n\nbool aws_http_connection_is_client(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_is_open-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_is_open","text":"aws_http_connection_is_open(connection)\n\nReturns true unless the connection is closed or closing.\n\nPrototype\n\nbool aws_http_connection_is_open(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_is_server-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_is_server","text":"aws_http_connection_is_server(connection)\n\nReturns true if this is a server connection.\n\nPrototype\n\nbool aws_http_connection_is_server(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_make_request-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_make_request","text":"aws_http_connection_make_request(client_connection, options)\n\nCreate a stream, with a client connection sending a request. The request does not start sending automatically once the stream is created. You must call aws_http_stream_activate to begin execution of the request.\n\nThe options are copied during this call.\n\nTip for language bindings: Do not bind the options struct. Use something more natural for your language, such as Builder Pattern in Java, or Python's ability to take many optional arguments by name.\n\nNote: The header of the request will be sent as it is when the message to send protocol matches the protocol of the connection. - No user-agent will be added. - No security check will be enforced. eg: referer header privacy should be enforced by the user-agent who adds the header - When HTTP/1 message sent on HTTP/2 connection, aws_http2_message_new_from_http1 will be applied under the hood. - When HTTP/2 message sent on HTTP/1 connection, no change will be made.\n\nPrototype\n\nstruct aws_http_stream *aws_http_connection_make_request( struct aws_http_connection *client_connection, const struct aws_http_make_request_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_acquire","text":"aws_http_connection_manager_acquire(manager)\n\nPrototype\n\nvoid aws_http_connection_manager_acquire(struct aws_http_connection_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_acquire_connection-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_acquire_connection","text":"aws_http_connection_manager_acquire_connection(manager, callback, user_data)\n\nPrototype\n\nvoid aws_http_connection_manager_acquire_connection( struct aws_http_connection_manager *manager, aws_http_connection_manager_on_connection_setup_fn *callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_fetch_metrics-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_fetch_metrics","text":"aws_http_connection_manager_fetch_metrics(manager, out_metrics)\n\nFetch the current manager metrics from connection manager.\n\nPrototype\n\nvoid aws_http_connection_manager_fetch_metrics( const struct aws_http_connection_manager *manager, struct aws_http_manager_metrics *out_metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_new","text":"aws_http_connection_manager_new(allocator, options)\n\nPrototype\n\nstruct aws_http_connection_manager *aws_http_connection_manager_new( struct aws_allocator *allocator, const struct aws_http_connection_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_release","text":"aws_http_connection_manager_release(manager)\n\nPrototype\n\nvoid aws_http_connection_manager_release(struct aws_http_connection_manager *manager);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_manager_release_connection-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_manager_release_connection","text":"aws_http_connection_manager_release_connection(manager, connection)\n\nPrototype\n\nint aws_http_connection_manager_release_connection( struct aws_http_connection_manager *manager, struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_new_requests_allowed-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_new_requests_allowed","text":"aws_http_connection_new_requests_allowed(connection)\n\nReturn whether the connection can make a new requests. If false, then a new connection must be established to make further requests.\n\nPrototype\n\nbool aws_http_connection_new_requests_allowed(const struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_release","text":"aws_http_connection_release(connection)\n\nUsers must release the connection when they are done with it. The connection's memory cannot be reclaimed until this is done. If the connection was not already shutting down, it will be shut down.\n\nUsers should always wait for the on_shutdown() callback to be called before releasing any data passed to the http_connection (Eg aws_tls_connection_options, aws_socket_options) otherwise there will be race conditions between http_connection shutdown tasks and memory release tasks, causing Segfaults.\n\nPrototype\n\nvoid aws_http_connection_release(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_connection_stop_new_requests-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_connection_stop_new_requests","text":"aws_http_connection_stop_new_requests(connection)\n\nStop accepting new requests for the connection. It will NOT start the shutdown process for the connection. The requests that are already open can still wait to be completed, but new requests will fail to be created,\n\nPrototype\n\nvoid aws_http_connection_stop_new_requests(struct aws_http_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_header_name_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_header_name_eq","text":"aws_http_header_name_eq(name_a, name_b)\n\nReturn whether both names are equivalent. This is a case-insensitive string comparison.\n\nExample Matches: \"Content-Length\" == \"content-length\" // upper or lower case ok\n\nExample Mismatches: \"Content-Length\" != \" Content-Length\" // leading whitespace bad\n\nPrototype\n\nbool aws_http_header_name_eq(struct aws_byte_cursor name_a, struct aws_byte_cursor name_b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_acquire","text":"aws_http_headers_acquire(headers)\n\nAcquire a hold on the object, preventing it from being deleted until aws_http_headers_release() is called by all those with a hold on it.\n\nPrototype\n\nvoid aws_http_headers_acquire(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_add-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_add","text":"aws_http_headers_add(headers, name, value)\n\nAdd a header. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add(struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_add_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_add_array","text":"aws_http_headers_add_array(headers, array, count)\n\nAdd an array of headers. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add_array(struct aws_http_headers *headers, const struct aws_http_header *array, size_t count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_add_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_add_header","text":"aws_http_headers_add_header(headers, header)\n\nAdd a header. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_add_header(struct aws_http_headers *headers, const struct aws_http_header *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_clear","text":"aws_http_headers_clear(headers)\n\nClear all headers.\n\nPrototype\n\nvoid aws_http_headers_clear(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_count","text":"aws_http_headers_count(headers)\n\nGet the total number of headers.\n\nPrototype\n\nsize_t aws_http_headers_count(const struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_erase-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_erase","text":"aws_http_headers_erase(headers, name)\n\nRemove all headers with this name. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no headers with this name are found.\n\nPrototype\n\nint aws_http_headers_erase(struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_erase_index-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_erase_index","text":"aws_http_headers_erase_index(headers, index)\n\nRemove the header at the specified index.\n\nAWS_ERROR_INVALID_INDEX is raised if the index is invalid.\n\nPrototype\n\nint aws_http_headers_erase_index(struct aws_http_headers *headers, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_erase_value-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_erase_value","text":"aws_http_headers_erase_value(headers, name, value)\n\nRemove the first header found with this name and value. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if no such header is found.\n\nPrototype\n\nint aws_http_headers_erase_value( struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_get-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_get","text":"aws_http_headers_get(headers, name, out_value)\n\nGet the first value for this name, ignoring any additional values. AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised if the name is not found.\n\nPrototype\n\nint aws_http_headers_get( const struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor *out_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_get_all-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_get_all","text":"aws_http_headers_get_all(headers, name)\n\nGet all values with this name, combined into one new aws_string that you are responsible for destroying. If there are multiple headers with this name, their values are appended with comma-separators. If there are no headers with this name, NULL is returned and AWS_ERROR_HTTP_HEADER_NOT_FOUND is raised.\n\nPrototype\n\nstruct aws_string *aws_http_headers_get_all(const struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_get_index-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_get_index","text":"aws_http_headers_get_index(headers, index, out_header)\n\nGet the header at the specified index. The index of a given header may change any time headers are modified. When iterating headers, the following ordering rules apply:\n\nHeaders with the same name will always be in the same order, relative to one another. If \"A: one\" is added before \"A: two\", then \"A: one\" will always precede \"A: two\".\nHeaders with different names could be in any order, relative to one another. If \"A: one\" is seen before \"B: bee\" in one iteration, you might see \"B: bee\" before \"A: one\" on the next.\n\nAWS_ERROR_INVALID_INDEX is raised if the index is invalid.\n\nPrototype\n\nint aws_http_headers_get_index( const struct aws_http_headers *headers, size_t index, struct aws_http_header *out_header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_has-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_has","text":"aws_http_headers_has(headers, name)\n\nTest if header name exists or not in headers\n\nPrototype\n\nbool aws_http_headers_has(const struct aws_http_headers *headers, struct aws_byte_cursor name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_new","text":"aws_http_headers_new(allocator)\n\nCreate a new headers object. The caller has a hold on the object and must call aws_http_headers_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_headers *aws_http_headers_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_release","text":"aws_http_headers_release(headers)\n\nRelease a hold on the object. The object is deleted when all holds on it are released.\n\nPrototype\n\nvoid aws_http_headers_release(struct aws_http_headers *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_headers_set-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_headers_set","text":"aws_http_headers_set(headers, name, value)\n\nSet a header value. The header is added if necessary and any existing values for this name are removed. The underlying strings are copied.\n\nPrototype\n\nint aws_http_headers_set(struct aws_http_headers *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_http_library_clean_up","text":"aws_http_library_clean_up()\n\nClean up internal datastructures used by aws-c-http. Must not be called until application is done using functionality in aws-c-http.\n\nPrototype\n\nvoid aws_http_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_library_init","text":"aws_http_library_init(alloc)\n\nInitializes internal datastructures used by aws-c-http. Must be called before using any functionality in aws-c-http.\n\nPrototype\n\nvoid aws_http_library_init(struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_acquire","text":"aws_http_message_acquire(message)\n\nAcquire a hold on the object, preventing it from being deleted until aws_http_message_release() is called by all those with a hold on it.\n\nThis function returns the passed in message (possibly NULL) so that acquire-and-assign can be done with a single statement.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_acquire(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_add_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_add_header","text":"aws_http_message_add_header(message, header)\n\nAdd a header to the end of the array. The message makes its own copy of the underlying strings.\n\nPrototype\n\nint aws_http_message_add_header(struct aws_http_message *message, struct aws_http_header header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_add_header_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_add_header_array","text":"aws_http_message_add_header_array(message, headers, num_headers)\n\nAdd an array of headers to the end of the header array. The message makes its own copy of the underlying strings.\n\nThis is a helper function useful when it's easier to define headers as a stack array, rather than calling add_header repeatedly.\n\nPrototype\n\nint aws_http_message_add_header_array( struct aws_http_message *message, const struct aws_http_header *headers, size_t num_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_destroy","text":"aws_http_message_destroy(message)\n\nDeprecated. This is equivalent to aws_http_message_release().\n\nPrototype\n\nvoid aws_http_message_destroy(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_erase_header-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_erase_header","text":"aws_http_message_erase_header(message, index)\n\nRemove the header at the specified index. Headers after this index are all shifted back one position.\n\nThis function cannot fail if a valid index is provided. Otherwise, AWS_ERROR_INVALID_INDEX will be raised.\n\nPrototype\n\nint aws_http_message_erase_header(struct aws_http_message *message, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_body_stream-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_body_stream","text":"aws_http_message_get_body_stream(message)\n\nGet the body stream. Returns NULL if no body stream is set.\n\nPrototype\n\nstruct aws_input_stream *aws_http_message_get_body_stream(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_const_headers-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_const_headers","text":"aws_http_message_get_const_headers(message)\n\nGet the message's const aws_http_headers.\n\nPrototype\n\nconst struct aws_http_headers *aws_http_message_get_const_headers(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_header-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_header","text":"aws_http_message_get_header(message, out_header, index)\n\nGet the header at the specified index. This function cannot fail if a valid index is provided. Otherwise, AWS_ERROR_INVALID_INDEX will be raised.\n\nThe underlying strings are stored within the message.\n\nPrototype\n\nint aws_http_message_get_header( const struct aws_http_message *message, struct aws_http_header *out_header, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_header_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_header_count","text":"aws_http_message_get_header_count(message)\n\nGet the number of headers.\n\nPrototype\n\nsize_t aws_http_message_get_header_count(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_headers-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_headers","text":"aws_http_message_get_headers(message)\n\nThis datastructure has more functions for inspecting and modifying headers than are available on the aws_http_message datastructure.\n\nPrototype\n\nstruct aws_http_headers *aws_http_message_get_headers(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_protocol_version-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_protocol_version","text":"aws_http_message_get_protocol_version(message)\n\nGet the protocol version of the http message.\n\nPrototype\n\nenum aws_http_version aws_http_message_get_protocol_version(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_request_method-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_request_method","text":"aws_http_message_get_request_method(request_message, out_method)\n\nGet the method (request messages only).\n\nPrototype\n\nint aws_http_message_get_request_method( const struct aws_http_message *request_message, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_request_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_request_path","text":"aws_http_message_get_request_path(request_message, out_path)\n\nPrototype\n\nint aws_http_message_get_request_path(const struct aws_http_message *request_message, struct aws_byte_cursor *out_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_get_response_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_get_response_status","text":"aws_http_message_get_response_status(response_message, out_status_code)\n\nGet the status code (response messages only). If no status is set, AWS_ERROR_HTTP_DATA_NOT_AVAILABLE is raised.\n\nPrototype\n\nint aws_http_message_get_response_status(const struct aws_http_message *response_message, int *out_status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_is_request-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_is_request","text":"aws_http_message_is_request(message)\n\nPrototype\n\nbool aws_http_message_is_request(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_is_response-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_is_response","text":"aws_http_message_is_response(message)\n\nPrototype\n\nbool aws_http_message_is_response(const struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_new_request-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_new_request","text":"aws_http_message_new_request(allocator)\n\nCreate a new HTTP/1.1 request message. The message is blank, all properties (method, path, etc) must be set individually. If HTTP/1.1 message used in HTTP/2 connection, the transformation will be automatically applied. A HTTP/2 message will created and sent based on the HTTP/1.1 message.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_request(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_new_request_with_headers-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_new_request_with_headers","text":"aws_http_message_new_request_with_headers(allocator, existing_headers)\n\nLike aws_http_message_new_request(), but uses existing aws_http_headers instead of creating a new one. Acquires a hold on the headers, and releases it when the request is destroyed.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_request_with_headers( struct aws_allocator *allocator, struct aws_http_headers *existing_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_new_response-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_new_response","text":"aws_http_message_new_response(allocator)\n\nCreate a new HTTP/1.1 response message. The message is blank, all properties (status, headers, etc) must be set individually.\n\nThe caller has a hold on the object and must call aws_http_message_release() when they are done with it.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_response(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_new_websocket_handshake_request-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_new_websocket_handshake_request","text":"aws_http_message_new_websocket_handshake_request(allocator, path, host)\n\nCreate request with all required fields for a websocket upgrade request. The method and path are set, and the the following headers are added:\n\nHost: <host> Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: <base64 encoding of 16 random bytes> Sec-WebSocket-Version: 13\n\nPrototype\n\nstruct aws_http_message *aws_http_message_new_websocket_handshake_request( struct aws_allocator *allocator, struct aws_byte_cursor path, struct aws_byte_cursor host);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_message_release","text":"aws_http_message_release(message)\n\nRelease a hold on the object. The object is deleted when all holds on it are released.\n\nThis function always returns NULL so that release-and-assign-NULL can be done with a single statement.\n\nPrototype\n\nstruct aws_http_message *aws_http_message_release(struct aws_http_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_set_body_stream-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_set_body_stream","text":"aws_http_message_set_body_stream(message, body_stream)\n\nSet the body stream. NULL is an acceptable value for messages with no body. Note: The message does NOT take ownership of the body stream. The stream must not be destroyed until the message is complete.\n\nPrototype\n\nvoid aws_http_message_set_body_stream(struct aws_http_message *message, struct aws_input_stream *body_stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_set_request_method-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_set_request_method","text":"aws_http_message_set_request_method(request_message, method)\n\nSet the method (request messages only). The request makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http_message_set_request_method(struct aws_http_message *request_message, struct aws_byte_cursor method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_set_request_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_set_request_path","text":"aws_http_message_set_request_path(request_message, path)\n\nSet the path-and-query value (request messages only). The request makes its own copy of the underlying string.\n\nPrototype\n\nint aws_http_message_set_request_path(struct aws_http_message *request_message, struct aws_byte_cursor path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_message_set_response_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_message_set_response_status","text":"aws_http_message_set_response_status(response_message, status_code)\n\nSet the status code (response messages only).\n\nPrototype\n\nint aws_http_message_set_response_status(struct aws_http_message *response_message, int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_options_validate_proxy_configuration-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_options_validate_proxy_configuration","text":"aws_http_options_validate_proxy_configuration(options)\n\nChecks http proxy options for correctness\n\nPrototype\n\nint aws_http_options_validate_proxy_configuration(const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_destroy","text":"aws_http_proxy_config_destroy(config)\n\nDestroys an http proxy configuration\n\nParameters\n\nconfig: http proxy configuration to destroy\n\nPrototype\n\nvoid aws_http_proxy_config_destroy(struct aws_http_proxy_config *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_clone-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_clone","text":"aws_http_proxy_config_new_clone(allocator, proxy_config)\n\nClones an existing proxy configuration. A refactor could remove this (do a \"move\" between the old and new user data in the one spot it's used) but that should wait until we have better test cases for the logic where this gets invoked (ntlm/kerberos chains).\n\nParameters\n\nallocator: memory allocator to use\nproxy_config: http proxy configuration to clone\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_clone( struct aws_allocator *allocator, const struct aws_http_proxy_config *proxy_config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_from_connection_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_from_connection_options","text":"aws_http_proxy_config_new_from_connection_options(allocator, options)\n\nCreate a persistent proxy configuration from http connection options\n\nParameters\n\nallocator: memory allocator to use\noptions: http connection options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_connection_options( struct aws_allocator *allocator, const struct aws_http_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_from_manager_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_from_manager_options","text":"aws_http_proxy_config_new_from_manager_options(allocator, options)\n\nCreate a persistent proxy configuration from http connection manager options\n\nParameters\n\nallocator: memory allocator to use\noptions: http connection manager options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_manager_options( struct aws_allocator *allocator, const struct aws_http_connection_manager_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_from_proxy_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_from_proxy_options","text":"aws_http_proxy_config_new_from_proxy_options(allocator, options)\n\nCreate a persistent proxy configuration from non-persistent proxy options. Legacy connection type of proxy options will be rejected.\n\nParameters\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_proxy_options( struct aws_allocator *allocator, const struct aws_http_proxy_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_from_proxy_options_with_tls_info-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_from_proxy_options_with_tls_info","text":"aws_http_proxy_config_new_from_proxy_options_with_tls_info(allocator, proxy_options, is_tls_connection)\n\nCreate a persistent proxy configuration from non-persistent proxy options.\n\nParameters\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\nis_tls_connection: tls connection info of the main connection to determine connection_type when the connection_type is legacy.\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_from_proxy_options_with_tls_info( struct aws_allocator *allocator, const struct aws_http_proxy_options *proxy_options, bool is_tls_connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_config_new_tunneling_from_proxy_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_config_new_tunneling_from_proxy_options","text":"aws_http_proxy_config_new_tunneling_from_proxy_options(allocator, options)\n\nCreate a persistent proxy configuration from non-persistent proxy options. The resulting proxy configuration assumes a tunneling connection type.\n\nParameters\n\nallocator: memory allocator to use\noptions: http proxy options to source proxy configuration from\n\nReturns\n\nPrototype\n\nstruct aws_http_proxy_config *aws_http_proxy_config_new_tunneling_from_proxy_options( struct aws_allocator *allocator, const struct aws_http_proxy_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_acquire","text":"aws_http_proxy_negotiator_acquire(proxy_negotiator)\n\nTake a reference to an http proxy negotiator\n\nParameters\n\nproxy_negotiator: negotiator to take a reference to\n\nReturns\n\nthe strategy\n\nPrototype\n\nstruct aws_http_proxy_negotiator *aws_http_proxy_negotiator_acquire(struct aws_http_proxy_negotiator *proxy_negotiator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_negotiator_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_negotiator_release","text":"aws_http_proxy_negotiator_release(proxy_negotiator)\n\nRelease a reference to an http proxy negotiator\n\nParameters\n\nproxy_negotiator: negotiator to release a reference to\n\nPrototype\n\nvoid aws_http_proxy_negotiator_release(struct aws_http_proxy_negotiator *proxy_negotiator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_new_socket_channel-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_new_socket_channel","text":"aws_http_proxy_new_socket_channel(channel_options, proxy_options)\n\nEstablish an arbitrary protocol connection through an http proxy via tunneling CONNECT. Alpn is not required for this connection process to succeed, but we encourage its use if available.\n\nParameters\n\nchannel_options: configuration options for the socket level connection\nproxy_options: configuration options for the proxy connection\n\nReturns\n\nAWS_OP_SUCCESS if the asynchronous channel kickoff succeeded, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_http_proxy_new_socket_channel( struct aws_socket_channel_bootstrap_options *channel_options, const struct aws_http_proxy_options *proxy_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_options_init_from_config-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_options_init_from_config","text":"aws_http_proxy_options_init_from_config(options, config)\n\nInitializes non-persistent http proxy options from a persistent http proxy configuration\n\nParameters\n\noptions: http proxy options to initialize\nconfig: the http proxy config to use as an initialization source\n\nPrototype\n\nvoid aws_http_proxy_options_init_from_config( struct aws_http_proxy_options *options, const struct aws_http_proxy_config *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_acquire","text":"aws_http_proxy_strategy_acquire(proxy_strategy)\n\nTake a reference to an http proxy strategy\n\nParameters\n\nproxy_strategy: strategy to take a reference to\n\nReturns\n\nthe strategy\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_acquire(struct aws_http_proxy_strategy *proxy_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_create_negotiator-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_create_negotiator","text":"aws_http_proxy_strategy_create_negotiator(strategy, allocator)\n\nCreates a new proxy negotiator from a proxy strategy\n\nParameters\n\nallocator: memory allocator to use\nstrategy: strategy to creation a new negotiator for\n\nReturns\n\na new proxy negotiator if successful, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_negotiator *aws_http_proxy_strategy_create_negotiator( struct aws_http_proxy_strategy *strategy, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_new_basic_auth-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_new_basic_auth","text":"aws_http_proxy_strategy_new_basic_auth(allocator, config)\n\nA constructor for a proxy strategy that performs basic authentication by adding the appropriate header and header value to requests or CONNECT requests.\n\nParameters\n\nallocator: memory allocator to use\nconfig: basic authentication configuration info\n\nReturns\n\na new proxy strategy if successfully constructed, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_new_basic_auth( struct aws_allocator *allocator, struct aws_http_proxy_strategy_basic_auth_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_new_tunneling_adaptive-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_new_tunneling_adaptive","text":"aws_http_proxy_strategy_new_tunneling_adaptive(allocator, config)\n\nConstructor for an adaptive tunneling proxy strategy. This strategy attempts a vanilla CONNECT and if that fails it may make followup CONNECT attempts using kerberos or ntlm tokens, based on configuration and proxy response properties.\n\nParameters\n\nallocator: memory allocator to use\nconfig: configuration options for the strategy\n\nReturns\n\na new proxy strategy if successfully constructed, otherwise NULL\n\nPrototype\n\nstruct aws_http_proxy_strategy *aws_http_proxy_strategy_new_tunneling_adaptive( struct aws_allocator *allocator, struct aws_http_proxy_strategy_tunneling_adaptive_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_proxy_strategy_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_proxy_strategy_release","text":"aws_http_proxy_strategy_release(proxy_strategy)\n\nRelease a reference to an http proxy strategy\n\nParameters\n\nproxy_strategy: strategy to release a reference to\n\nPrototype\n\nvoid aws_http_proxy_strategy_release(struct aws_http_proxy_strategy *proxy_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_server_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_server_new","text":"aws_http_server_new(options)\n\nCreate server, a listening socket that accepts incoming connections.\n\nPrototype\n\nstruct aws_http_server *aws_http_server_new(const struct aws_http_server_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_server_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_server_release","text":"aws_http_server_release(server)\n\nRelease the server. It will close the listening socket and all the connections existing in the server. The on_destroy_complete will be invoked when the destroy operation completes\n\nPrototype\n\nvoid aws_http_server_release(struct aws_http_server *server);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_status_text-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_status_text","text":"aws_http_status_text(status_code)\n\nReturns the description of common status codes. Ex: 404 -> \"Not Found\" An empty string is returned if the status code is not recognized.\n\nPrototype\n\nconst char *aws_http_status_text(int status_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_acquire","text":"aws_http_stream_acquire(stream)\n\nAcquire refcount on the stream to prevent it from being cleaned up until it is released.\n\nPrototype\n\nstruct aws_http_stream *aws_http_stream_acquire(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_activate-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_activate","text":"aws_http_stream_activate(stream)\n\nOnly used for client initiated streams (immediately following a call to aws_http_connection_make_request).\n\nActivates the request's outgoing stream processing.\n\nPrototype\n\nint aws_http_stream_activate(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_get_connection-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_get_connection","text":"aws_http_stream_get_connection(stream)\n\nPrototype\n\nstruct aws_http_connection *aws_http_stream_get_connection(const struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_get_id-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_get_id","text":"aws_http_stream_get_id(stream)\n\nGets the HTTP/2 id associated with a stream. Even h1 streams have an id (using the same allocation procedure as http/2) for easier tracking purposes. For client streams, this will only be non-zero after a successful call to aws_http_stream_activate()\n\nPrototype\n\nuint32_t aws_http_stream_get_id(const struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_get_incoming_request_method-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_get_incoming_request_method","text":"aws_http_stream_get_incoming_request_method(stream, out_method)\n\nPrototype\n\nint aws_http_stream_get_incoming_request_method( const struct aws_http_stream *stream, struct aws_byte_cursor *out_method);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_get_incoming_request_uri-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_get_incoming_request_uri","text":"aws_http_stream_get_incoming_request_uri(stream, out_uri)\n\nPrototype\n\nint aws_http_stream_get_incoming_request_uri(const struct aws_http_stream *stream, struct aws_byte_cursor *out_uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_get_incoming_response_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_get_incoming_response_status","text":"aws_http_stream_get_incoming_response_status(stream, out_status)\n\nPrototype\n\nint aws_http_stream_get_incoming_response_status(const struct aws_http_stream *stream, int *out_status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_new_server_request_handler-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_new_server_request_handler","text":"aws_http_stream_new_server_request_handler(options)\n\nCreate a stream, with a server connection receiving and responding to a request. This function can only be called from the aws_http_on_incoming_request_fn callback. aws_http_stream_send_response() should be used to send a response.\n\nPrototype\n\nstruct aws_http_stream *aws_http_stream_new_server_request_handler( const struct aws_http_request_handler_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_release","text":"aws_http_stream_release(stream)\n\nUsers must release the stream when they are done with it, or its memory will never be cleaned up. This will not cancel the stream, its callbacks will still fire if the stream is still in progress.\n\nTips for language bindings: - Invoke this from the wrapper class's finalizer/destructor. - Do not let the wrapper class be destroyed until on_complete() has fired.\n\nPrototype\n\nvoid aws_http_stream_release(struct aws_http_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_send_response-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_send_response","text":"aws_http_stream_send_response(stream, response)\n\nSend response (only callable from \"request handler\" streams) The response object must stay alive at least until the stream's on_complete is called.\n\nPrototype\n\nint aws_http_stream_send_response(struct aws_http_stream *stream, struct aws_http_message *response);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_http_stream_update_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_http_stream_update_window","text":"aws_http_stream_update_window(stream, increment_size)\n\nIncrement the stream's flow-control window to keep data flowing.\n\nIf the connection was created with manual_window_management set true, the flow-control window of each stream will shrink as body data is received (headers, padding, and other metadata do not affect the window). The connection's initial_window_size determines the starting size of each stream's window. If a stream's flow-control window reaches 0, no further data will be received.\n\nIf manual_window_management is false, this call will have no effect. The connection maintains its flow-control windows such that no back-pressure is applied and data arrives as fast as possible.\n\nPrototype\n\nvoid aws_http_stream_update_window(struct aws_http_stream *stream, size_t increment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_decode-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_decode","text":"aws_huffman_decode(decoder, to_decode, output)\n\nDecodes a byte buffer into the provided symbol array.\n\nParameters\n\ndecoder:[in] The decoder object to use\nto_decode:[in] The encoded byte buffer to read from\noutput:[in] The buffer to write decoded symbols to. If decoder is set to allow growth, capacity will be increased when necessary.\n\nReturns\n\nAWS_OP_SUCCESS if encoding is successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_huffman_decode( struct aws_huffman_decoder *decoder, struct aws_byte_cursor *to_decode, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_decoder_allow_growth-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_decoder_allow_growth","text":"aws_huffman_decoder_allow_growth(decoder, allow_growth)\n\nSet whether or not to increase capacity when the output buffer fills up while decoding. This is false by default.\n\nPrototype\n\nvoid aws_huffman_decoder_allow_growth(struct aws_huffman_decoder *decoder, bool allow_growth);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_decoder_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_decoder_init","text":"aws_huffman_decoder_init(decoder, coder)\n\nInitialize a decoder object with a symbol coder.\n\nPrototype\n\nvoid aws_huffman_decoder_init(struct aws_huffman_decoder *decoder, struct aws_huffman_symbol_coder *coder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_decoder_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_huffman_decoder_reset","text":"aws_huffman_decoder_reset(decoder)\n\nResets a decoder for use with a new binary stream\n\nPrototype\n\nvoid aws_huffman_decoder_reset(struct aws_huffman_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_encode-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_encode","text":"aws_huffman_encode(encoder, to_encode, output)\n\nEncode a symbol buffer into the output buffer.\n\nParameters\n\nencoder:[in] The encoder object to use\nto_encode:[in] The symbol buffer to encode\noutput:[in] The buffer to write encoded bytes to\n\nReturns\n\nAWS_OP_SUCCESS if encoding is successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_huffman_encode( struct aws_huffman_encoder *encoder, struct aws_byte_cursor *to_encode, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_encoder_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_encoder_init","text":"aws_huffman_encoder_init(encoder, coder)\n\nInitialize a encoder object with a symbol coder.\n\nPrototype\n\nvoid aws_huffman_encoder_init(struct aws_huffman_encoder *encoder, struct aws_huffman_symbol_coder *coder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_encoder_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_huffman_encoder_reset","text":"aws_huffman_encoder_reset(encoder)\n\nResets a decoder for use with a new binary stream\n\nPrototype\n\nvoid aws_huffman_encoder_reset(struct aws_huffman_encoder *encoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_huffman_get_encoded_length-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_huffman_get_encoded_length","text":"aws_huffman_get_encoded_length(encoder, to_encode)\n\nGet the byte length of to_encode post-encoding.\n\nParameters\n\nencoder:[in] The encoder object to use\nto_encode:[in] The symbol buffer to encode\n\nReturns\n\nThe length of the encoded string.\n\nPrototype\n\nsize_t aws_huffman_get_encoded_length(struct aws_huffman_encoder *encoder, struct aws_byte_cursor to_encode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_acquire","text":"aws_imds_client_acquire(client)\n\nIncrements the ref count on the client\n\nParameters\n\nclient: imds client to acquire a reference to\n\nPrototype\n\nvoid aws_imds_client_acquire(struct aws_imds_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_ami_id-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_ami_id","text":"aws_imds_client_get_ami_id(client, callback, user_data)\n\nGets the ami id of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_ami_id( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_ami_launch_index-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_ami_launch_index","text":"aws_imds_client_get_ami_launch_index(client, callback, user_data)\n\nGets the ami launch index of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_ami_launch_index( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_ami_manifest_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_ami_manifest_path","text":"aws_imds_client_get_ami_manifest_path(client, callback, user_data)\n\nGets the ami manifest path of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_ami_manifest_path( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_ancestor_ami_ids-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_ancestor_ami_ids","text":"aws_imds_client_get_ancestor_ami_ids(client, callback, user_data)\n\nGets the list of ancestor ami ids of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_ancestor_ami_ids( struct aws_imds_client *client, aws_imds_client_on_get_array_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_attached_iam_role-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_attached_iam_role","text":"aws_imds_client_get_attached_iam_role(client, callback, user_data)\n\nGets the attached iam role of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_attached_iam_role( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_availability_zone-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_availability_zone","text":"aws_imds_client_get_availability_zone(client, callback, user_data)\n\nGets the availability zone of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_availability_zone( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_block_device_mapping-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_block_device_mapping","text":"aws_imds_client_get_block_device_mapping(client, callback, user_data)\n\nGets the list of block device mappings of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_block_device_mapping( struct aws_imds_client *client, aws_imds_client_on_get_array_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_credentials-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_credentials","text":"aws_imds_client_get_credentials(client, iam_role_name, callback, user_data)\n\nGets temporary credentials based on the attached iam role of the ec2 instance\n\nParameters\n\nclient: imds client to use for the query\niam_role_name: iam role name to get temporary credentials through\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_credentials( struct aws_imds_client *client, struct aws_byte_cursor iam_role_name, aws_imds_client_on_get_credentials_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_iam_profile-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_iam_profile","text":"aws_imds_client_get_iam_profile(client, callback, user_data)\n\nGets the iam profile information of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_iam_profile( struct aws_imds_client *client, aws_imds_client_on_get_iam_profile_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_instance_action-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_instance_action","text":"aws_imds_client_get_instance_action(client, callback, user_data)\n\nGets the instance-action of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_instance_action( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_instance_id-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_instance_id","text":"aws_imds_client_get_instance_id(client, callback, user_data)\n\nGets the instance id of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_instance_id( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_instance_info-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_instance_info","text":"aws_imds_client_get_instance_info(client, callback, user_data)\n\nGets the instance information data block of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_instance_info( struct aws_imds_client *client, aws_imds_client_on_get_instance_info_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_instance_signature-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_instance_signature","text":"aws_imds_client_get_instance_signature(client, callback, user_data)\n\nGets the signature of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_instance_signature( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_instance_type-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_instance_type","text":"aws_imds_client_get_instance_type(client, callback, user_data)\n\nGets the instance type of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_instance_type( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_mac_address-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_mac_address","text":"aws_imds_client_get_mac_address(client, callback, user_data)\n\nGets the mac address of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_mac_address( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_private_ip_address-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_private_ip_address","text":"aws_imds_client_get_private_ip_address(client, callback, user_data)\n\nGets the private ip address of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_private_ip_address( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_product_codes-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_product_codes","text":"aws_imds_client_get_product_codes(client, callback, user_data)\n\nGets the product codes of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_product_codes( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_public_key-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_public_key","text":"aws_imds_client_get_public_key(client, callback, user_data)\n\nGets the public key of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_public_key( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_ramdisk_id-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_ramdisk_id","text":"aws_imds_client_get_ramdisk_id(client, callback, user_data)\n\nGets the ramdisk id of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_ramdisk_id( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_reservation_id-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_reservation_id","text":"aws_imds_client_get_reservation_id(client, callback, user_data)\n\nGets the reservation id of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_reservation_id( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_resource_async-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_resource_async","text":"aws_imds_client_get_resource_async(client, resource_path, callback, user_data)\n\nQueries a generic resource (string) from the ec2 instance metadata document\n\nParameters\n\nclient: imds client to use for the query\nresource_path: path of the resource to query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_resource_async( struct aws_imds_client *client, struct aws_byte_cursor resource_path, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_security_groups-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_security_groups","text":"aws_imds_client_get_security_groups(client, callback, user_data)\n\nGets the list of the security groups of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_security_groups( struct aws_imds_client *client, aws_imds_client_on_get_array_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_get_user_data-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_get_user_data","text":"aws_imds_client_get_user_data(client, callback, user_data)\n\nGets the user data of the ec2 instance from the instance metadata document\n\nParameters\n\nclient: imds client to use for the query\ncallback: callback function to invoke on query success or failure\nuser_data: opaque data to invoke the completion callback with\n\nReturns\n\nAWS_OP_SUCCESS if the query was successfully started, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_imds_client_get_user_data( struct aws_imds_client *client, aws_imds_client_on_get_resource_callback_fn callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_new","text":"aws_imds_client_new(allocator, options)\n\nCreates a new imds client\n\nParameters\n\nallocator: memory allocator to use for creation and queries\noptions: configuration options for the imds client\n\nReturns\n\na newly-constructed imds client, or NULL on failure\n\nPrototype\n\nstruct aws_imds_client *aws_imds_client_new( struct aws_allocator *allocator, const struct aws_imds_client_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_imds_client_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_imds_client_release","text":"aws_imds_client_release(client)\n\nDecrements the ref count on the client\n\nParameters\n\nclient: imds client to release a reference to\n\nPrototype\n\nvoid aws_imds_client_release(struct aws_imds_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_acquire","text":"aws_input_stream_acquire(stream)\n\nIncrements the reference count on the input stream, allowing the caller to take a reference to it.\n\nReturns the same input stream passed in.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_acquire(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_destroy","text":"aws_input_stream_destroy(stream)\n\nPrototype\n\nvoid aws_input_stream_destroy(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_get_length-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_get_length","text":"aws_input_stream_get_length(stream, out_length)\n\nPrototype\n\nint aws_input_stream_get_length(struct aws_input_stream *stream, int64_t *out_length);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_get_status-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_get_status","text":"aws_input_stream_get_status(stream, status)\n\nPrototype\n\nint aws_input_stream_get_status(struct aws_input_stream *stream, struct aws_stream_status *status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_new_from_cursor-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_new_from_cursor","text":"aws_input_stream_new_from_cursor(allocator, cursor)\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_cursor( struct aws_allocator *allocator, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_new_from_file-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_new_from_file","text":"aws_input_stream_new_from_file(allocator, file_name)\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_file( struct aws_allocator *allocator, const char *file_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_new_from_open_file-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_new_from_open_file","text":"aws_input_stream_new_from_open_file(allocator, file)\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_new_from_open_file(struct aws_allocator *allocator, FILE *file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_read-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_read","text":"aws_input_stream_read(stream, dest)\n\nPrototype\n\nint aws_input_stream_read(struct aws_input_stream *stream, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_release","text":"aws_input_stream_release(stream)\n\nDecrements a input stream's ref count. When the ref count drops to zero, the input stream will be destroyed.\n\nReturns NULL always.\n\nPrototype\n\nstruct aws_input_stream *aws_input_stream_release(struct aws_input_stream *stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_input_stream_seek-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_input_stream_seek","text":"aws_input_stream_seek(stream, offset, basis)\n\nPrototype\n\nint aws_input_stream_seek(struct aws_input_stream *stream, int64_t offset, enum aws_stream_seek_basis basis);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_io_fatal_assert_library_initialized-Tuple{}","page":"Home","title":"LibAWSCRT.aws_io_fatal_assert_library_initialized","text":"aws_io_fatal_assert_library_initialized()\n\nPrototype\n\nvoid aws_io_fatal_assert_library_initialized(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_io_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_io_library_clean_up","text":"aws_io_library_clean_up()\n\nShuts down the internal datastructures used by aws-c-io.\n\nPrototype\n\nvoid aws_io_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_io_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_io_library_init","text":"aws_io_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-io. Must be called before using any functionality in aws-c-io.\n\nPrototype\n\nvoid aws_io_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_clean_up","text":"aws_iotdevice_defender_config_clean_up(config)\n\nDestroys a new reporting task for Device Defender metrics\n\nParameters\n\nconfig:[in] defender task configuration\n\nPrototype\n\nvoid aws_iotdevice_defender_config_clean_up(struct aws_iotdevice_defender_task_config *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_create-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_create","text":"aws_iotdevice_defender_config_create(config_out, allocator, thing_name, report_format)\n\nCreates a new reporting task config for Device Defender metrics collection\n\nParameters\n\nconfig_out:[in] output to write a pointer to a task configuration. Will write non-NULL if successful in creating the the task configuration. Will write NULL if there is an error during creation\nallocator:[in] allocator to use for the task configuration's internal data, and the task itself when started\nthing_name:[in] thing name the task config is reporting for\nreport_format:[in] report format to produce when publishing to IoT\n\nReturns\n\nAWS_OP_SUCCESS and config_out will be non-NULL. Returns an error code otherwise\n\nPrototype\n\nint aws_iotdevice_defender_config_create( struct aws_iotdevice_defender_task_config **config_out, struct aws_allocator *allocator, const struct aws_byte_cursor *thing_name, enum aws_iotdevice_defender_report_format report_format);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_register_ip_list_metric-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_register_ip_list_metric","text":"aws_iotdevice_defender_config_register_ip_list_metric(task_config, metric_name, supplier, userdata)\n\nAdds IP list custom metric to the Device Defender task configuration. Has no impact on a defender task already started using the configuration.\n\nParameters\n\ntask_config:[in] the defender task configuration to register the metric to\nmetric_name:[in] UTF8 byte string of the metric name\nsupplier:[in] callback function to produce the metric value when requested at report generation time\nuserdata:[in] specific callback data for the supplier callback function\n\nPrototype\n\nvoid aws_iotdevice_defender_config_register_ip_list_metric( struct aws_iotdevice_defender_task_config *task_config, const struct aws_byte_cursor *metric_name, aws_iotdevice_defender_get_ip_list_fn *supplier, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_register_number_list_metric-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_register_number_list_metric","text":"aws_iotdevice_defender_config_register_number_list_metric(task_config, metric_name, supplier, userdata)\n\nAdds number list custom metric to the Device Defender task configuration. Has no impact on a defender task already started using the configuration.\n\nParameters\n\ntask_config:[in] the defender task configuration to register the metric to\nmetric_name:[in] UTF8 byte string of the metric name\nsupplier:[in] callback function to produce the metric value when requested at report generation time\nuserdata:[in] specific callback data for the supplier callback function\n\nPrototype\n\nvoid aws_iotdevice_defender_config_register_number_list_metric( struct aws_iotdevice_defender_task_config *task_config, const struct aws_byte_cursor *metric_name, aws_iotdevice_defender_get_number_list_fn *supplier, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_register_number_metric-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_register_number_metric","text":"aws_iotdevice_defender_config_register_number_metric(task_config, metric_name, supplier, userdata)\n\nAdds number custom metric to the Device Defender task configuration. Has no impact on a defender task already started using the configuration.\n\nParameters\n\ntask_config:[in] the defender task configuration to register the metric to\nmetric_name:[in] UTF8 byte string of the metric name\nsupplier:[in] callback function to produce the metric value when requested at report generation time\nuserdata:[in] specific callback data for the supplier callback function\n\nPrototype\n\nvoid aws_iotdevice_defender_config_register_number_metric( struct aws_iotdevice_defender_task_config *task_config, const struct aws_byte_cursor *metric_name, aws_iotdevice_defender_get_number_fn *supplier, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_register_string_list_metric-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_register_string_list_metric","text":"aws_iotdevice_defender_config_register_string_list_metric(task_config, metric_name, supplier, userdata)\n\nAdds string list custom metric to the Device Defender task configuration. Has no impact on a defender task already started using the configuration.\n\nParameters\n\ntask_config:[in] the defender task configuration to register the metric to\nmetric_name:[in] UTF8 byte string of the metric name\nsupplier:[in] callback function to produce the metric value when requested at report generation time\nuserdata:[in] specific callback data for the supplier callback function\n\nPrototype\n\nvoid aws_iotdevice_defender_config_register_string_list_metric( struct aws_iotdevice_defender_task_config *task_config, const struct aws_byte_cursor *metric_name, aws_iotdevice_defender_get_string_list_fn *supplier, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_callback_userdata-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_callback_userdata","text":"aws_iotdevice_defender_config_set_callback_userdata(config, userdata)\n\nSets the userdata for the device defender task's callback functions\n\nParameters\n\nconfig:[in] defender task configuration\nuserdata:[in] how much time in nanoseconds between defender task runs\n\nReturns\n\nAWS_OP_SUCCESS when the property has been set properly. Returns an error code if the value was not able to be set\n\nPrototype\n\nint aws_iotdevice_defender_config_set_callback_userdata( struct aws_iotdevice_defender_task_config *config, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_report_accepted_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_report_accepted_fn","text":"aws_iotdevice_defender_config_set_report_accepted_fn(config, accepted_fn)\n\nSets the report rejected callback function to invoke when is canceled and not going to be scheduled to run. This is a suggestion of when it is OK to close or free resources kept around while the task is running.\n\nParameters\n\nconfig:[in] defender task configuration\naccepted_fn:[in] accepted report callback function\n\nReturns\n\nAWS_OP_SUCCESS when the report accepted callback has been set. Returns an error if the callback was not set\n\nPrototype\n\nint aws_iotdevice_defender_config_set_report_accepted_fn( struct aws_iotdevice_defender_task_config *config, aws_iotdevice_defender_report_accepted_fn *accepted_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_report_rejected_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_report_rejected_fn","text":"aws_iotdevice_defender_config_set_report_rejected_fn(config, rejected_fn)\n\nSets the report rejected callback function to invoke when is canceled and not going to be scheduled to run. This is a suggestion of when it is OK to close or free resources kept around while the task is running.\n\nParameters\n\nconfig:[in] defender task configuration\nrejected_fn:[in] rejected report callback function\n\nReturns\n\nAWS_OP_SUCCESS when the report rejected callback has been set. Returns an error if the callback was not set\n\nPrototype\n\nint aws_iotdevice_defender_config_set_report_rejected_fn( struct aws_iotdevice_defender_task_config *config, aws_iotdevice_defender_report_rejected_fn *rejected_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_task_cancelation_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_task_cancelation_fn","text":"aws_iotdevice_defender_config_set_task_cancelation_fn(config, cancel_fn)\n\nSets the task cancelation callback function to invoke when the task is canceled and not going to be scheduled to run. This is a suggestion of when it is OK to close or free resources kept around while the task is running.\n\nParameters\n\nconfig:[in] defender task configuration\ncancel_fn:[in] cancelation callback function\n\nReturns\n\nAWS_OP_SUCCESS when the task cancelation callback has been set. Returns an error if the callback was not set\n\nPrototype\n\nint aws_iotdevice_defender_config_set_task_cancelation_fn( struct aws_iotdevice_defender_task_config *config, aws_iotdevice_defender_task_canceled_fn *cancel_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_task_failure_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_task_failure_fn","text":"aws_iotdevice_defender_config_set_task_failure_fn(config, failure_fn)\n\nSets the task failure callback function to invoke when the running of the task encounters a failure. Though this is optional to specify, it is important to register a handler to at least monitor failure that stops the task from running\n\nThe most likely scenario for task not being able to continue is failure to reschedule the task\n\nParameters\n\nconfig:[in] defender task configuration\nfailure_fn:[in] failure callback function\n\nReturns\n\nAWS_OP_SUCCESS when the task failure callback has been set. Returns an error if the callback was not set\n\nPrototype\n\nint aws_iotdevice_defender_config_set_task_failure_fn( struct aws_iotdevice_defender_task_config *config, aws_iotdevice_defender_task_failure_fn *failure_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_config_set_task_period_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_config_set_task_period_ns","text":"aws_iotdevice_defender_config_set_task_period_ns(config, task_period_ns)\n\nSets the period of the device defender task\n\nParameters\n\nconfig:[in] defender task configuration\ntask_period_ns:[in] how much time in nanoseconds between defender task runs\n\nReturns\n\nAWS_OP_SUCCESS when the property has been set properly. Returns an error code if the value was not able to be set.\n\nPrototype\n\nint aws_iotdevice_defender_config_set_task_period_ns( struct aws_iotdevice_defender_task_config *config, uint64_t task_period_ns);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_task_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_task_clean_up","text":"aws_iotdevice_defender_task_clean_up(defender_task)\n\nCancels the running task reporting Device Defender metrics and cleans up. If the task is currently running, it will block until the task has been canceled and cleaned up successfully\n\nParameters\n\ndefender_task:[in] running task to stop and clean up\n\nPrototype\n\nvoid aws_iotdevice_defender_task_clean_up(struct aws_iotdevice_defender_task *defender_task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_task_create-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_task_create","text":"aws_iotdevice_defender_task_create(task_out, config, connection, event_loop)\n\nCreates and starts a new Device Defender reporting task\n\nParameters\n\ntask_out:[out] output parameter to set to point to the defender task\nconfig:[in] defender task configuration to use to start the task\nconnection:[in] mqtt connection to use to publish reports to\nevent_loop:[in] IoT device thing name used to determine the MQTT topic to publish the report to and listen for accepted or rejected responses\n\nReturns\n\nAWS_OP_SUCCESS if the task has been created successfully and is scheduled to run\n\nPrototype\n\nint aws_iotdevice_defender_task_create( struct aws_iotdevice_defender_task **task_out, const struct aws_iotdevice_defender_task_config *config, struct aws_mqtt_client_connection *connection, struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_defender_task_create_ex-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_defender_task_create_ex","text":"aws_iotdevice_defender_task_create_ex(task_out, config, publish_fn, event_loop)\n\nCreates and starts a new Device Defender reporting task with the ability to define a function to accept/handle each report when the task needs to publish.\n\nParameters\n\ntask_out:[out] output parameter to set to point to the defender task\nconfig:[in] defender task configuration to use to start the task\npublish_fn:[in] callback to handle reports generated by the task. The userdata comes from the task config\nevent_loop:[in] IoT device thing name used to determine the MQTT topic to publish the report to and listen for accepted or rejected responses\n\nReturns\n\nAWS_OP_SUCCESS if the task has been created successfully and is scheduled to run\n\nPrototype\n\nint aws_iotdevice_defender_task_create_ex( struct aws_iotdevice_defender_task **task_out, const struct aws_iotdevice_defender_task_config *config, aws_iotdevice_defender_publish_fn *publish_fn, struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_iotdevice_library_clean_up","text":"aws_iotdevice_library_clean_up()\n\nShuts down the internal datastructures used by aws-c-iot\n\nPrototype\n\nvoid aws_iotdevice_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_iotdevice_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_iotdevice_library_init","text":"aws_iotdevice_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-iot. Must be called before using any functionality in aws-c-iot.\n\nPrototype\n\nvoid aws_iotdevice_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_is_any_directory_separator-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_is_any_directory_separator","text":"aws_is_any_directory_separator(value)\n\nReturns true iff the character is a directory separator on ANY supported platform.\n\nPrototype\n\nbool aws_is_any_directory_separator(char value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_is_big_endian-Tuple{}","page":"Home","title":"LibAWSCRT.aws_is_big_endian","text":"aws_is_big_endian()\n\nReturns 1 if machine is big endian, 0 if little endian. If you compile with even -O1 optimization, this check is completely optimized out at compile time and code which calls \"if (aws_is_big_endian())\" will do the right thing without branching.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_is_big_endian(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_is_debugger_present-Tuple{}","page":"Home","title":"LibAWSCRT.aws_is_debugger_present","text":"aws_is_debugger_present()\n\nPrototype\n\nbool aws_is_debugger_present(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_is_mem_zeroed-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_is_mem_zeroed","text":"aws_is_mem_zeroed(buf, bufsize)\n\nReturns whether each byte is zero.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_is_mem_zeroed(const void *buf, size_t bufsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_is_power_of_two-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_is_power_of_two","text":"aws_is_power_of_two(x)\n\nFunction to check if x is power of 2\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_is_power_of_two(const size_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_isalnum-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_isalnum","text":"aws_isalnum(ch)\n\nLike isalnum(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'.\n\nPrototype\n\nbool aws_isalnum(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_isalpha-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_isalpha","text":"aws_isalpha(ch)\n\nLike isalpha(), but ignores C locale. Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'.\n\nPrototype\n\nbool aws_isalpha(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_isdigit-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_isdigit","text":"aws_isdigit(ch)\n\nLike isdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.\n\nNote: C's built-in isdigit() is also supposed to ignore the C locale, but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits\"\n\nPrototype\n\nbool aws_isdigit(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_isspace-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_isspace","text":"aws_isspace(ch)\n\nLike isspace(), but ignores C locale. Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C), line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B).\n\nPrototype\n\nbool aws_isspace(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_isxdigit-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_isxdigit","text":"aws_isxdigit(ch)\n\nLike isxdigit(). Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.\n\nNote: C's built-in isxdigit() is also supposed to ignore the C locale, but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits\"\n\nPrototype\n\nbool aws_isxdigit(uint8_t ch);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_const_iterate_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_const_iterate_array","text":"aws_json_const_iterate_array(array, on_value, user_data)\n\niterates through values of an array. iteration is sequential starting with 0th element.\n\nParameters\n\narray: array to iterate over.\non_value: callback for when value is encountered.\nuser_data: user data to pass back in callback.\n\nReturns\n\nAWS_OP_SUCCESS when iteration finishes completely or exits early, AWS_OP_ERR if value is not an array.\n\nPrototype\n\nint aws_json_const_iterate_array( const struct aws_json_value *array, aws_json_on_value_encountered_const_fn *on_value, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_const_iterate_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_const_iterate_object","text":"aws_json_const_iterate_object(object, on_member, user_data)\n\niterates through members of the object. iteration is sequential in order fields were initially parsed.\n\nParameters\n\nobject: object to iterate over.\non_member: callback for when member is encountered.\nuser_data: user data to pass back in callback.\n\nReturns\n\nAWS_OP_SUCCESS when iteration finishes completely or exits early, AWS_OP_ERR if value is not an object.\n\nPrototype\n\nint aws_json_const_iterate_object( const struct aws_json_value *object, aws_json_on_member_encountered_const_fn *on_member, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_get_array_element-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_get_array_element","text":"aws_json_get_array_element(array, index)\n\nReturns the aws_json_value at the given index in the array aws_json_value.\n\nParameters\n\narray: The array aws_json_value.\nindex: The index of the aws_json_value you want to access.\n\nReturns\n\nA pointer to the aws_json_value at the given index in the array, otherwise NULL.\n\nPrototype\n\nstruct aws_json_value *aws_json_get_array_element(const struct aws_json_value *array, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_get_array_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_get_array_size","text":"aws_json_get_array_size(array)\n\nReturns the number of items in the array aws_json_value.\n\nParameters\n\narray: The array aws_json_value.\n\nReturns\n\nThe number of items in the array_json_value.\n\nPrototype\n\nsize_t aws_json_get_array_size(const struct aws_json_value *array);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_add_array_element-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_add_array_element","text":"aws_json_value_add_array_element(array, value)\n\nAdds a aws_json_value to the given array aws_json_value.\n\nNote that the aws_json_value will be destroyed when the aws_json_value array is destroyed by calling \"aws_json_destroy()\"\n\nParameters\n\narray: The array aws_json_value you want to add an aws_json_value to.\nvalue: The aws_json_value you want to add.\n\nReturns\n\nAWS_OP_SUCCESS if adding the aws_json_value was successful. Will return AWS_OP_ERR if the array passed is invalid.\n\nPrototype\n\nint aws_json_value_add_array_element(struct aws_json_value *array, const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_add_to_object-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_add_to_object","text":"aws_json_value_add_to_object(object, key, value)\n\nAdds a aws_json_value to a object aws_json_value.\n\nNote that the aws_json_value will be destroyed when the aws_json_value object is destroyed by calling \"aws_json_destroy()\"\n\nParameters\n\nobject: The object aws_json_value you want to add a value to.\nkey: The key to add the aws_json_value at.\nvalue: The aws_json_value you want to add.\n\nReturns\n\nAWS_OP_SUCCESS if adding was successful. Will return AWS_OP_ERROR if the object passed is invalid or if the passed key is already in use in the object.\n\nPrototype\n\nint aws_json_value_add_to_object( struct aws_json_value *object, struct aws_byte_cursor key, struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_compare-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_compare","text":"aws_json_value_compare(a, b, is_case_sensitive)\n\nChecks whether two json values are equivalent.\n\nParameters\n\na: first value to compare.\nb: second value to compare.\nis_case_sensitive: case sensitive compare or not.\n\nReturns\n\nTrue is values are equal, false otherwise\n\nPrototype\n\nbool aws_json_value_compare(const struct aws_json_value *a, const struct aws_json_value *b, bool is_case_sensitive);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_destroy","text":"aws_json_value_destroy(value)\n\nRemoves the aws_json_value from memory. If the aws_json_value is a object or array, it will also destroy attached aws_json_values as well.\n\nFor example, if you called \"aws_json_array_add(b, a)\" to add an object \"a\" to an array \"b\", if you call \"aws_json_destroy(b)\" then it will also free \"a\" automatically. All children/attached aws_json_values are freed when the parent/root aws_json_value is destroyed.\n\nParameters\n\nvalue: The aws_json_value to destroy.\n\nPrototype\n\nvoid aws_json_value_destroy(struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_duplicate-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_duplicate","text":"aws_json_value_duplicate(value)\n\nDuplicates json value.\n\nParameters\n\nvalue: first value to compare.\n\nReturns\n\nduplicated value. NULL and last error set if value cannot be duplicated.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_duplicate(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_get_boolean-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_get_boolean","text":"aws_json_value_get_boolean(value, output)\n\nGets the boolean of a boolean aws_json_value.\n\nParameters\n\nvalue: The boolean aws_json_value.\noutput: The boolean\n\nReturns\n\nAWS_OP_SUCCESS if the value is a boolean, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_boolean(const struct aws_json_value *value, bool *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_get_from_object-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_get_from_object","text":"aws_json_value_get_from_object(object, key)\n\nReturns the aws_json_value at the given key.\n\nParameters\n\nobject: The object aws_json_value you want to get the value from.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nThe aws_json_value at the given key, otherwise NULL.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_get_from_object(const struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_get_number-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_get_number","text":"aws_json_value_get_number(value, output)\n\nGets the number of a number aws_json_value.\n\nParameters\n\nvalue: The number aws_json_value.\noutput: The number\n\nReturns\n\nAWS_OP_SUCCESS if the value is a number, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_number(const struct aws_json_value *value, double *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_get_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_get_string","text":"aws_json_value_get_string(value, output)\n\nGets the string of a string aws_json_value.\n\nParameters\n\nvalue: The string aws_json_value.\noutput: The string\n\nReturns\n\nAWS_OP_SUCCESS if the value is a string, otherwise AWS_OP_ERR.\n\nPrototype\n\nint aws_json_value_get_string(const struct aws_json_value *value, struct aws_byte_cursor *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_has_key-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_has_key","text":"aws_json_value_has_key(object, key)\n\nChecks if there is a aws_json_value at the given key.\n\nParameters\n\nobject: The value aws_json_value you want to check a key in.\nkey: The key that you want to check. Is case sensitive.\n\nReturns\n\nTrue if a aws_json_value is found.\n\nPrototype\n\nbool aws_json_value_has_key(const struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_array-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_array","text":"aws_json_value_is_array(value)\n\nChecks if the aws_json_value is a array.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a array aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_array(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_boolean-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_boolean","text":"aws_json_value_is_boolean(value)\n\nChecks if the aws_json_value is a boolean.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a boolean aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_boolean(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_null-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_null","text":"aws_json_value_is_null(value)\n\nChecks if the aws_json_value is a null aws_json_value.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a null aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_null(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_number-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_number","text":"aws_json_value_is_number(value)\n\nChecks if the aws_json_value is a number.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a number aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_number(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_object-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_object","text":"aws_json_value_is_object(value)\n\nChecks if the aws_json_value is a object aws_json_value.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a object aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_object(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_is_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_is_string","text":"aws_json_value_is_string(value)\n\nChecks if the aws_json_value is a string.\n\nParameters\n\nvalue: The aws_json_value to check.\n\nReturns\n\nTrue if the aws_json_value is a string aws_json_value, otherwise false.\n\nPrototype\n\nbool aws_json_value_is_string(const struct aws_json_value *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_array-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_array","text":"aws_json_value_new_array(allocator)\n\nCreates a new array aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value. Deleting this array will also destroy any aws_json_values it contains.\n\nParameters\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new array aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_array(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_boolean-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_boolean","text":"aws_json_value_new_boolean(allocator, boolean)\n\nCreates a new boolean aws_json_value with the given boolean and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nParameters\n\nboolean: The boolean you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new boolean aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_boolean(struct aws_allocator *allocator, bool boolean);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_from_string","text":"aws_json_value_new_from_string(allocator, string)\n\nParses the JSON string and returns a aws_json_value containing the root of the JSON.\n\nParameters\n\nallocator: The allocator used to create the value\nstring: The string containing the JSON.\n\nReturns\n\nThe root aws_json_value of the JSON.\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_from_string(struct aws_allocator *allocator, struct aws_byte_cursor string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_null-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_null","text":"aws_json_value_new_null(allocator)\n\nCreates a new null aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nParameters\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new null aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_null(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_number-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_number","text":"aws_json_value_new_number(allocator, number)\n\nCreates a new number aws_json_value with the given number and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nParameters\n\nnumber: The number you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new number aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_number(struct aws_allocator *allocator, double number);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_object-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_object","text":"aws_json_value_new_object(allocator)\n\nCreates a new object aws_json_value and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value. Deleting this object will also destroy any aws_json_values it contains.\n\nParameters\n\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new object aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_object(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_new_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_new_string","text":"aws_json_value_new_string(allocator, string)\n\nCreates a new string aws_json_value with the given string and returns a pointer to it.\n\nNote: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or on the object/array containing the aws_json_value.\n\nParameters\n\nstring: A byte pointer to the string you want to store in the aws_json_value\nallocator: The allocator to use when creating the value\n\nReturns\n\nA new string aws_json_value\n\nPrototype\n\nstruct aws_json_value *aws_json_value_new_string(struct aws_allocator *allocator, struct aws_byte_cursor string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_remove_array_element-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_remove_array_element","text":"aws_json_value_remove_array_element(array, index)\n\nRemoves the aws_json_value at the given index in the array aws_json_value.\n\nParameters\n\narray: The array aws_json_value.\nindex: The index containing the aws_json_value you want to remove.\n\nReturns\n\nAWS_OP_SUCCESS if the aws_json_value at the index was removed. Will return AWS_OP_ERR if the array passed is invalid or if the index passed is out of range.\n\nPrototype\n\nint aws_json_value_remove_array_element(struct aws_json_value *array, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_json_value_remove_from_object-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_json_value_remove_from_object","text":"aws_json_value_remove_from_object(object, key)\n\nRemoves the aws_json_value at the given key.\n\nParameters\n\nobject: The object aws_json_value you want to remove a aws_json_value in.\nkey: The key that the aws_json_value is at. Is case sensitive.\n\nReturns\n\nAWS_OP_SUCCESS if the aws_json_value was removed. Will return AWS_OP_ERR if the object passed is invalid or if the value at the key cannot be found.\n\nPrototype\n\nint aws_json_value_remove_from_object(struct aws_json_value *object, struct aws_byte_cursor key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_last_error-Tuple{}","page":"Home","title":"LibAWSCRT.aws_last_error","text":"aws_last_error()\n\nPrototype\n\nint aws_last_error(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_clean_up","text":"aws_linked_hash_table_clean_up(table)\n\nCleans up the table. Elements in the table will be evicted and cleanup callbacks will be invoked.\n\nPrototype\n\nvoid aws_linked_hash_table_clean_up(struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_clear-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_clear","text":"aws_linked_hash_table_clear(table)\n\nClears all items from the table.\n\nPrototype\n\nvoid aws_linked_hash_table_clear(struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_find-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_find","text":"aws_linked_hash_table_find(table, key, p_value)\n\nFinds element in the table by key. If found, AWS_OP_SUCCESS will be returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nIf any errors occur AWS_OP_ERR will be returned.\n\nPrototype\n\nint aws_linked_hash_table_find(struct aws_linked_hash_table *table, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_find_and_move_to_back-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_find_and_move_to_back","text":"aws_linked_hash_table_find_and_move_to_back(table, key, p_value)\n\nFinds element in the table by key. If found, AWS_OP_SUCCESS will be returned and the item will be moved to the back of the list. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\nNote: this will change the order of elements\n\nPrototype\n\nint aws_linked_hash_table_find_and_move_to_back(struct aws_linked_hash_table *table, const void *key, void **p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_get_element_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_get_element_count","text":"aws_linked_hash_table_get_element_count(table)\n\nreturns number of elements in the table.\n\nPrototype\n\nsize_t aws_linked_hash_table_get_element_count(const struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_get_iteration_list-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_get_iteration_list","text":"aws_linked_hash_table_get_iteration_list(table)\n\nreturns the underlying linked list for iteration.\n\nThe returned list has nodes of the type: aws_linked_hash_table_node. Use AWS_CONTAINER_OF for access to the element.\n\nPrototype\n\nconst struct aws_linked_list *aws_linked_hash_table_get_iteration_list(const struct aws_linked_hash_table *table);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_init-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_init","text":"aws_linked_hash_table_init(table, allocator, hash_fn, equals_fn, destroy_key_fn, destroy_value_fn, initial_item_count)\n\nInitializes the table. Sets up the underlying hash table and linked list. For the other parameters, see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.\n\nPrototype\n\nint aws_linked_hash_table_init( struct aws_linked_hash_table *table, struct aws_allocator *allocator, aws_hash_fn *hash_fn, aws_hash_callback_eq_fn *equals_fn, aws_hash_callback_destroy_fn *destroy_key_fn, aws_hash_callback_destroy_fn *destroy_value_fn, size_t initial_item_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_move_node_to_end_of_list-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_move_node_to_end_of_list","text":"aws_linked_hash_table_move_node_to_end_of_list(table, node)\n\nMove the aws_linked_hash_table_node to the end of the list.\n\nNote: this will change the order of elements\n\nPrototype\n\nvoid aws_linked_hash_table_move_node_to_end_of_list( struct aws_linked_hash_table *table, struct aws_linked_hash_table_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_put-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_put","text":"aws_linked_hash_table_put(table, key, p_value)\n\nPuts p_value at key. If an element is already stored at key it will be replaced.\n\nPrototype\n\nint aws_linked_hash_table_put(struct aws_linked_hash_table *table, const void *key, void *p_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_hash_table_remove-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_hash_table_remove","text":"aws_linked_hash_table_remove(table, key)\n\nRemoves item at key from the table.\n\nPrototype\n\nint aws_linked_hash_table_remove(struct aws_linked_hash_table *table, const void *key);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_back-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_back","text":"aws_linked_list_back(list)\n\nReturns the element in the back of the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_back(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_begin-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_begin","text":"aws_linked_list_begin(list)\n\nReturns an iteration pointer for the first element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_begin(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_empty-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_empty","text":"aws_linked_list_empty(list)\n\nTests if the list is empty.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_empty(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_end-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_end","text":"aws_linked_list_end(list)\n\nReturns an iteration pointer for one past the last element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL const struct aws_linked_list_node *aws_linked_list_end(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_front-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_front","text":"aws_linked_list_front(list)\n\nReturns the element in the front of the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_front(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_init","text":"aws_linked_list_init(list)\n\nInitializes the list. List will be empty after this call.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_init(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_insert_after-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_insert_after","text":"aws_linked_list_insert_after(after, to_add)\n\nInserts to_add immediately after after.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_insert_after( struct aws_linked_list_node *after, struct aws_linked_list_node *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_insert_before-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_insert_before","text":"aws_linked_list_insert_before(before, to_add)\n\nInserts to_add immediately before before.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_insert_before( struct aws_linked_list_node *before, struct aws_linked_list_node *to_add);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_is_valid","text":"aws_linked_list_is_valid(list)\n\nChecks that a linked list is valid.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_is_valid(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_is_valid_deep-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_is_valid_deep","text":"aws_linked_list_is_valid_deep(list)\n\nChecks that a linked list satisfies double linked list connectivity constraints. This check is O(n) as it traverses the whole linked list to ensure that tail is reachable from head (and vice versa) and that every connection is bidirectional.\n\nNote: This check cannot go into an infinite loop, because we ensure that the connection to the next node is bidirectional. Therefore, if a node's [a] a.next is a previous node [b] in the list, b.prev != &a and so this check would fail, thus terminating the loop.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_is_valid_deep(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_move_all_back-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_move_all_back","text":"aws_linked_list_move_all_back(dst, src)\n\nRemove all nodes from one list, and add them to the back of another.\n\nExample: if dst={1,2} and src={3,4}, they become dst={1,2,3,4} and src={}\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_move_all_back( struct aws_linked_list *AWS_RESTRICT dst, struct aws_linked_list *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_move_all_front-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_move_all_front","text":"aws_linked_list_move_all_front(dst, src)\n\nRemove all nodes from one list, and add them to the front of another.\n\nExample: if dst={2,1} and src={4,3}, they become dst={4,3,2,1} and src={}\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_move_all_front( struct aws_linked_list *AWS_RESTRICT dst, struct aws_linked_list *AWS_RESTRICT src);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_next-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_next","text":"aws_linked_list_next(node)\n\nReturns the next element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_next(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_node_next_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_node_next_is_valid","text":"aws_linked_list_node_next_is_valid(node)\n\nChecks that the prev of the next pointer of a node points to the node. As this checks whether the [next] connection of a node is bidirectional, it returns false if used for the list tail.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_node_next_is_valid(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_node_prev_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_node_prev_is_valid","text":"aws_linked_list_node_prev_is_valid(node)\n\nChecks that the next of the prev pointer of a node points to the node. Similarly to the above, this returns false if used for the head of a list.\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_linked_list_node_prev_is_valid(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_node_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_node_reset","text":"aws_linked_list_node_reset(node)\n\nSet node's next and prev pointers to NULL.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_node_reset(struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_pop_back-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_pop_back","text":"aws_linked_list_pop_back(list)\n\nReturns the element in the back of the list and removes it\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_pop_back(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_pop_front-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_pop_front","text":"aws_linked_list_pop_front(list)\n\nReturns the element in the front of the list and removes it\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_pop_front(struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_prev-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_prev","text":"aws_linked_list_prev(node)\n\nReturns the previous element in the list.\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_prev(const struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_push_back-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_push_back","text":"aws_linked_list_push_back(list, node)\n\nAppend new_node.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_push_back(struct aws_linked_list *list, struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_push_front-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_push_front","text":"aws_linked_list_push_front(list, node)\n\nPrepend new_node.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_push_front(struct aws_linked_list *list, struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_rbegin-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_rbegin","text":"aws_linked_list_rbegin(list)\n\nReturns a pointer for the last element in the list. Used to begin iterating the list in reverse. Ex: for (i = aws_linked_list_rbegin(list); i != aws_linked_list_rend(list); i = aws_linked_list_prev(i)) {...}\n\nPrototype\n\nAWS_STATIC_IMPL struct aws_linked_list_node *aws_linked_list_rbegin(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_remove-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_remove","text":"aws_linked_list_remove(node)\n\nRemoves the specified node from the list (prev/next point to each other) and returns the next node in the list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_remove(struct aws_linked_list_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_rend-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_rend","text":"aws_linked_list_rend(list)\n\nReturns the pointer to one before the first element in the list. Used to end iterating the list in reverse.\n\nPrototype\n\nAWS_STATIC_IMPL const struct aws_linked_list_node *aws_linked_list_rend(const struct aws_linked_list *list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_swap_contents-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_swap_contents","text":"aws_linked_list_swap_contents(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_swap_contents( struct aws_linked_list *AWS_RESTRICT a, struct aws_linked_list *AWS_RESTRICT b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_linked_list_swap_nodes-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_linked_list_swap_nodes","text":"aws_linked_list_swap_nodes(a, b)\n\nSwaps the order two nodes in the linked list.\n\nPrototype\n\nAWS_STATIC_IMPL void aws_linked_list_swap_nodes(struct aws_linked_list_node *a, struct aws_linked_list_node *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_localtime-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_localtime","text":"aws_localtime(time, t)\n\nCross platform friendly version of localtime_r\n\nPrototype\n\nvoid aws_localtime(time_t time, struct tm *t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_channel_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_log_channel_clean_up","text":"aws_log_channel_clean_up(channel)\n\nPrototype\n\nvoid aws_log_channel_clean_up(struct aws_log_channel *channel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_channel_init_background-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_channel_init_background","text":"aws_log_channel_init_background(channel, allocator, writer)\n\nPrototype\n\nint aws_log_channel_init_background( struct aws_log_channel *channel, struct aws_allocator *allocator, struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_channel_init_foreground-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_channel_init_foreground","text":"aws_log_channel_init_foreground(channel, allocator, writer)\n\nPrototype\n\nint aws_log_channel_init_foreground( struct aws_log_channel *channel, struct aws_allocator *allocator, struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_formatter_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_log_formatter_clean_up","text":"aws_log_formatter_clean_up(formatter)\n\nPrototype\n\nvoid aws_log_formatter_clean_up(struct aws_log_formatter *formatter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_formatter_init_default-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_formatter_init_default","text":"aws_log_formatter_init_default(formatter, allocator, options)\n\nPrototype\n\nint aws_log_formatter_init_default( struct aws_log_formatter *formatter, struct aws_allocator *allocator, struct aws_log_formatter_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_level_to_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_level_to_string","text":"aws_log_level_to_string(log_level, level_string)\n\nConverts a log level to a c-string constant. Intended primarily to support building log lines that include the level in them, i.e.\n\n[ERROR] 10:34:54.642 01-31-19 - Json parse error....\n\nPrototype\n\nint aws_log_level_to_string(enum aws_log_level log_level, const char **level_string);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_subject_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_log_subject_name","text":"aws_log_subject_name(subject)\n\nGet subject name from log subject.\n\nPrototype\n\nconst char *aws_log_subject_name(aws_log_subject_t subject);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_writer_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_log_writer_clean_up","text":"aws_log_writer_clean_up(writer)\n\nPrototype\n\nvoid aws_log_writer_clean_up(struct aws_log_writer *writer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_writer_init_file-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_writer_init_file","text":"aws_log_writer_init_file(writer, allocator, options)\n\nPrototype\n\nint aws_log_writer_init_file( struct aws_log_writer *writer, struct aws_allocator *allocator, struct aws_log_writer_file_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_writer_init_stderr-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_writer_init_stderr","text":"aws_log_writer_init_stderr(writer, allocator)\n\nPrototype\n\nint aws_log_writer_init_stderr(struct aws_log_writer *writer, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_log_writer_init_stdout-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_log_writer_init_stdout","text":"aws_log_writer_init_stdout(writer, allocator)\n\nPrototype\n\nint aws_log_writer_init_stdout(struct aws_log_writer *writer, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_logger_clean_up","text":"aws_logger_clean_up(logger)\n\nCleans up all resources used by the logger; simply invokes the clean_up v-function\n\nPrototype\n\nvoid aws_logger_clean_up(struct aws_logger *logger);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_get-Tuple{}","page":"Home","title":"LibAWSCRT.aws_logger_get","text":"aws_logger_get()\n\nGets the aws logger used globally across the process.\n\nPrototype\n\nstruct aws_logger *aws_logger_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_get_conditional-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_logger_get_conditional","text":"aws_logger_get_conditional(subject, level)\n\nGets the aws logger used globally across the process if the logging level is at least the inputted level.\n\nParameters\n\nsubject: log subject to perform the level check versus, not currently used\nlevel: logging level to check against in order to return the logger\n\nReturns\n\nthe current logger if the current logging level is at or more detailed then the supplied logging level\n\nPrototype\n\nstruct aws_logger *aws_logger_get_conditional(aws_log_subject_t subject, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_init_from_external-NTuple{6, Any}","page":"Home","title":"LibAWSCRT.aws_logger_init_from_external","text":"aws_logger_init_from_external(logger, allocator, formatter, channel, writer, level)\n\nPrototype\n\nint aws_logger_init_from_external( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_log_formatter *formatter, struct aws_log_channel *channel, struct aws_log_writer *writer, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_init_noalloc-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_logger_init_noalloc","text":"aws_logger_init_noalloc(logger, allocator, options)\n\nPrototype\n\nint aws_logger_init_noalloc( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_logger_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_init_standard-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_logger_init_standard","text":"aws_logger_init_standard(logger, allocator, options)\n\nPrototype\n\nint aws_logger_init_standard( struct aws_logger *logger, struct aws_allocator *allocator, struct aws_logger_standard_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_set-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_logger_set","text":"aws_logger_set(logger)\n\nSets the aws logger used globally across the process. Not thread-safe. Must only be called once.\n\nPrototype\n\nvoid aws_logger_set(struct aws_logger *logger);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_logger_set_log_level-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_logger_set_log_level","text":"aws_logger_set_log_level(logger, level)\n\nSets the current logging level for the logger. Loggers are not require to support this.\n\nParameters\n\nlogger: logger to set the log level for\nlevel: new log level for the logger\n\nReturns\n\nAWS_OP_SUCCESS if the level was successfully set, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_logger_set_log_level(struct aws_logger *logger, enum aws_log_level level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_lookup_table_hex_to_num_get-Tuple{}","page":"Home","title":"LibAWSCRT.aws_lookup_table_hex_to_num_get","text":"aws_lookup_table_hex_to_num_get()\n\nReturns lookup table to go from ASCII/UTF-8 hex character to a number (0-15). Non-hex characters map to 255. Valid examples: '0' -> 0 'F' -> 15 'f' -> 15 Invalid examples: ' ' -> 255 'Z' -> 255 '\\0' -> 255\n\nPrototype\n\nconst uint8_t *aws_lookup_table_hex_to_num_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_lookup_table_to_lower_get-Tuple{}","page":"Home","title":"LibAWSCRT.aws_lookup_table_to_lower_get","text":"aws_lookup_table_to_lower_get()\n\nReturns a lookup table for bytes that is the identity transformation with the exception of uppercase ascii characters getting replaced with lowercase characters. Used in caseless comparisons.\n\nPrototype\n\nconst uint8_t *aws_lookup_table_to_lower_get(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_lru_cache_get_mru_element-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_lru_cache_get_mru_element","text":"aws_lru_cache_get_mru_element(cache)\n\nAccesses the most-recently-used element and returns its value.\n\nPrototype\n\nvoid *aws_lru_cache_get_mru_element(const struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_lru_cache_use_lru_element-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_lru_cache_use_lru_element","text":"aws_lru_cache_use_lru_element(cache)\n\nAccesses the least-recently-used element, sets it to most-recently-used element, and returns the value.\n\nPrototype\n\nvoid *aws_lru_cache_use_lru_element(struct aws_cache *cache);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_double-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_double","text":"aws_max_double(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL double aws_max_double(double a, double b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_float-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_float","text":"aws_max_float(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL float aws_max_float(float a, float b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_i16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_i16","text":"aws_max_i16(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int16_t aws_max_i16(int16_t a, int16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_i32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_i32","text":"aws_max_i32(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int32_t aws_max_i32(int32_t a, int32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_i64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_i64","text":"aws_max_i64(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int64_t aws_max_i64(int64_t a, int64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_i8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_i8","text":"aws_max_i8(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int8_t aws_max_i8(int8_t a, int8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_int-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_int","text":"aws_max_int(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int aws_max_int(int a, int b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_size-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_size","text":"aws_max_size(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_max_size(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_u16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_u16","text":"aws_max_u16(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_max_u16(uint16_t a, uint16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_u32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_u32","text":"aws_max_u32(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_max_u32(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_u64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_u64","text":"aws_max_u64(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_max_u64(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_max_u8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_max_u8","text":"aws_max_u8(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint8_t aws_max_u8(uint8_t a, uint8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_md5_compute-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_md5_compute","text":"aws_md5_compute(allocator, input, output, truncate_to)\n\nComputes the md5 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory.\n\nPrototype\n\nint aws_md5_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_md5_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_md5_new","text":"aws_md5_new(allocator)\n\nAllocates and initializes an md5 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_md5_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_acquire-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mem_acquire","text":"aws_mem_acquire(allocator, size)\n\nReturns at least size of memory ready for usage. In versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nvoid *aws_mem_acquire(struct aws_allocator *allocator, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_calloc-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mem_calloc","text":"aws_mem_calloc(allocator, num, size)\n\nAllocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits to zero. In versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_calloc() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_calloc() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nvoid *aws_mem_calloc(struct aws_allocator *allocator, size_t num, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_realloc-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_mem_realloc","text":"aws_mem_realloc(allocator, ptr, oldsize, newsize)\n\nAttempts to adjust the size of the pointed-to memory buffer from oldsize to newsize. The pointer (*ptr) may be changed if the memory needs to be reallocated.\n\nIn versions v0.6.8 and prior, this function was allowed to return NULL. In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a GC etc...before returning.\n\nPrototype\n\nint aws_mem_realloc(struct aws_allocator *allocator, void **ptr, size_t oldsize, size_t newsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_release-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mem_release","text":"aws_mem_release(allocator, ptr)\n\nReleases ptr back to whatever allocated it. Nothing happens if ptr is NULL.\n\nPrototype\n\nvoid aws_mem_release(struct aws_allocator *allocator, void *ptr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_tracer_bytes-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mem_tracer_bytes","text":"aws_mem_tracer_bytes(trace_allocator)\n\nPrototype\n\nsize_t aws_mem_tracer_bytes(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_tracer_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mem_tracer_count","text":"aws_mem_tracer_count(trace_allocator)\n\nPrototype\n\nsize_t aws_mem_tracer_count(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_tracer_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mem_tracer_destroy","text":"aws_mem_tracer_destroy(trace_allocator)\n\nPrototype\n\nstruct aws_allocator *aws_mem_tracer_destroy(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_tracer_dump-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mem_tracer_dump","text":"aws_mem_tracer_dump(trace_allocator)\n\nPrototype\n\nvoid aws_mem_tracer_dump(struct aws_allocator *trace_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mem_tracer_new-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_mem_tracer_new","text":"aws_mem_tracer_new(allocator, deprecated, level, frames_per_stack)\n\nPrototype\n\nstruct aws_allocator *aws_mem_tracer_new( struct aws_allocator *allocator, struct aws_allocator *deprecated, enum aws_mem_trace_level level, size_t frames_per_stack);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_memory_pool_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_memory_pool_acquire","text":"aws_memory_pool_acquire(mempool)\n\nAcquires memory from the pool if available, otherwise, it attempts to allocate and returns the result.\n\nPrototype\n\nvoid *aws_memory_pool_acquire(struct aws_memory_pool *mempool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_memory_pool_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_memory_pool_clean_up","text":"aws_memory_pool_clean_up(mempool)\n\nPrototype\n\nvoid aws_memory_pool_clean_up(struct aws_memory_pool *mempool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_memory_pool_init-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_memory_pool_init","text":"aws_memory_pool_init(mempool, alloc, ideal_segment_count, segment_size)\n\nPrototype\n\nint aws_memory_pool_init( struct aws_memory_pool *mempool, struct aws_allocator *alloc, uint16_t ideal_segment_count, size_t segment_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_memory_pool_release-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_memory_pool_release","text":"aws_memory_pool_release(mempool, to_release)\n\nReleases memory to the pool if space is available, otherwise frees to_release\n\nPrototype\n\nvoid aws_memory_pool_release(struct aws_memory_pool *mempool, void *to_release);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_message_pool_acquire-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_message_pool_acquire","text":"aws_message_pool_acquire(msg_pool, message_type, size_hint)\n\nAcquires a message from the pool if available, otherwise, it attempts to allocate. If a message is acquired, note that size_hint is just a hint. the return value's capacity will be set to the actual buffer size.\n\nPrototype\n\nstruct aws_io_message *aws_message_pool_acquire( struct aws_message_pool *msg_pool, enum aws_io_message_type message_type, size_t size_hint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_message_pool_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_message_pool_clean_up","text":"aws_message_pool_clean_up(msg_pool)\n\nPrototype\n\nvoid aws_message_pool_clean_up(struct aws_message_pool *msg_pool);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_message_pool_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_message_pool_init","text":"aws_message_pool_init(msg_pool, alloc, args)\n\nInitializes message pool using 'msg_pool' as the backing pool, 'args' is copied.\n\nPrototype\n\nint aws_message_pool_init( struct aws_message_pool *msg_pool, struct aws_allocator *alloc, struct aws_message_pool_creation_args *args);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_message_pool_release-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_message_pool_release","text":"aws_message_pool_release(msg_pool, message)\n\nReleases message to the pool if space is available, otherwise frees message\n\nParameters\n\nmessage:\n\nPrototype\n\nvoid aws_message_pool_release(struct aws_message_pool *msg_pool, struct aws_io_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_double-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_double","text":"aws_min_double(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL double aws_min_double(double a, double b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_float-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_float","text":"aws_min_float(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL float aws_min_float(float a, float b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_i16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_i16","text":"aws_min_i16(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int16_t aws_min_i16(int16_t a, int16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_i32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_i32","text":"aws_min_i32(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int32_t aws_min_i32(int32_t a, int32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_i64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_i64","text":"aws_min_i64(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int64_t aws_min_i64(int64_t a, int64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_i8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_i8","text":"aws_min_i8(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int8_t aws_min_i8(int8_t a, int8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_int-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_int","text":"aws_min_int(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL int aws_min_int(int a, int b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_size-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_size","text":"aws_min_size(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_min_size(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_u16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_u16","text":"aws_min_u16(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_min_u16(uint16_t a, uint16_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_u32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_u32","text":"aws_min_u32(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_min_u32(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_u64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_u64","text":"aws_min_u64(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_min_u64(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_min_u8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_min_u8","text":"aws_min_u8(a, b)\n\nPrototype\n\nAWS_STATIC_IMPL uint8_t aws_min_u8(uint8_t a, uint8_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_acquire","text":"aws_mqtt_client_acquire(client)\n\nIncrements the ref count to an mqtt client, allowing the caller to take a reference to it\n\nParameters\n\nclient:[in] The client to increment the ref count on\n\nReturns\n\nthe mqtt client\n\nPrototype\n\nstruct aws_mqtt_client *aws_mqtt_client_acquire(struct aws_mqtt_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_acquire","text":"aws_mqtt_client_connection_acquire(connection)\n\nIncrements the ref count to an mqtt client connection, allowing the caller to take a reference to it\n\nParameters\n\nconnection:[in] The connection object\n\nReturns\n\nthe mqtt connection\n\nPrototype\n\nstruct aws_mqtt_client_connection *aws_mqtt_client_connection_acquire(struct aws_mqtt_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_connect-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_connect","text":"aws_mqtt_client_connection_connect(connection, connection_options)\n\nOpens the actual connection defined by aws_mqtt_client_connection_new. Once the connection is opened, on_connack will be called. Only called when connection is disconnected.\n\nParameters\n\nconnection:[in] The connection object\nconnection_options:[in] Configuration information for the connection attempt\n\nReturns\n\nAWS_OP_SUCCESS if the connection has been successfully initiated, otherwise AWS_OP_ERR and aws_last_error() will be set.\n\nPrototype\n\nint aws_mqtt_client_connection_connect( struct aws_mqtt_client_connection *connection, const struct aws_mqtt_connection_options *connection_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_disconnect-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_disconnect","text":"aws_mqtt_client_connection_disconnect(connection, on_disconnect, userdata)\n\nCloses the connection asynchronously, calls the on_disconnect callback. All uncompleted requests (publish/subscribe/unsubscribe) will be cancelled, regardless to the status of clean_session. DISCONNECT packet will be sent, which deletes the will message from server.\n\nParameters\n\nconnection:[in] The connection to close\non_disconnect:[in] (nullable) Callback function to invoke when the connection is completely disconnected.\nuserdata:[in] (nullable) passed to on_disconnect\n\nReturns\n\nAWS_OP_SUCCESS if the connection is open and is being shutdown, otherwise AWS_OP_ERR and aws_last_error() is set.\n\nPrototype\n\nint aws_mqtt_client_connection_disconnect( struct aws_mqtt_client_connection *connection, aws_mqtt_client_on_disconnect_fn *on_disconnect, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_get_stats-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_get_stats","text":"aws_mqtt_client_connection_get_stats(connection, stats)\n\nQueries the connection's internal statistics for incomplete/unacked operations.\n\nParameters\n\nconnection: connection to get statistics for\nstats: set of incomplete/unacked operation statistics\n\nReturns\n\nAWS_OP_SUCCESS if getting the operation statistics were successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_mqtt_client_connection_get_stats( struct aws_mqtt_client_connection *connection, struct aws_mqtt_connection_operation_statistics *stats);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_new","text":"aws_mqtt_client_connection_new(client)\n\nSpawns a new connection object.\n\nParameters\n\nclient:[in] The client to spawn the connection from\n\nReturns\n\na new mqtt connection on success, NULL otherwise\n\nPrototype\n\nstruct aws_mqtt_client_connection *aws_mqtt_client_connection_new(struct aws_mqtt_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_publish-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_publish","text":"aws_mqtt_client_connection_publish(connection, topic, qos, retain, payload, on_complete, userdata)\n\nSend a PUBLISH packet over connection.\n\nParameters\n\nconnection:[in] The connection to publish on\ntopic:[in] The topic to publish on\nqos:[in] The requested QoS of the packet\nretain:[in] True to have the server save the packet, and send to all new subscriptions matching topic\npayload:[in] The data to send as the payload of the publish\non_complete:[in] (nullable) For QoS 0, called as soon as the packet is sent For QoS 1, called when PUBACK is received For QoS 2, called when PUBCOMP is received\nuser_data:[in] (nullable) Passed to on_complete\n\nReturns\n\nThe packet id of the publish packet if successfully sent, otherwise 0.\n\nPrototype\n\nuint16_t aws_mqtt_client_connection_publish( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *topic, enum aws_mqtt_qos qos, bool retain, const struct aws_byte_cursor *payload, aws_mqtt_op_complete_fn *on_complete, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_reconnect-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_reconnect","text":"aws_mqtt_client_connection_reconnect(connection, on_connection_complete, userdata)\n\nDEPRECATED Opens the actual connection defined by aws_mqtt_client_connection_new. Once the connection is opened, on_connack will be called.\n\nMust be called on a connection that has previously been open, as the parameters passed during the last connection will be reused.\n\nParameters\n\nconnection:[in] The connection object\non_connection_complete:[in] The callback to fire when the connection attempt completes\nuserdata:[in] (nullable) Passed to the userdata param of on_connection_complete\n\nReturns\n\nAWS_OP_SUCCESS if the connection has been successfully initiated, otherwise AWS_OP_ERR and aws_last_error() will be set.\n\nPrototype\n\nint aws_mqtt_client_connection_reconnect( struct aws_mqtt_client_connection *connection, aws_mqtt_client_on_connection_complete_fn *on_connection_complete, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_release","text":"aws_mqtt_client_connection_release(connection)\n\nDecrements the ref count on an mqtt connection. If the ref count drops to zero, the connection is cleaned up. Note: cannot call this with lock held, since it will start the destroy process and cause a dead lock.\n\nParameters\n\nconnection:[in] The connection object\n\nPrototype\n\nvoid aws_mqtt_client_connection_release(struct aws_mqtt_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_connection_closed_handler-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_connection_closed_handler","text":"aws_mqtt_client_connection_set_connection_closed_handler(connection, on_closed, on_closed_ud)\n\nSets the callback to call when the connection is closed normally by user request. This is different than the connection interrupted or lost, this only covers successful closure.\n\nParameters\n\nconnection:[in] The connection object\non_closed:[in] The function to call when a connection is closed\non_closed_ud:[in] Userdata for on_closed\n\nPrototype\n\nint aws_mqtt_client_connection_set_connection_closed_handler( struct aws_mqtt_client_connection *connection, aws_mqtt_client_on_connection_closed_fn *on_closed, void *on_closed_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_connection_interruption_handlers-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_connection_interruption_handlers","text":"aws_mqtt_client_connection_set_connection_interruption_handlers(connection, on_interrupted, on_interrupted_ud, on_resumed, on_resumed_ud)\n\nSets the callbacks to call when a connection is interrupted and resumed.\n\nParameters\n\nconnection:[in] The connection object\non_interrupted:[in] The function to call when a connection is lost\non_interrupted_ud:[in] Userdata for on_interrupted\non_resumed:[in] The function to call when a connection is resumed (if clean_session is true, calling aws_mqtt_resubscribe_existing_topics is suggested)\non_resumed_ud:[in] Userdata for on_resumed\n\nPrototype\n\nint aws_mqtt_client_connection_set_connection_interruption_handlers( struct aws_mqtt_client_connection *connection, aws_mqtt_client_on_connection_interrupted_fn *on_interrupted, void *on_interrupted_ud, aws_mqtt_client_on_connection_resumed_fn *on_resumed, void *on_resumed_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_host_resolution_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_host_resolution_options","text":"aws_mqtt_client_connection_set_host_resolution_options(connection, host_resolution_config)\n\nSet host resolution ooptions for the connection.\n\nPrototype\n\nint aws_mqtt_client_connection_set_host_resolution_options( struct aws_mqtt_client_connection *connection, struct aws_host_resolution_config *host_resolution_config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_http_proxy_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_http_proxy_options","text":"aws_mqtt_client_connection_set_http_proxy_options(connection, proxy_options)\n\nSet http proxy options for the connection.\n\nPrototype\n\nint aws_mqtt_client_connection_set_http_proxy_options( struct aws_mqtt_client_connection *connection, struct aws_http_proxy_options *proxy_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_login-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_login","text":"aws_mqtt_client_connection_set_login(connection, username, password)\n\nSets the username and/or password to send with the CONNECT packet.\n\nParameters\n\nconnection:[in] The connection object\nusername:[in] The username to connect with\npassword:[in] [optional] The password to connect with\n\nPrototype\n\nint aws_mqtt_client_connection_set_login( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *username, const struct aws_byte_cursor *password);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_on_any_publish_handler-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_on_any_publish_handler","text":"aws_mqtt_client_connection_set_on_any_publish_handler(connection, on_any_publish, on_any_publish_ud)\n\nSets the callback to call whenever ANY publish packet is received. Only safe to set when connection is not connected.\n\nParameters\n\nconnection:[in] The connection object\non_any_publish:[in] The function to call when a publish is received (pass NULL to unset)\non_any_publish_ud:[in] Userdata for on_any_publish\n\nPrototype\n\nint aws_mqtt_client_connection_set_on_any_publish_handler( struct aws_mqtt_client_connection *connection, aws_mqtt_client_publish_received_fn *on_any_publish, void *on_any_publish_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_reconnect_timeout-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_reconnect_timeout","text":"aws_mqtt_client_connection_set_reconnect_timeout(connection, min_timeout, max_timeout)\n\nSets the minimum and maximum reconnect timeouts.\n\nThe time between reconnect attempts will start at min and multiply by 2 until max is reached.\n\nParameters\n\nconnection:[in] The connection object\nmin_timeout:[in] The timeout to start with\nmax_timeout:[in] The highest allowable wait time between reconnect attempts\n\nPrototype\n\nint aws_mqtt_client_connection_set_reconnect_timeout( struct aws_mqtt_client_connection *connection, uint64_t min_timeout, uint64_t max_timeout);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_set_will-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_set_will","text":"aws_mqtt_client_connection_set_will(connection, topic, qos, retain, payload)\n\nSets the will message to send with the CONNECT packet.\n\nParameters\n\nconnection:[in] The connection object\ntopic:[in] The topic to publish the will on\nqos:[in] The QoS to publish the will with\nretain:[in] The retain flag to publish the will with\npayload:[in] The data if the will message\n\nPrototype\n\nint aws_mqtt_client_connection_set_will( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *topic, enum aws_mqtt_qos qos, bool retain, const struct aws_byte_cursor *payload);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_subscribe-NTuple{8, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_subscribe","text":"aws_mqtt_client_connection_subscribe(connection, topic_filter, qos, on_publish, on_publish_ud, on_ud_cleanup, on_suback, on_suback_ud)\n\nSubscribe to a single topic filter. on_publish will be called when a PUBLISH matching topic_filter is received.\n\nParameters\n\nconnection:[in] The connection to subscribe on\ntopic_filter:[in] The topic filter to subscribe on. This resource must persist until on_suback.\nqos:[in] The maximum QoS of messages to receive\non_publish:[in] (nullable) Called when a PUBLISH packet matching topic_filter is received\non_publish_ud:[in] (nullable) Passed to on_publish\non_ud_cleanup:[in] (nullable) Called when a subscription is removed, on_publish_ud is passed.\non_suback:[in] (nullable) Called when a SUBACK has been received from the server and the subscription is complete\non_suback_ud:[in] (nullable) Passed to on_suback\n\nReturns\n\nThe packet id of the subscribe packet if successfully sent, otherwise 0.\n\nPrototype\n\nuint16_t aws_mqtt_client_connection_subscribe( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *topic_filter, enum aws_mqtt_qos qos, aws_mqtt_client_publish_received_fn *on_publish, void *on_publish_ud, aws_mqtt_userdata_cleanup_fn *on_ud_cleanup, aws_mqtt_suback_fn *on_suback, void *on_suback_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_subscribe_local-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_subscribe_local","text":"aws_mqtt_client_connection_subscribe_local(connection, topic_filter, on_publish, on_publish_ud, on_ud_cleanup, on_suback, on_suback_ud)\n\nSubscribe to a single topic filter WITHOUT sending a SUBSCRIBE packet. This is useful if you expect the broker to send PUBLISHES without first subscribing. on_publish will be called when a PUBLISH matching topic_filter is received.\n\nParameters\n\nconnection:[in] The connection to subscribe on\ntopic_filter:[in] The topic filter to subscribe on. This resource must persist until on_suback.\non_publish:[in] (nullable) Called when a PUBLISH packet matching topic_filter is received\non_publish_ud:[in] (nullable) Passed to on_publish\non_ud_cleanup:[in] (nullable) Called when a subscription is removed, on_publish_ud is passed.\non_suback:[in] (nullable) Called when a SUBACK has been received from the server and the subscription is complete\non_suback_ud:[in] (nullable) Passed to on_suback\n\nReturns\n\nThe \"packet id\" of the operation if successfully initiated, otherwise 0.\n\nPrototype\n\nuint16_t aws_mqtt_client_connection_subscribe_local( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *topic_filter, aws_mqtt_client_publish_received_fn *on_publish, void *on_publish_ud, aws_mqtt_userdata_cleanup_fn *on_ud_cleanup, aws_mqtt_suback_fn *on_suback, void *on_suback_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_subscribe_multiple-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_subscribe_multiple","text":"aws_mqtt_client_connection_subscribe_multiple(connection, topic_filters, on_suback, on_suback_ud)\n\nSubscribe to topic filters. on_publish will be called when a PUBLISH matching each topic_filter is received.\n\nParameters\n\nconnection:[in] The connection to subscribe on\ntopic_filters:[in] An array_list of aws_mqtt_topic_subscription (NOT pointers) describing the requests.\non_suback:[in] (nullable) Called when a SUBACK has been received from the server and the subscription is complete. Broker may fail one of the topics, check the qos in aws_mqtt_topic_subscription from the callback\non_suback_ud:[in] (nullable) Passed to on_suback\n\nReturns\n\nThe packet id of the subscribe packet if successfully sent, otherwise 0.\n\nPrototype\n\nuint16_t aws_mqtt_client_connection_subscribe_multiple( struct aws_mqtt_client_connection *connection, const struct aws_array_list *topic_filters, aws_mqtt_suback_multi_fn *on_suback, void *on_suback_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_unsubscribe-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_unsubscribe","text":"aws_mqtt_client_connection_unsubscribe(connection, topic_filter, on_unsuback, on_unsuback_ud)\n\nUnsubscribe to a topic filter.\n\nParameters\n\nconnection:[in] The connection to unsubscribe on\ntopic_filter:[in] The topic filter to unsubscribe on. This resource must persist until on_unsuback.\non_unsuback:[in] (nullable) Called when a UNSUBACK has been received from the server and the subscription is removed\non_unsuback_ud:[in] (nullable) Passed to on_unsuback\n\nReturns\n\nThe packet id of the unsubscribe packet if successfully sent, otherwise 0.\n\nPrototype\n\nuint16_t aws_mqtt_client_connection_unsubscribe( struct aws_mqtt_client_connection *connection, const struct aws_byte_cursor *topic_filter, aws_mqtt_op_complete_fn *on_unsuback, void *on_unsuback_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_connection_use_websockets-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_connection_use_websockets","text":"aws_mqtt_client_connection_use_websockets(connection, transformer, transformer_ud, validator, validator_ud)\n\nUse MQTT over websockets when connecting. Requires the MQTT_WITH_WEBSOCKETS build option.\n\nIn this scenario, an HTTP connection is established, which is then upgraded to a websocket connection, which is then used to send MQTT data.\n\nParameters\n\nconnection:[in] The connection object.\ntransformer:[in] [optional] Function that may transform the websocket handshake request. See aws_mqtt_transform_websocket_handshake_fn for more info.\ntransformer_ud:[in] [optional] Userdata for request_transformer.\nvalidator:[in] [optional] Function that may reject the websocket handshake response.\nvalidator_ud:[in] [optional] Userdata for response_validator.\n\nPrototype\n\nint aws_mqtt_client_connection_use_websockets( struct aws_mqtt_client_connection *connection, aws_mqtt_transform_websocket_handshake_fn *transformer, void *transformer_ud, aws_mqtt_validate_websocket_handshake_fn *validator, void *validator_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_new","text":"aws_mqtt_client_new(allocator, bootstrap)\n\nCreates an instance of aws_mqtt_client.\n\nParameters\n\nallocator:[in] The allocator the client will use for all future allocations\nbootstrap:[in] The client bootstrap to use to initiate new socket connections\n\nReturns\n\na new instance of an aws_mqtt_client if successful, NULL otherwise\n\nPrototype\n\nstruct aws_mqtt_client *aws_mqtt_client_new(struct aws_allocator *allocator, struct aws_client_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_client_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_client_release","text":"aws_mqtt_client_release(client)\n\nDecrements the ref count on an mqtt client. If the ref count drops to zero, the client is cleaned up.\n\nParameters\n\nclient:[in] The client to release a ref count on\n\nPrototype\n\nvoid aws_mqtt_client_release(struct aws_mqtt_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_fatal_assert_library_initialized-Tuple{}","page":"Home","title":"LibAWSCRT.aws_mqtt_fatal_assert_library_initialized","text":"aws_mqtt_fatal_assert_library_initialized()\n\nPrototype\n\nvoid aws_mqtt_fatal_assert_library_initialized(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_is_valid_topic-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_is_valid_topic","text":"aws_mqtt_is_valid_topic(topic)\n\nPrototype\n\nbool aws_mqtt_is_valid_topic(const struct aws_byte_cursor *topic);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_is_valid_topic_filter-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_is_valid_topic_filter","text":"aws_mqtt_is_valid_topic_filter(topic_filter)\n\nPrototype\n\nbool aws_mqtt_is_valid_topic_filter(const struct aws_byte_cursor *topic_filter);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_mqtt_library_clean_up","text":"aws_mqtt_library_clean_up()\n\nShuts down the internal datastructures used by aws-c-mqtt.\n\nPrototype\n\nvoid aws_mqtt_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_library_init","text":"aws_mqtt_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-mqtt. Must be called before using any functionality in aws-c-mqtt.\n\nPrototype\n\nvoid aws_mqtt_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mqtt_resubscribe_existing_topics-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mqtt_resubscribe_existing_topics","text":"aws_mqtt_resubscribe_existing_topics(connection, on_suback, on_suback_ud)\n\nResubscribe to all topics currently subscribed to. This is to help when resuming a connection with a clean session.\n\nParameters\n\nconnection:[in] The connection to subscribe on\non_suback:[in] (nullable) Called when a SUBACK has been received from the server and the subscription is complete\non_suback_ud:[in] (nullable) Passed to on_suback\n\nReturns\n\nThe packet id of the subscribe packet if successfully sent, otherwise 0 (and aws_last_error() will be set).\n\nPrototype\n\nuint16_t aws_mqtt_resubscribe_existing_topics( struct aws_mqtt_client_connection *connection, aws_mqtt_suback_multi_fn *on_suback, void *on_suback_ud);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_size_checked","text":"aws_mul_size_checked(a, b, r)\n\nMultiplies a * b and returns the result in *r. If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_size_saturating","text":"aws_mul_size_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns SIZE_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_mul_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_u32_checked","text":"aws_mul_u32_checked(a, b, r)\n\nIf a * b overflows, returns AWS_OP_ERR; otherwise multiplies a * b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_u32_saturating","text":"aws_mul_u32_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns 2^32 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_mul_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_u64_checked","text":"aws_mul_u64_checked(a, b, r)\n\nIf a * b overflows, returns AWS_OP_ERR; otherwise multiplies a * b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_mul_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mul_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_mul_u64_saturating","text":"aws_mul_u64_saturating(a, b)\n\nMultiplies a * b. If the result overflows, returns 2^64 - 1.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_mul_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mutex_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mutex_clean_up","text":"aws_mutex_clean_up(mutex)\n\nCleans up internal resources.\n\nPrototype\n\nvoid aws_mutex_clean_up(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mutex_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mutex_init","text":"aws_mutex_init(mutex)\n\nInitializes a new platform instance of mutex.\n\nPrototype\n\nint aws_mutex_init(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mutex_lock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mutex_lock","text":"aws_mutex_lock(mutex)\n\nBlocks until it acquires the lock. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n\nPrototype\n\nint aws_mutex_lock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mutex_try_lock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mutex_try_lock","text":"aws_mutex_try_lock(mutex)\n\nAttempts to acquire the lock but returns immediately if it can not. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be. Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]\n\nPrototype\n\nint aws_mutex_try_lock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_mutex_unlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_mutex_unlock","text":"aws_mutex_unlock(mutex)\n\nReleases the lock.\n\nPrototype\n\nint aws_mutex_unlock(struct aws_mutex *mutex);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_normalize_directory_separator-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_normalize_directory_separator","text":"aws_normalize_directory_separator(path)\n\nNormalizes the path by replacing any directory separator with the local platform's directory separator.\n\nParameters\n\npath: path to normalize. Must be writeable.\n\nPrototype\n\nvoid aws_normalize_directory_separator(struct aws_byte_buf *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ntoh16-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ntoh16","text":"aws_ntoh16(x)\n\nConvert 16 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_ntoh16(uint16_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ntoh32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ntoh32","text":"aws_ntoh32(x)\n\nConvert 32 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_ntoh32(uint32_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ntoh64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ntoh64","text":"aws_ntoh64(x)\n\nConvert 64 bit integer from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_ntoh64(uint64_t x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ntohf32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ntohf32","text":"aws_ntohf32(x)\n\nConvert 32 bit float from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL float aws_ntohf32(float x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ntohf64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ntohf64","text":"aws_ntohf64(x)\n\nConvert 32 bit float from network to host byte order.\n\nPrototype\n\nAWS_STATIC_IMPL double aws_ntohf64(double x);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_partitions_config_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_partitions_config_acquire","text":"aws_partitions_config_acquire(partitions)\n\nPrototype\n\nstruct aws_partitions_config *aws_partitions_config_acquire(struct aws_partitions_config *partitions);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_partitions_config_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_partitions_config_new_from_string","text":"aws_partitions_config_new_from_string(allocator, json)\n\nPrototype\n\nstruct aws_partitions_config *aws_partitions_config_new_from_string( struct aws_allocator *allocator, struct aws_byte_cursor json);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_partitions_config_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_partitions_config_release","text":"aws_partitions_config_release(partitions)\n\nPrototype\n\nstruct aws_partitions_config *aws_partitions_config_release(struct aws_partitions_config *partitions);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_partitions_get_supported_version-Tuple{}","page":"Home","title":"LibAWSCRT.aws_partitions_get_supported_version","text":"aws_partitions_get_supported_version()\n\nPrototype\n\nstruct aws_byte_cursor aws_partitions_get_supported_version(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_path_exists-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_path_exists","text":"aws_path_exists(path)\n\nReturns true if a file or path exists, otherwise, false.\n\nPrototype\n\nbool aws_path_exists(const struct aws_string *path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_clean_up_read_end-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pipe_clean_up_read_end","text":"aws_pipe_clean_up_read_end(read_end)\n\nClean up the read-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_clean_up_read_end(struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_clean_up_write_end-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pipe_clean_up_write_end","text":"aws_pipe_clean_up_write_end(write_end)\n\nClean up the write-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_clean_up_write_end(struct aws_pipe_write_end *write_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_get_read_end_event_loop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pipe_get_read_end_event_loop","text":"aws_pipe_get_read_end_event_loop(read_end)\n\nGet the event-loop connected to the read-end of the pipe. This may be called on any thread.\n\nPrototype\n\nstruct aws_event_loop *aws_pipe_get_read_end_event_loop(const struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_get_write_end_event_loop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pipe_get_write_end_event_loop","text":"aws_pipe_get_write_end_event_loop(write_end)\n\nGet the event-loop connected to the write-end of the pipe. This may be called on any thread.\n\nPrototype\n\nstruct aws_event_loop *aws_pipe_get_write_end_event_loop(const struct aws_pipe_write_end *write_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_init-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_pipe_init","text":"aws_pipe_init(read_end, read_end_event_loop, write_end, write_end_event_loop, allocator)\n\nOpens an OS specific bidirectional pipe. The read direction is stored in read_end. Write direction is stored in write_end. Each end must be connected to an event-loop, and further calls to each end must happen on that event-loop's thread.\n\nPrototype\n\nint aws_pipe_init( struct aws_pipe_read_end *read_end, struct aws_event_loop *read_end_event_loop, struct aws_pipe_write_end *write_end, struct aws_event_loop *write_end_event_loop, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_pipe_read","text":"aws_pipe_read(read_end, dst_buffer, num_bytes_read)\n\nRead data from the pipe into the destination buffer. Attempts to read enough to fill all remaining space in the buffer, from dst\\_buffer->len to dst\\_buffer->capacity. dst\\_buffer->len is updated to reflect the buffer's new length. num_bytes_read (optional) is set to the total number of bytes read. This function never blocks. If no bytes could be read without blocking, then AWS_OP_ERR is returned and aws_last_error() code will be AWS_IO_READ_WOULD_BLOCK. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_read(struct aws_pipe_read_end *read_end, struct aws_byte_buf *dst_buffer, size_t *num_bytes_read);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_subscribe_to_readable_events-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_pipe_subscribe_to_readable_events","text":"aws_pipe_subscribe_to_readable_events(read_end, on_readable, user_data)\n\nSubscribe to be notified when the pipe becomes readable (edge-triggered), or an error occurs. on_readable is invoked on the event-loop's thread when the pipe has data to read, or the pipe has an error. on_readable is invoked again any time the user reads all data, and then more data arrives. Note that it will not be invoked again if the pipe still has unread data when more data arrives. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_subscribe_to_readable_events( struct aws_pipe_read_end *read_end, aws_pipe_on_readable_fn *on_readable, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_unsubscribe_from_readable_events-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pipe_unsubscribe_from_readable_events","text":"aws_pipe_unsubscribe_from_readable_events(read_end)\n\nStop receiving notifications about events on the read-end of the pipe. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_unsubscribe_from_readable_events(struct aws_pipe_read_end *read_end);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pipe_write-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_pipe_write","text":"aws_pipe_write(write_end, src_buffer, on_completed, user_data)\n\nInitiates an asynchrous write from the source buffer to the pipe. The data referenced by src_buffer must remain in memory until the operation completes. on_complete is called on the event-loop thread when the operation has either completed or failed. The callback's pipe argument will be NULL if the callback is invoked after the pipe has been cleaned up. This must be called on the thread of the connected event-loop.\n\nPrototype\n\nint aws_pipe_write( struct aws_pipe_write_end *write_end, struct aws_byte_cursor src_buffer, aws_pipe_on_write_completed_fn *on_completed, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pkcs11_lib_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pkcs11_lib_acquire","text":"aws_pkcs11_lib_acquire(pkcs11_lib)\n\nAcquire a reference to a PKCS#11 library, preventing it from being cleaned up. You must call aws_pkcs11_lib_release() when you are done with it. This function returns whatever was passed in. It cannot fail.\n\nPrototype\n\nstruct aws_pkcs11_lib *aws_pkcs11_lib_acquire(struct aws_pkcs11_lib *pkcs11_lib);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pkcs11_lib_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_pkcs11_lib_new","text":"aws_pkcs11_lib_new(allocator, options)\n\nLoad and initialize a PKCS#11 library. See aws_pkcs11_lib_options for options.\n\nIf successful a valid pointer is returned. You must call aws_pkcs11_lib_release() when you are done with it. If unsuccessful, NULL is returned and an error is set.\n\nPrototype\n\nstruct aws_pkcs11_lib *aws_pkcs11_lib_new( struct aws_allocator *allocator, const struct aws_pkcs11_lib_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_pkcs11_lib_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_pkcs11_lib_release","text":"aws_pkcs11_lib_release(pkcs11_lib)\n\nRelease a reference to the PKCS#11 library. When the last reference is released, the library is cleaned up.\n\nPrototype\n\nvoid aws_pkcs11_lib_release(struct aws_pkcs11_lib *pkcs11_lib);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_backpointer_index_valid-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_backpointer_index_valid","text":"aws_priority_queue_backpointer_index_valid(queue, index)\n\nChecks that the backpointer at a specific index of the queue is NULL or points to a correctly allocated aws_priority_queue_node.\n\nPrototype\n\nbool aws_priority_queue_backpointer_index_valid(const struct aws_priority_queue *const queue, size_t index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_backpointers_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_backpointers_valid","text":"aws_priority_queue_backpointers_valid(queue)\n\nChecks that the backpointers of the priority queue satisfy validity constraints.\n\nPrototype\n\nbool aws_priority_queue_backpointers_valid(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_backpointers_valid_deep-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_backpointers_valid_deep","text":"aws_priority_queue_backpointers_valid_deep(queue)\n\nChecks that the backpointers of the priority queue are either NULL or correctly allocated to point at aws_priority_queue_nodes. This check is O(n), as it accesses every backpointer in a loop, and thus shouldn't be used carelessly.\n\nPrototype\n\nbool aws_priority_queue_backpointers_valid_deep(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_capacity-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_capacity","text":"aws_priority_queue_capacity(queue)\n\nCurrent allocated capacity for the queue, in dynamic mode this grows over time, in static mode, this will never change.\n\nPrototype\n\nsize_t aws_priority_queue_capacity(const struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_clean_up","text":"aws_priority_queue_clean_up(queue)\n\nCleans up any internally allocated memory and resets the struct for reuse or deletion.\n\nPrototype\n\nvoid aws_priority_queue_clean_up(struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_init_dynamic-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_init_dynamic","text":"aws_priority_queue_init_dynamic(queue, alloc, default_size, item_size, pred)\n\nInitializes a priority queue struct for use. This mode will grow memory automatically (exponential model) Default size is the inital size of the queue item_size is the size of each element in bytes. Mixing items types is not supported by this API. pred is the function that will be used to determine priority.\n\nPrototype\n\nint aws_priority_queue_init_dynamic( struct aws_priority_queue *queue, struct aws_allocator *alloc, size_t default_size, size_t item_size, aws_priority_queue_compare_fn *pred);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_init_static-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_init_static","text":"aws_priority_queue_init_static(queue, heap, item_count, item_size, pred)\n\nInitializes a priority queue struct for use. This mode will not allocate any additional memory. When the heap fills new enqueue operations will fail with AWS_ERROR_PRIORITY_QUEUE_FULL.\n\nHeaps initialized using this call do not support the aws_priority_queue_push_ref call with a non-NULL backpointer parameter.\n\nheap is the raw memory allocated for this priority_queue item_count is the maximum number of elements the raw heap can contain item_size is the size of each element in bytes. Mixing items types is not supported by this API. pred is the function that will be used to determine priority.\n\nPrototype\n\nvoid aws_priority_queue_init_static( struct aws_priority_queue *queue, void *heap, size_t item_count, size_t item_size, aws_priority_queue_compare_fn *pred);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_is_valid","text":"aws_priority_queue_is_valid(queue)\n\nSet of properties of a valid aws_priority_queue.\n\nPrototype\n\nbool aws_priority_queue_is_valid(const struct aws_priority_queue *const queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_pop-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_pop","text":"aws_priority_queue_pop(queue, item)\n\nCopies the element of the highest priority, and removes it from the queue.. Complexity: O(log(n)). If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised.\n\nPrototype\n\nint aws_priority_queue_pop(struct aws_priority_queue *queue, void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_push-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_push","text":"aws_priority_queue_push(queue, item)\n\nCopies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\nPrototype\n\nint aws_priority_queue_push(struct aws_priority_queue *queue, void *item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_push_ref-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_push_ref","text":"aws_priority_queue_push_ref(queue, item, backpointer)\n\nCopies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\nIf the backpointer parameter is non-null, the heap will continually update the pointed-to field with information needed to remove the node later on. *backpointer must remain valid until the node is removed from the heap, and may be updated on any mutating operation on the priority queue.\n\nIf the node is removed, the backpointer will be set to a sentinel value that indicates that the node has already been removed. It is safe (and a no-op) to call aws_priority_queue_remove with such a sentinel value.\n\nPrototype\n\nint aws_priority_queue_push_ref( struct aws_priority_queue *queue, void *item, struct aws_priority_queue_node *backpointer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_remove-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_remove","text":"aws_priority_queue_remove(queue, item, node)\n\nRemoves a specific node from the priority queue. Complexity: O(log(n)) After removing a node (using either _remove or _pop), the backpointer set at push_ref time is set to a sentinel value. If this sentinel value is passed to aws_priority_queue_remove, AWS_ERROR_PRIORITY_QUEUE_BAD_NODE will be raised. Note, however, that passing uninitialized aws_priority_queue_nodes, or ones from different priority queues, results in undefined behavior.\n\nPrototype\n\nint aws_priority_queue_remove(struct aws_priority_queue *queue, void *item, const struct aws_priority_queue_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_size","text":"aws_priority_queue_size(queue)\n\nCurrent number of elements in the queue\n\nPrototype\n\nsize_t aws_priority_queue_size(const struct aws_priority_queue *queue);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_priority_queue_top-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_priority_queue_top","text":"aws_priority_queue_top(queue, item)\n\nObtains a pointer to the element of the highest priority. Complexity: constant time. If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised.\n\nPrototype\n\nint aws_priority_queue_top(const struct aws_priority_queue *queue, void **item);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_acquire","text":"aws_profile_collection_acquire(collection)\n\nIncrements the reference count on the profile collection, allowing the caller to take a reference to it.\n\nReturns the same profile collection passed in.\n\nPrototype\n\nstruct aws_profile_collection *aws_profile_collection_acquire(struct aws_profile_collection *collection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_destroy","text":"aws_profile_collection_destroy(profile_collection)\n\n\\deprecated This is equivalent to aws_profile_collection_release.\n\nPrototype\n\nvoid aws_profile_collection_destroy(struct aws_profile_collection *profile_collection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_get_profile-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_get_profile","text":"aws_profile_collection_get_profile(profile_collection, profile_name)\n\nRetrieves a reference to a profile with the specified name, if it exists, from the profile collection\n\nPrototype\n\nconst struct aws_profile *aws_profile_collection_get_profile( const struct aws_profile_collection *profile_collection, const struct aws_string *profile_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_get_profile_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_get_profile_count","text":"aws_profile_collection_get_profile_count(profile_collection)\n\nReturns the number of profiles in a collection\n\nPrototype\n\nsize_t aws_profile_collection_get_profile_count(const struct aws_profile_collection *profile_collection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_get_section-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_get_section","text":"aws_profile_collection_get_section(profile_collection, section_type, section_name)\n\nPrototype\n\nconst struct aws_profile *aws_profile_collection_get_section( const struct aws_profile_collection *profile_collection, const enum aws_profile_section_type section_type, const struct aws_string *section_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_get_section_count-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_get_section_count","text":"aws_profile_collection_get_section_count(profile_collection, section_type)\n\nReturns the number of elements of the specified section in a collection.\n\nPrototype\n\nsize_t aws_profile_collection_get_section_count( const struct aws_profile_collection *profile_collection, const enum aws_profile_section_type section_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_new_from_buffer-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_new_from_buffer","text":"aws_profile_collection_new_from_buffer(allocator, buffer, source)\n\nCreate a new profile collection by parsing text in a buffer. Primarily for testing.\n\nPrototype\n\nstruct aws_profile_collection *aws_profile_collection_new_from_buffer( struct aws_allocator *allocator, const struct aws_byte_buf *buffer, enum aws_profile_source_type source);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_new_from_file-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_new_from_file","text":"aws_profile_collection_new_from_file(allocator, file_path, source)\n\nCreate a new profile collection by parsing a file with the specified path\n\nPrototype\n\nstruct aws_profile_collection *aws_profile_collection_new_from_file( struct aws_allocator *allocator, const struct aws_string *file_path, enum aws_profile_source_type source);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_new_from_merge-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_new_from_merge","text":"aws_profile_collection_new_from_merge(allocator, config_profiles, credentials_profiles)\n\nCreate a new profile collection by merging a config-file-based profile collection and a credentials-file-based profile collection\n\nPrototype\n\nstruct aws_profile_collection *aws_profile_collection_new_from_merge( struct aws_allocator *allocator, const struct aws_profile_collection *config_profiles, const struct aws_profile_collection *credentials_profiles);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_collection_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_collection_release","text":"aws_profile_collection_release(collection)\n\nDecrements a profile collection's ref count. When the ref count drops to zero, the collection will be destroyed. Returns NULL.\n\nPrototype\n\nstruct aws_profile_collection *aws_profile_collection_release(struct aws_profile_collection *collection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_get_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_get_name","text":"aws_profile_get_name(profile)\n\nReturns a reference to the name of the provided profile\n\nPrototype\n\nconst struct aws_string *aws_profile_get_name(const struct aws_profile *profile);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_get_property-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_get_property","text":"aws_profile_get_property(profile, property_name)\n\nRetrieves a reference to a property with the specified name, if it exists, from a profile\n\nPrototype\n\nconst struct aws_profile_property *aws_profile_get_property( const struct aws_profile *profile, const struct aws_string *property_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_get_property_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_get_property_count","text":"aws_profile_get_property_count(profile)\n\nReturns how many properties a profile holds\n\nPrototype\n\nsize_t aws_profile_get_property_count(const struct aws_profile *profile);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_property_get_sub_property-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_profile_property_get_sub_property","text":"aws_profile_property_get_sub_property(property, sub_property_name)\n\nReturns a reference to the value of a sub property with the given name, if it exists, in the property\n\nPrototype\n\nconst struct aws_string *aws_profile_property_get_sub_property( const struct aws_profile_property *property, const struct aws_string *sub_property_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_property_get_sub_property_count-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_property_get_sub_property_count","text":"aws_profile_property_get_sub_property_count(property)\n\nReturns how many sub properties the property holds\n\nPrototype\n\nsize_t aws_profile_property_get_sub_property_count(const struct aws_profile_property *property);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_profile_property_get_value-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_profile_property_get_value","text":"aws_profile_property_get_value(property)\n\nReturns a reference to the property's string value\n\nPrototype\n\nconst struct aws_string *aws_profile_property_get_value(const struct aws_profile_property *property);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_acquire","text":"aws_promise_acquire(promise)\n\nPrototype\n\nstruct aws_promise *aws_promise_acquire(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_complete-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_promise_complete","text":"aws_promise_complete(promise, value, dtor)\n\nPrototype\n\nvoid aws_promise_complete(struct aws_promise *promise, void *value, void (*dtor)(void *));\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_error_code-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_error_code","text":"aws_promise_error_code(promise)\n\nPrototype\n\nint aws_promise_error_code(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_fail-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_promise_fail","text":"aws_promise_fail(promise, error_code)\n\nPrototype\n\nvoid aws_promise_fail(struct aws_promise *promise, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_is_complete-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_is_complete","text":"aws_promise_is_complete(promise)\n\nPrototype\n\nbool aws_promise_is_complete(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_new","text":"aws_promise_new(allocator)\n\nPrototype\n\nstruct aws_promise *aws_promise_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_release","text":"aws_promise_release(promise)\n\nPrototype\n\nvoid aws_promise_release(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_take_value-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_take_value","text":"aws_promise_take_value(promise)\n\nPrototype\n\nvoid *aws_promise_take_value(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_value-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_value","text":"aws_promise_value(promise)\n\nPrototype\n\nvoid *aws_promise_value(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_wait-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_promise_wait","text":"aws_promise_wait(promise)\n\nPrototype\n\nvoid aws_promise_wait(struct aws_promise *promise);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_promise_wait_for-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_promise_wait_for","text":"aws_promise_wait_for(promise, nanoseconds)\n\nPrototype\n\nbool aws_promise_wait_for(struct aws_promise *promise, size_t nanoseconds);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ptr_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ptr_eq","text":"aws_ptr_eq(a, b)\n\nEquality function which compares pointer equality.\n\nPrototype\n\nbool aws_ptr_eq(const void *a, const void *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_raise_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_raise_error","text":"aws_raise_error(err)\n\nPrototype\n\nAWS_STATIC_IMPL int aws_raise_error(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_raise_error_private-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_raise_error_private","text":"aws_raise_error_private(err)\n\nPrototype\n\nvoid aws_raise_error_private(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_read_u16-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_read_u16","text":"aws_read_u16(buffer)\n\nPrototype\n\nAWS_STATIC_IMPL uint16_t aws_read_u16(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_read_u24-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_read_u24","text":"aws_read_u24(buffer)\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_read_u24(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_read_u32-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_read_u32","text":"aws_read_u32(buffer)\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_read_u32(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_read_u64-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_read_u64","text":"aws_read_u64(buffer)\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_read_u64(const uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ref_count_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ref_count_acquire","text":"aws_ref_count_acquire(ref_count)\n\nIncrements a ref-counter's ref count\n\nParameters\n\nref_count: ref-counter to increment the count for\n\nReturns\n\nthe object being ref-counted\n\nPrototype\n\nvoid *aws_ref_count_acquire(struct aws_ref_count *ref_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ref_count_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ref_count_init","text":"aws_ref_count_init(ref_count, object, on_zero_fn)\n\nInitializes a ref-counter structure. After initialization, the ref count will be 1.\n\nParameters\n\nref_count: ref-counter to initialize\nobject: object being ref counted\non_zero_fn: function to invoke when the ref count reaches zero\n\nPrototype\n\nvoid aws_ref_count_init( struct aws_ref_count *ref_count, void *object, aws_simple_completion_callback *on_zero_fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ref_count_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ref_count_release","text":"aws_ref_count_release(ref_count)\n\nDecrements a ref-counter's ref count. Invokes the on_zero callback if the ref count drops to zero\n\nParameters\n\nref_count: ref-counter to decrement the count for\n\nReturns\n\nthe value of the decremented ref count\n\nPrototype\n\nsize_t aws_ref_count_release(struct aws_ref_count *ref_count);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_register_error_info-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_register_error_info","text":"aws_register_error_info(error_info)\n\nTODO: this needs to be a private function (wait till we have the cmake story better before moving it though). It should be external for the purpose of other libs we own, but customers should not be able to hit it without going out of their way to do so.\n\nPrototype\n\nvoid aws_register_error_info(const struct aws_error_info_list *error_info);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_register_log_subject_info_list-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_register_log_subject_info_list","text":"aws_register_log_subject_info_list(log_subject_list)\n\nConnects log subject strings with log subject integer values\n\nPrototype\n\nvoid aws_register_log_subject_info_list(struct aws_log_subject_info_list *log_subject_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_reset_error-Tuple{}","page":"Home","title":"LibAWSCRT.aws_reset_error","text":"aws_reset_error()\n\nPrototype\n\nvoid aws_reset_error(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_resource_name_init_from_cur-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_resource_name_init_from_cur","text":"aws_resource_name_init_from_cur(arn, input)\n\nGiven an ARN \"Amazon Resource Name\" represented as an in memory a structure representing the parts\n\nPrototype\n\nint aws_resource_name_init_from_cur(struct aws_resource_name *arn, const struct aws_byte_cursor *input);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_resource_name_length-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_resource_name_length","text":"aws_resource_name_length(arn, size)\n\nCalculates the space needed to write an ARN to a byte buf\n\nPrototype\n\nint aws_resource_name_length(const struct aws_resource_name *arn, size_t *size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_restore_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_restore_error","text":"aws_restore_error(err)\n\nPrototype\n\nvoid aws_restore_error(int err);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_acquire","text":"aws_retry_strategy_acquire(retry_strategy)\n\nAcquire a reference count on retry_strategy.\n\nPrototype\n\nvoid aws_retry_strategy_acquire(struct aws_retry_strategy *retry_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_acquire_retry_token-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_acquire_retry_token","text":"aws_retry_strategy_acquire_retry_token(retry_strategy, partition_id, on_acquired, user_data, timeout_ms)\n\nAttempts to acquire a retry token for use with retries. On success, on_acquired will be invoked when a token is available, or an error will be returned if the timeout expires. partition_id identifies operations that should be grouped together. This allows for more sophisticated strategies such as AIMD and circuit breaker patterns. Pass NULL to use the global partition.\n\nPrototype\n\nint aws_retry_strategy_acquire_retry_token( struct aws_retry_strategy *retry_strategy, const struct aws_byte_cursor *partition_id, aws_retry_strategy_on_retry_token_acquired_fn *on_acquired, void *user_data, uint64_t timeout_ms);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_new_exponential_backoff-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_new_exponential_backoff","text":"aws_retry_strategy_new_exponential_backoff(allocator, config)\n\nCreates a retry strategy using exponential backoff. This strategy does not perform any bookkeeping on error types and success. There is no circuit breaker functionality in here. See the comments above for aws_exponential_backoff_retry_options.\n\nPrototype\n\nstruct aws_retry_strategy *aws_retry_strategy_new_exponential_backoff( struct aws_allocator *allocator, const struct aws_exponential_backoff_retry_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_new_standard-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_new_standard","text":"aws_retry_strategy_new_standard(allocator, config)\n\nThis is a retry implementation that cuts off traffic if it's detected that an endpoint partition is having availability problems. This is necessary to keep from making outages worse by scheduling work that's unlikely to succeed yet increases load on an already ailing system.\n\nWe do this by creating a bucket for each partition. A partition is an arbitrary specifier. It can be anything: a region, a service, a combination of region and service, a literal dns name.... doesn't matter.\n\nEach bucket has a budget for maximum allowed retries. Different types of events carry different weights. Things that indicate an unhealthy partition such as transient errors (timeouts, unhealthy connection etc...) cost more. A retry for any other reason (service sending a 5xx response code) cost a bit less. When a retry is attempted this capacity is leased out to the retry. On success it is released back to the capacity pool. On failure, it remains leased. Operations that succeed without a retry slowly restore the capacity pool.\n\nIf a partition runs out of capacity it is assumed unhealthy and retries will be blocked until capacity returns to the pool. To prevent a partition from staying unhealthy after an outage has recovered, new requests that succeed without a retry will increase the capacity slowly ( a new request gets a payback lease of 1, but the lease is never actually deducted from the capacity pool).\n\nPrototype\n\nstruct aws_retry_strategy *aws_retry_strategy_new_standard( struct aws_allocator *allocator, const struct aws_standard_retry_options *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_release","text":"aws_retry_strategy_release(retry_strategy)\n\nReleases a reference count on retry_strategy.\n\nPrototype\n\nvoid aws_retry_strategy_release(struct aws_retry_strategy *retry_strategy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_strategy_schedule_retry-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_retry_strategy_schedule_retry","text":"aws_retry_strategy_schedule_retry(token, error_type, retry_ready, user_data)\n\nSchedules a retry based on the backoff and token based strategies. retry_ready is invoked when the retry is either ready for execution or if it has been canceled due to application shutdown.\n\nThis function can return an error to reject the retry attempt if, for example, a circuit breaker has opened. If this occurs users should fail their calls back to their callers.\n\nerror_type is used for book keeping. See the comments above for aws_retry_error_type.\n\nPrototype\n\nint aws_retry_strategy_schedule_retry( struct aws_retry_token *token, enum aws_retry_error_type error_type, aws_retry_strategy_on_retry_ready_fn *retry_ready, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_token_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_retry_token_acquire","text":"aws_retry_token_acquire(token)\n\nIncrements reference count for token. This should be called any time you seat the token to a pointer you own.\n\nPrototype\n\nvoid aws_retry_token_acquire(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_token_record_success-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_retry_token_record_success","text":"aws_retry_token_record_success(token)\n\nRecords a successful retry. This is used for making future decisions to open up token buckets, AIMD breakers etc... some strategies such as exponential backoff will ignore this, but you should always call it after a successful operation or your system will never recover during an outage.\n\nPrototype\n\nint aws_retry_token_record_success(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_retry_token_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_retry_token_release","text":"aws_retry_token_release(token)\n\nReleases the reference count for token. This should always be invoked after either calling aws_retry_strategy_schedule_retry() and failing, or after calling aws_retry_token_record_success().\n\nPrototype\n\nvoid aws_retry_token_release(struct aws_retry_token *token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_acquire-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_acquire","text":"aws_ring_buffer_acquire(ring_buf, requested_size, dest)\n\nAttempts to acquire requested_size buffer and stores the result in dest if successful. Returns AWS_OP_SUCCESS if the requested size was available for use, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_acquire( struct aws_ring_buffer *ring_buf, size_t requested_size, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_acquire_up_to-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_acquire_up_to","text":"aws_ring_buffer_acquire_up_to(ring_buf, minimum_size, requested_size, dest)\n\nAttempts to acquire requested_size buffer and stores the result in dest if successful. If not available, it will attempt to acquire anywhere from 1 byte to requested_size. Returns AWS_OP_SUCCESS if some buffer space is available for use, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_acquire_up_to( struct aws_ring_buffer *ring_buf, size_t minimum_size, size_t requested_size, struct aws_byte_buf *dest);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_buf_belongs_to_pool-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_buf_belongs_to_pool","text":"aws_ring_buffer_buf_belongs_to_pool(ring_buffer, buf)\n\nReturns true if the memory in buf was vended by this ring buffer, false otherwise. Make sure buf->buffer and ring\\_buffer->allocation refer to the same memory region.\n\nPrototype\n\nbool aws_ring_buffer_buf_belongs_to_pool( const struct aws_ring_buffer *ring_buffer, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_check_atomic_ptr-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_check_atomic_ptr","text":"aws_ring_buffer_check_atomic_ptr(ring_buf, atomic_ptr)\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_check_atomic_ptr( const struct aws_ring_buffer *ring_buf, const uint8_t *atomic_ptr);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_clean_up","text":"aws_ring_buffer_clean_up(ring_buf)\n\nCleans up the ring buffer's resources.\n\nPrototype\n\nvoid aws_ring_buffer_clean_up(struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_init","text":"aws_ring_buffer_init(ring_buf, allocator, size)\n\nInitializes a ring buffer with an allocation of size size. Returns AWS_OP_SUCCESS on a successful initialization, AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_ring_buffer_init(struct aws_ring_buffer *ring_buf, struct aws_allocator *allocator, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_is_empty-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_is_empty","text":"aws_ring_buffer_is_empty(ring_buf)\n\nChecks whether the ring buffer is empty\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_is_empty(const struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_is_valid","text":"aws_ring_buffer_is_valid(ring_buf)\n\nEvaluates the set of properties that define the shape of all valid aws_ring_buffer structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_ring_buffer_is_valid(const struct aws_ring_buffer *ring_buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_ring_buffer_release-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_ring_buffer_release","text":"aws_ring_buffer_release(ring_buffer, buf)\n\nReleases buf back to the ring buffer for further use. RELEASE MUST HAPPEN in the SAME ORDER AS ACQUIRE. If you do not, your application, and possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be poisoned for generations with fragments of what is left of your radioactive corrupted memory.\n\nPrototype\n\nvoid aws_ring_buffer_release(struct aws_ring_buffer *ring_buffer, struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_round_up_to_power_of_two-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_round_up_to_power_of_two","text":"aws_round_up_to_power_of_two(n, result)\n\nFunction to find the smallest result that is power of 2 >= n. Returns AWS_OP_ERR if this cannot be done without overflow\n\nPrototype\n\nAWS_STATIC_IMPL int aws_round_up_to_power_of_two(size_t n, size_t *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_run_command-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_run_command","text":"aws_run_command(allocator, options, result)\n\nCurrently this API is implemented using popen on Posix system and _popen on Windows to capture output from running a command. Note that popen only captures stdout, and doesn't provide an option to capture stderr. We will add more options, such as acquire stderr in the future so probably will alter the underlying implementation as well.\n\nPrototype\n\nint aws_run_command( struct aws_allocator *allocator, struct aws_run_command_options *options, struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_run_command_result_cleanup-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_run_command_result_cleanup","text":"aws_run_command_result_cleanup(result)\n\nPrototype\n\nvoid aws_run_command_result_cleanup(struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_run_command_result_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_run_command_result_init","text":"aws_run_command_result_init(allocator, result)\n\nPrototype\n\nint aws_run_command_result_init(struct aws_allocator *allocator, struct aws_run_command_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_clean_up","text":"aws_rw_lock_clean_up(lock)\n\nCleans up internal resources.\n\nPrototype\n\nvoid aws_rw_lock_clean_up(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_init","text":"aws_rw_lock_init(lock)\n\nInitializes a new platform instance of mutex.\n\nPrototype\n\nint aws_rw_lock_init(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_rlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_rlock","text":"aws_rw_lock_rlock(lock)\n\nBlocks until it acquires the lock. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n\nPrototype\n\nint aws_rw_lock_rlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_runlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_runlock","text":"aws_rw_lock_runlock(lock)\n\nReleases the lock.\n\nPrototype\n\nint aws_rw_lock_runlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_try_rlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_try_rlock","text":"aws_rw_lock_try_rlock(lock)\n\nAttempts to acquire the lock but returns immediately if it can not. While on some platforms such as Windows, this may behave as a reentrant mutex, you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be. Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]\n\nPrototype\n\nint aws_rw_lock_try_rlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_try_wlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_try_wlock","text":"aws_rw_lock_try_wlock(lock)\n\nPrototype\n\nint aws_rw_lock_try_wlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_wlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_wlock","text":"aws_rw_lock_wlock(lock)\n\nPrototype\n\nint aws_rw_lock_wlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_rw_lock_wunlock-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_rw_lock_wunlock","text":"aws_rw_lock_wunlock(lock)\n\nPrototype\n\nint aws_rw_lock_wunlock(struct aws_rw_lock *lock);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_client_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_client_acquire","text":"aws_s3_client_acquire(client)\n\nAdd a reference, keeping this object alive. The reference must be released when you are done with it, or it's memory will never be cleaned up. You must not pass in NULL. Always returns the same pointer that was passed in.\n\nPrototype\n\nstruct aws_s3_client *aws_s3_client_acquire(struct aws_s3_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_client_make_meta_request-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_client_make_meta_request","text":"aws_s3_client_make_meta_request(client, options)\n\nPrototype\n\nstruct aws_s3_meta_request *aws_s3_client_make_meta_request( struct aws_s3_client *client, const struct aws_s3_meta_request_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_client_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_client_new","text":"aws_s3_client_new(allocator, client_config)\n\nPrototype\n\nstruct aws_s3_client *aws_s3_client_new( struct aws_allocator *allocator, const struct aws_s3_client_config *client_config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_client_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_client_release","text":"aws_s3_client_release(client)\n\nRelease a reference. When the reference count drops to 0, this object will be cleaned up. It's OK to pass in NULL (nothing happens). Always returns NULL.\n\nPrototype\n\nstruct aws_s3_client *aws_s3_client_release(struct aws_s3_client *client);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_endpoint_resolver_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_endpoint_resolver_new","text":"aws_s3_endpoint_resolver_new(allocator)\n\nCreates a new S3 endpoint resolver. Warning: Before using this header, you have to enable it by setting cmake config AWS_ENABLE_S3_ENDPOINT_RESOLVER=ON\n\nPrototype\n\nstruct aws_endpoints_rule_engine *aws_s3_endpoint_resolver_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_get_compute_platform_info_for_instance_type-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_get_compute_platform_info_for_instance_type","text":"aws_s3_get_compute_platform_info_for_instance_type(instance_type_name)\n\nRetrieves the pre-configured metadata for an ec2 instance type. If no such pre-configuration exists, returns NULL.\n\nPrototype\n\nstruct aws_s3_compute_platform_info *aws_s3_get_compute_platform_info_for_instance_type( const struct aws_byte_cursor instance_type_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_init_default_signing_config-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_init_default_signing_config","text":"aws_s3_init_default_signing_config(signing_config, region, credentials_provider)\n\nInitialize the configuration for a default S3 signing.\n\nPrototype\n\nvoid aws_s3_init_default_signing_config( struct aws_signing_config_aws *signing_config, const struct aws_byte_cursor region, struct aws_credentials_provider *credentials_provider);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_s3_library_clean_up","text":"aws_s3_library_clean_up()\n\nShuts down the internal datastructures used by aws-c-s3.\n\nPrototype\n\nvoid aws_s3_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_library_init","text":"aws_s3_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-s3. Must be called before using any functionality in aws-c-s3.\n\nPrototype\n\nvoid aws_s3_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_acquire","text":"aws_s3_meta_request_acquire(meta_request)\n\nAdd a reference, keeping this object alive. The reference must be released when you are done with it, or it's memory will never be cleaned up. You must not pass in NULL. Always returns the same pointer that was passed in.\n\nPrototype\n\nstruct aws_s3_meta_request *aws_s3_meta_request_acquire(struct aws_s3_meta_request *meta_request);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_cancel-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_cancel","text":"aws_s3_meta_request_cancel(meta_request)\n\nPrototype\n\nvoid aws_s3_meta_request_cancel(struct aws_s3_meta_request *meta_request);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_increment_read_window","text":"aws_s3_meta_request_increment_read_window(meta_request, bytes)\n\nIncrement the flow-control window, so that response data continues downloading.\n\nIf the client was created with enable_read_backpressure set true, each meta request has a flow-control window that shrinks as response body data is downloaded (headers do not affect the size of the window). The client's initial_read_window determines the starting size of each meta request's window. If a meta request's flow-control window reaches 0, no further data will be downloaded. If the initial_read_window is 0, the request will not start until the window is incremented. Maintain a larger window to keep up a high download throughput, parts cannot download in parallel unless the window is large enough to hold multiple parts. Maintain a smaller window to limit the amount of data buffered in memory.\n\nIf enable_read_backpressure is false this call will have no effect, no backpressure is being applied and data is being downloaded as fast as possible.\n\nWARNING: This feature is experimental. Currently, backpressure is only applied to GetObject requests which are split into multiple parts, and you may still receive some data after the window reaches 0.\n\nPrototype\n\nvoid aws_s3_meta_request_increment_read_window(struct aws_s3_meta_request *meta_request, uint64_t bytes);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_pause-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_pause","text":"aws_s3_meta_request_pause(meta_request, out_resume_token)\n\nNote: pause is currently only supported on upload requests. In order to pause an ongoing upload, call aws_s3_meta_request_pause() that will return resume token. Token can be used to query the state of operation at the pausing time. To resume an upload that was paused, supply resume token in the meta request options structure member aws_s3_meta_request_options.resume_token. The upload can be resumed either from the same client or a different one. Corner cases for resume upload are as follows: - upload is not MPU - fail with AWS_ERROR_UNSUPPORTED_OPERATION - pausing before MPU is created - NULL resume token returned. NULL resume token is equivalent to restarting upload - pausing in the middle of part transfer - return resume token. scheduling of new part uploads stops. - pausing after completeMPU started - return resume token. if s3 cannot find find associated MPU id when resuming with that token and num of parts uploaded equals to total num parts, then operation is a no op. Otherwise operation fails. Note: for no op case the call will succeed and finish/shutdown request callbacks will fire, but on headers callback will not fire. Note: similar to cancel pause does not cancel requests already in flight and and parts might complete after pause is requested.\n\nParameters\n\nmeta_request: pointer to the aws_s3_meta_request of the upload to be paused\nresume_token: resume token\n\nReturns\n\neither AWS_OP_ERR or AWS_OP_SUCCESS\n\nPrototype\n\nint aws_s3_meta_request_pause( struct aws_s3_meta_request *meta_request, struct aws_s3_meta_request_resume_token **out_resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_release","text":"aws_s3_meta_request_release(meta_request)\n\nRelease a reference. When the reference count drops to 0, this object will be cleaned up. It's OK to pass in NULL (nothing happens). Always returns NULL.\n\nPrototype\n\nstruct aws_s3_meta_request *aws_s3_meta_request_release(struct aws_s3_meta_request *meta_request);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_acquire","text":"aws_s3_meta_request_resume_token_acquire(resume_token)\n\nPrototype\n\nstruct aws_s3_meta_request_resume_token *aws_s3_meta_request_resume_token_acquire( struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_new_upload-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_new_upload","text":"aws_s3_meta_request_resume_token_new_upload(allocator, options)\n\nCreate upload resume token from persisted data. Note: Data required for resume token varies per operation.\n\nPrototype\n\nstruct aws_s3_meta_request_resume_token *aws_s3_meta_request_resume_token_new_upload( struct aws_allocator *allocator, const struct aws_s3_upload_resume_token_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_num_parts_completed-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_num_parts_completed","text":"aws_s3_meta_request_resume_token_num_parts_completed(resume_token)\n\nPrototype\n\nsize_t aws_s3_meta_request_resume_token_num_parts_completed(struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_part_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_part_size","text":"aws_s3_meta_request_resume_token_part_size(resume_token)\n\nPrototype\n\nuint64_t aws_s3_meta_request_resume_token_part_size(struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_release","text":"aws_s3_meta_request_resume_token_release(resume_token)\n\nPrototype\n\nstruct aws_s3_meta_request_resume_token *aws_s3_meta_request_resume_token_release( struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_total_num_parts-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_total_num_parts","text":"aws_s3_meta_request_resume_token_total_num_parts(resume_token)\n\nPrototype\n\nsize_t aws_s3_meta_request_resume_token_total_num_parts(struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_type-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_type","text":"aws_s3_meta_request_resume_token_type(resume_token)\n\nPrototype\n\nenum aws_s3_meta_request_type aws_s3_meta_request_resume_token_type( struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_meta_request_resume_token_upload_id-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_meta_request_resume_token_upload_id","text":"aws_s3_meta_request_resume_token_upload_id(resume_token)\n\nPrototype\n\nstruct aws_byte_cursor aws_s3_meta_request_resume_token_upload_id( struct aws_s3_meta_request_resume_token *resume_token);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_acquire","text":"aws_s3_request_metrics_acquire(metrics)\n\nAdd a reference, keeping this object alive. The reference must be released when you are done with it, or it's memory will never be cleaned up. Always returns the same pointer that was passed in.\n\nPrototype\n\nstruct aws_s3_request_metrics *aws_s3_request_metrics_acquire(struct aws_s3_request_metrics *metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_connection_id-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_connection_id","text":"aws_s3_request_metrics_get_connection_id(metrics, out_connection_id)\n\nPrototype\n\nint aws_s3_request_metrics_get_connection_id(const struct aws_s3_request_metrics *metrics, size_t *out_connection_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_end_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_end_timestamp_ns","text":"aws_s3_request_metrics_get_end_timestamp_ns(metrics, out_end_time)\n\nPrototype\n\nvoid aws_s3_request_metrics_get_end_timestamp_ns(const struct aws_s3_request_metrics *metrics, uint64_t *out_end_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_error_code-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_error_code","text":"aws_s3_request_metrics_get_error_code(metrics)\n\nPrototype\n\nint aws_s3_request_metrics_get_error_code(const struct aws_s3_request_metrics *metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_host_address-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_host_address","text":"aws_s3_request_metrics_get_host_address(metrics, out_host_address)\n\nGet the host_address of the request. If unavailable, AWS_ERROR_S3_METRIC_DATA_NOT_AVAILABLE will be raised. If available, out_host_address will be set to a string. Be warned this string's lifetime is tied to the metrics object.\n\nPrototype\n\nvoid aws_s3_request_metrics_get_host_address( const struct aws_s3_request_metrics *metrics, const struct aws_string **out_host_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_ip_address-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_ip_address","text":"aws_s3_request_metrics_get_ip_address(metrics, out_ip_address)\n\nGet the IP address of the request connected to. If unavailable, AWS_ERROR_S3_METRIC_DATA_NOT_AVAILABLE will be raised. If available, out_ip_address will be set to a string. Be warned this string's lifetime is tied to the metrics object.\n\nPrototype\n\nint aws_s3_request_metrics_get_ip_address( const struct aws_s3_request_metrics *metrics, const struct aws_string **out_ip_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_receive_end_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_receive_end_timestamp_ns","text":"aws_s3_request_metrics_get_receive_end_timestamp_ns(metrics, out_receive_end_time)\n\nPrototype\n\nint aws_s3_request_metrics_get_receive_end_timestamp_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_receive_end_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_receive_start_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_receive_start_timestamp_ns","text":"aws_s3_request_metrics_get_receive_start_timestamp_ns(metrics, out_receive_start_time)\n\nPrototype\n\nint aws_s3_request_metrics_get_receive_start_timestamp_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_receive_start_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_receiving_duration_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_receiving_duration_ns","text":"aws_s3_request_metrics_get_receiving_duration_ns(metrics, out_receiving_duration)\n\nPrototype\n\nint aws_s3_request_metrics_get_receiving_duration_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_receiving_duration);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_request_id-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_request_id","text":"aws_s3_request_metrics_get_request_id(metrics, out_request_id)\n\n*********************************** Getters for s3 request metrics ***********************************************\n\nGet the request ID from aws_s3_request_metrics. If unavailable, AWS_ERROR_S3_METRIC_DATA_NOT_AVAILABLE will be raised. If available, out_request_id will be set to a string. Be warned this string's lifetime is tied to the metrics object.\n\nPrototype\n\nint aws_s3_request_metrics_get_request_id( const struct aws_s3_request_metrics *metrics, const struct aws_string **out_request_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_request_path_query-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_request_path_query","text":"aws_s3_request_metrics_get_request_path_query(metrics, out_request_path_query)\n\nGet the path and query of the request. If unavailable, AWS_ERROR_S3_METRIC_DATA_NOT_AVAILABLE will be raised. If available, out_request_path_query will be set to a string. Be warned this string's lifetime is tied to the metrics object.\n\nPrototype\n\nvoid aws_s3_request_metrics_get_request_path_query( const struct aws_s3_request_metrics *metrics, const struct aws_string **out_request_path_query);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_request_stream_id-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_request_stream_id","text":"aws_s3_request_metrics_get_request_stream_id(metrics, out_stream_id)\n\nPrototype\n\nint aws_s3_request_metrics_get_request_stream_id(const struct aws_s3_request_metrics *metrics, uint32_t *out_stream_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_request_type-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_request_type","text":"aws_s3_request_metrics_get_request_type(metrics, out_request_type)\n\nPrototype\n\nvoid aws_s3_request_metrics_get_request_type( const struct aws_s3_request_metrics *metrics, enum aws_s3_request_type *out_request_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_response_headers-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_response_headers","text":"aws_s3_request_metrics_get_response_headers(metrics, out_response_headers)\n\nPrototype\n\nint aws_s3_request_metrics_get_response_headers( const struct aws_s3_request_metrics *metrics, struct aws_http_headers **out_response_headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_response_status_code-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_response_status_code","text":"aws_s3_request_metrics_get_response_status_code(metrics, out_response_status)\n\nPrototype\n\nint aws_s3_request_metrics_get_response_status_code( const struct aws_s3_request_metrics *metrics, int *out_response_status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_send_end_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_send_end_timestamp_ns","text":"aws_s3_request_metrics_get_send_end_timestamp_ns(metrics, out_send_end_time)\n\nPrototype\n\nint aws_s3_request_metrics_get_send_end_timestamp_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_send_end_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_send_start_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_send_start_timestamp_ns","text":"aws_s3_request_metrics_get_send_start_timestamp_ns(metrics, out_send_start_time)\n\nPrototype\n\nint aws_s3_request_metrics_get_send_start_timestamp_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_send_start_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_sending_duration_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_sending_duration_ns","text":"aws_s3_request_metrics_get_sending_duration_ns(metrics, out_sending_duration)\n\nPrototype\n\nint aws_s3_request_metrics_get_sending_duration_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_sending_duration);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_start_timestamp_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_start_timestamp_ns","text":"aws_s3_request_metrics_get_start_timestamp_ns(metrics, out_start_time)\n\nPrototype\n\nvoid aws_s3_request_metrics_get_start_timestamp_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_start_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_thread_id-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_thread_id","text":"aws_s3_request_metrics_get_thread_id(metrics, out_thread_id)\n\nPrototype\n\nint aws_s3_request_metrics_get_thread_id(const struct aws_s3_request_metrics *metrics, aws_thread_id_t *out_thread_id);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_get_total_duration_ns-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_get_total_duration_ns","text":"aws_s3_request_metrics_get_total_duration_ns(metrics, out_total_duration)\n\nPrototype\n\nvoid aws_s3_request_metrics_get_total_duration_ns( const struct aws_s3_request_metrics *metrics, uint64_t *out_total_duration);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_s3_request_metrics_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_s3_request_metrics_release","text":"aws_s3_request_metrics_release(metrics)\n\nRelease a reference. When the reference count drops to 0, this object will be cleaned up. It's OK to pass in NULL (nothing happens). Always returns NULL.\n\nPrototype\n\nstruct aws_s3_request_metrics *aws_s3_request_metrics_release(struct aws_s3_request_metrics *metrics);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sdkutils_library_clean_up-Tuple{}","page":"Home","title":"LibAWSCRT.aws_sdkutils_library_clean_up","text":"aws_sdkutils_library_clean_up()\n\nPrototype\n\nvoid aws_sdkutils_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sdkutils_library_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_sdkutils_library_init","text":"aws_sdkutils_library_init(allocator)\n\nPrototype\n\nvoid aws_sdkutils_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_strlen-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_strlen","text":"aws_secure_strlen(str, max_read_len, str_len)\n\nComputes the length of a c string in bytes assuming the character set is either ASCII or UTF-8. If no NULL character is found within max_read_len of str, AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED is raised. Otherwise, str_len will contain the string length minus the NULL character, and AWS_OP_SUCCESS will be returned.\n\nPrototype\n\nint aws_secure_strlen(const char *str, size_t max_read_len, size_t *str_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_acquire","text":"aws_secure_tunnel_acquire(secure_tunnel)\n\nAcquires a reference to a secure tunnel\n\nParameters\n\nsecure_tunnel: secure tunnel to acquire a reference to. May be NULL\n\nReturns\n\nwhat was passed in as the secure tunnel (a client or NULL)\n\nPrototype\n\nstruct aws_secure_tunnel *aws_secure_tunnel_acquire(struct aws_secure_tunnel *secure_tunnel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_connection_start-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_connection_start","text":"aws_secure_tunnel_connection_start(secure_tunnel, message_options)\n\nQueue a CONNECTION_START message in a secure tunnel\n\nnote: Note\nThis function should only be used from source mode.\n\nParameters\n\nsecure_tunnel: secure tunnel to queue a message for\nmessage_options: configuration options for the message operation\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the message operation\n\nPrototype\n\nint aws_secure_tunnel_connection_start( struct aws_secure_tunnel *secure_tunnel, const struct aws_secure_tunnel_message_view *message_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_message_type_to_c_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_message_type_to_c_string","text":"aws_secure_tunnel_message_type_to_c_string(message_type)\n\nGet the const char description of a message type\n\nParameters\n\nmessage_type: message type used by a secure tunnel message\n\nReturns\n\nconst char translation of the message type\n\nPrototype\n\nconst char *aws_secure_tunnel_message_type_to_c_string(enum aws_secure_tunnel_message_type message_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_new","text":"aws_secure_tunnel_new(allocator, options)\n\nCreates a new secure tunnel\n\nParameters\n\noptions: secure tunnel configuration\n\nReturns\n\na new secure tunnel or NULL\n\nPrototype\n\nstruct aws_secure_tunnel *aws_secure_tunnel_new( struct aws_allocator *allocator, const struct aws_secure_tunnel_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_release","text":"aws_secure_tunnel_release(secure_tunnel)\n\nRelease a reference to a secure tunnel. When the secure tunnel ref count drops to zero, the secure tunnel will automatically trigger a stop and once the stop completes, the secure tunnel will delete itself.\n\nParameters\n\nsecure_tunnel: secure tunnel to release a reference to. May be NULL\n\nReturns\n\nNULL\n\nPrototype\n\nstruct aws_secure_tunnel *aws_secure_tunnel_release(struct aws_secure_tunnel *secure_tunnel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_send_message-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_send_message","text":"aws_secure_tunnel_send_message(secure_tunnel, message_options)\n\nQueues a message operation in a secure tunnel\n\nParameters\n\nsecure_tunnel: secure tunnel to queue a message for\nmessage_options: configuration options for the message operation\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the message operation\n\nPrototype\n\nint aws_secure_tunnel_send_message( struct aws_secure_tunnel *secure_tunnel, const struct aws_secure_tunnel_message_view *message_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_start-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_start","text":"aws_secure_tunnel_start(secure_tunnel)\n\nAsynchronous notify to the secure tunnel that you want it to attempt to connect. The secure tunnel will attempt to stay connected.\n\nParameters\n\nsecure_tunnel: secure tunnel to start\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the start process\n\nPrototype\n\nint aws_secure_tunnel_start(struct aws_secure_tunnel *secure_tunnel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_stop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_stop","text":"aws_secure_tunnel_stop(secure_tunnel)\n\nAsynchronous notify to the secure tunnel that you want it to transition to the stopped state. When the secure tunnel reaches the stopped state, all session state is erased.\n\nParameters\n\nsecure_tunnel: secure tunnel to stop\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the start process\n\nPrototype\n\nint aws_secure_tunnel_stop(struct aws_secure_tunnel *secure_tunnel);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_stream_reset-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_stream_reset","text":"aws_secure_tunnel_stream_reset(secure_tunnel, message_options)\n\nQueue a STREAM_RESET message in a secure tunnel\n\n\\deprecated This function should not be used.\n\nParameters\n\nsecure_tunnel: secure tunnel to queue a message for\nmessage_options: configuration options for the message operation\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the message operation\n\nPrototype\n\nint aws_secure_tunnel_stream_reset( struct aws_secure_tunnel *secure_tunnel, const struct aws_secure_tunnel_message_view *message_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_tunnel_stream_start-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_tunnel_stream_start","text":"aws_secure_tunnel_stream_start(secure_tunnel, message_options)\n\nQueue a STREAM_START message in a secure tunnel\n\nnote: Note\nThis function should only be used from source mode.\n\nParameters\n\nsecure_tunnel: secure tunnel to queue a message for\nmessage_options: configuration options for the message operation\n\nReturns\n\nsuccess/failure in the synchronous logic that kicks off the message operation\n\nPrototype\n\nint aws_secure_tunnel_stream_start( struct aws_secure_tunnel *secure_tunnel, const struct aws_secure_tunnel_message_view *message_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_secure_zero-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_secure_zero","text":"aws_secure_zero(pBuf, bufsize)\n\nSecurely zeroes a memory buffer. This function will attempt to ensure that the compiler will not optimize away this zeroing operation.\n\nPrototype\n\nvoid aws_secure_zero(void *pBuf, size_t bufsize);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_acquire","text":"aws_server_bootstrap_acquire(bootstrap)\n\nIncrements a server bootstrap's ref count, allowing the caller to take a reference to it.\n\nReturns the same server bootstrap passed in.\n\nPrototype\n\nstruct aws_server_bootstrap *aws_server_bootstrap_acquire(struct aws_server_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_destroy_socket_listener-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_destroy_socket_listener","text":"aws_server_bootstrap_destroy_socket_listener(bootstrap, listener)\n\nShuts down 'listener' and cleans up any resources associated with it. Any incoming channels on listener will still be active. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down.\n\nPrototype\n\nvoid aws_server_bootstrap_destroy_socket_listener( struct aws_server_bootstrap *bootstrap, struct aws_socket *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_new","text":"aws_server_bootstrap_new(allocator, el_group)\n\nInitializes the server bootstrap with allocator and el_group. This object manages listeners, server connections, and channels.\n\nPrototype\n\nstruct aws_server_bootstrap *aws_server_bootstrap_new( struct aws_allocator *allocator, struct aws_event_loop_group *el_group);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_new_socket_listener-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_new_socket_listener","text":"aws_server_bootstrap_new_socket_listener(bootstrap_options)\n\nSets up a server socket listener. If you are planning on using TLS, use aws_server_bootstrap_new_tls_socket_listener instead. This creates a socket listener bound to local_endpoint using socket options options. incoming_callback will be invoked once an incoming channel is ready for use or if an error is encountered. shutdown_callback will be invoked once the channel has shutdown. destroy_callback will be invoked after the server socket listener is destroyed, and all associated connections and channels have finished shutting down. Immediately after the shutdown_callback returns, the channel is cleaned up automatically. All callbacks are invoked the thread of the event-loop that the listening socket is assigned to\n\nUpon shutdown of your application, you'll want to call aws_server_bootstrap_destroy_socket_listener with the return value from this function.\n\nbootstrap_options is copied.\n\nPrototype\n\nstruct aws_socket *aws_server_bootstrap_new_socket_listener( const struct aws_server_socket_channel_bootstrap_options *bootstrap_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_release","text":"aws_server_bootstrap_release(bootstrap)\n\nDecrements a server bootstrap's ref count. When the ref count drops to zero, the bootstrap will be destroyed.\n\nPrototype\n\nvoid aws_server_bootstrap_release(struct aws_server_bootstrap *bootstrap);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_server_bootstrap_set_alpn_callback-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_server_bootstrap_set_alpn_callback","text":"aws_server_bootstrap_set_alpn_callback(bootstrap, on_protocol_negotiated)\n\nWhen using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added to the channel.\n\nPrototype\n\nint aws_server_bootstrap_set_alpn_callback( struct aws_server_bootstrap *bootstrap, aws_channel_on_protocol_negotiated_fn *on_protocol_negotiated);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_environment_value-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_set_environment_value","text":"aws_set_environment_value(variable_name, value)\n\nPrototype\n\nint aws_set_environment_value(const struct aws_string *variable_name, const struct aws_string *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_global_error_handler_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_set_global_error_handler_fn","text":"aws_set_global_error_handler_fn(handler, ctx)\n\nPrototype\n\naws_error_handler_fn *aws_set_global_error_handler_fn(aws_error_handler_fn *handler, void *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_md5_new_fn-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_set_md5_new_fn","text":"aws_set_md5_new_fn(fn)\n\nSet the implementation of md5 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_md5_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_sha1_new_fn-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_set_sha1_new_fn","text":"aws_set_sha1_new_fn(fn)\n\nSet the implementation of sha1 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha1_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_sha256_hmac_new_fn-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_set_sha256_hmac_new_fn","text":"aws_set_sha256_hmac_new_fn(fn)\n\nSet the implementation of sha256 hmac to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha256_hmac_new_fn(aws_hmac_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_sha256_new_fn-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_set_sha256_new_fn","text":"aws_set_sha256_new_fn(fn)\n\nSet the implementation of sha256 to use. If you compiled without BYO_CRYPTO, you do not need to call this. However, if use this, we will honor it, regardless of compile options. This may be useful for testing purposes. If you did set BYO_CRYPTO, and you do not call this function you will segfault.\n\nPrototype\n\nvoid aws_set_sha256_new_fn(aws_hash_new_fn *fn);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_soft_limit_io_handles-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_set_soft_limit_io_handles","text":"aws_set_soft_limit_io_handles(max_handles)\n\nSets the new soft limit for io_handles (max fds). This can be up to the hard limit but may not exceed it.\n\nThis operation will always fail with AWS_ERROR_UNIMPLEMENTED error code on Windows.\n\nPrototype\n\nint aws_set_soft_limit_io_handles(size_t max_handles);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_set_thread_local_error_handler_fn-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_set_thread_local_error_handler_fn","text":"aws_set_thread_local_error_handler_fn(handler, ctx)\n\nPrototype\n\naws_error_handler_fn *aws_set_thread_local_error_handler_fn(aws_error_handler_fn *handler, void *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha1_compute-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_sha1_compute","text":"aws_sha1_compute(allocator, input, output, truncate_to)\n\nComputes the sha1 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA1 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha1_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha1_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_sha1_new","text":"aws_sha1_new(allocator)\n\nAllocates and initializes a sha1 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_sha1_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha256_compute-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_sha256_compute","text":"aws_sha256_compute(allocator, input, output, truncate_to)\n\nComputes the sha256 hash over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example, if you want a SHA256 digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha256_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *input, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha256_hmac_compute-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_sha256_hmac_compute","text":"aws_sha256_hmac_compute(allocator, secret, to_hmac, output, truncate_to)\n\nComputes the sha256 hmac over input and writes the digest output to 'output'. Use this if you don't need to stream the data you're hashing and you can load the entire input to hash into memory. If you specify truncate_to to something other than 0, the output will be truncated to that number of bytes. For example if you want a SHA256 HMAC digest as the first 16 bytes, set truncate_to to 16. If you want the full digest size, just set this to 0.\n\nPrototype\n\nint aws_sha256_hmac_compute( struct aws_allocator *allocator, const struct aws_byte_cursor *secret, const struct aws_byte_cursor *to_hmac, struct aws_byte_buf *output, size_t truncate_to);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha256_hmac_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_sha256_hmac_new","text":"aws_sha256_hmac_new(allocator, secret)\n\nAllocates and initializes a sha256 hmac instance. Secret is the key to be used for the hmac process.\n\nPrototype\n\nstruct aws_hmac *aws_sha256_hmac_new(struct aws_allocator *allocator, const struct aws_byte_cursor *secret);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sha256_new-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_sha256_new","text":"aws_sha256_new(allocator)\n\nAllocates and initializes a sha256 hash instance.\n\nPrototype\n\nstruct aws_hash *aws_sha256_new(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_shared_library_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_shared_library_clean_up","text":"aws_shared_library_clean_up(library)\n\nPrototype\n\nvoid aws_shared_library_clean_up(struct aws_shared_library *library);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_shared_library_find_function-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_shared_library_find_function","text":"aws_shared_library_find_function(library, symbol_name, function_address)\n\nPrototype\n\nint aws_shared_library_find_function( struct aws_shared_library *library, const char *symbol_name, aws_generic_function *function_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_shared_library_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_shared_library_init","text":"aws_shared_library_init(library, library_path)\n\nPrototype\n\nint aws_shared_library_init(struct aws_shared_library *library, const char *library_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sign_request_aws-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_sign_request_aws","text":"aws_sign_request_aws(allocator, signable, base_config, on_complete, userdata)\n\n(Asynchronous) entry point to sign something (a request, a chunk, an event) with an AWS signing process. Depending on the configuration, the signing process may or may not complete synchronously.\n\nParameters\n\nallocator: memory allocator to use throughout the signing process\nsignable: the thing to be signed. See signable.h for common constructors for signables that wrap different types.\nbase_config: pointer to a signing configuration, currently this must be of type aws_signing_config_aws\non_complete: completion callback to be invoked when signing has finished\nuser_data: opaque user data that will be passed to the completion callback\n\nReturns\n\nAWS_OP_SUCCESS if the signing attempt was initiated successfully, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_sign_request_aws( struct aws_allocator *allocator, const struct aws_signable *signable, const struct aws_signing_config_base *base_config, aws_signing_complete_fn *on_complete, void *userdata);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_signable_destroy","text":"aws_signable_destroy(signable)\n\nCleans up and frees all resources associated with a signable instance\n\nParameters\n\nsignable: signable object to destroy\n\nPrototype\n\nvoid aws_signable_destroy(struct aws_signable *signable);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_get_payload_stream-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_get_payload_stream","text":"aws_signable_get_payload_stream(signable, out_input_stream)\n\nRetrieves the signable's message payload as a stream.\n\nParameters\n\nsignable: signable to get the payload of\nout_input_stream: output parameter for the payload stream\n\nReturns\n\nAWS_OP_SUCCESS if successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signable_get_payload_stream(const struct aws_signable *signable, struct aws_input_stream **out_input_stream);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_get_property-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_get_property","text":"aws_signable_get_property(signable, name, out_value)\n\nRetrieves a property (key-value pair) from a signable. Global property name constants are included below.\n\nParameters\n\nsignable: signable object to retrieve a property from\nname: name of the property to query\nout_value: output parameter for the property's value\n\nReturns\n\nAWS_OP_SUCCESS if the property was successfully fetched, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signable_get_property( const struct aws_signable *signable, const struct aws_string *name, struct aws_byte_cursor *out_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_get_property_list-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_get_property_list","text":"aws_signable_get_property_list(signable, name, out_property_list)\n\nRetrieves a named property list (list of key-value pairs) from a signable. Global property list name constants are included below.\n\nParameters\n\nsignable: signable object to retrieve a property list from\nname: name of the property list to fetch\nout_property_list: output parameter for the fetched property list\n\nReturns\n\nAWS_OP_SUCCESS if the property list was successfully fetched, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signable_get_property_list( const struct aws_signable *signable, const struct aws_string *name, struct aws_array_list **out_property_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_new_canonical_request-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_new_canonical_request","text":"aws_signable_new_canonical_request(allocator, canonical_request)\n\nCreates a signable that represents a pre-computed canonical request from an http request\n\nParameters\n\nallocator: memory allocator use to create the signable\ncanonical_request: text of the canonical request\n\nReturns\n\nthe new signable object, or NULL if failure\n\nPrototype\n\nstruct aws_signable *aws_signable_new_canonical_request( struct aws_allocator *allocator, struct aws_byte_cursor canonical_request);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_new_chunk-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_new_chunk","text":"aws_signable_new_chunk(allocator, chunk_data, previous_signature)\n\nCreates a signable that represents a unit of chunked encoding within an http request. This can also be used for Transcribe event signing with encoded payload as chunk_data.\n\nParameters\n\nallocator: memory allocator use to create the signable\nchunk_data: stream representing the data in the chunk; it should be in its final, encoded form\nprevious_signature: the signature computed in the most recent signing that preceded this one. It can be found by copying the \"signature\" property from the signing_result of that most recent signing.\n\nReturns\n\nthe new signable object, or NULL if failure\n\nPrototype\n\nstruct aws_signable *aws_signable_new_chunk( struct aws_allocator *allocator, struct aws_input_stream *chunk_data, struct aws_byte_cursor previous_signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_new_http_request-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_new_http_request","text":"aws_signable_new_http_request(allocator, request)\n\nCreates a signable wrapper around an http request.\n\nParameters\n\nallocator: memory allocator to use to create the signable\nrequest: http request to create a signable for\n\nReturns\n\nthe new signable object, or NULL if failure\n\nPrototype\n\nstruct aws_signable *aws_signable_new_http_request(struct aws_allocator *allocator, struct aws_http_message *request);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signable_new_trailing_headers-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signable_new_trailing_headers","text":"aws_signable_new_trailing_headers(allocator, trailing_headers, previous_signature)\n\nCreates a signable wrapper around a set of headers.\n\nParameters\n\nallocator: memory allocator use to create the signable\ntrailing_headers: http headers to create a signable for\nprevious_signature: the signature computed in the most recent signing that preceded this one. It can be found by copying the \"signature\" property from the signing_result of that most recent signing.\n\nReturns\n\nthe new signable object, or NULL if failure\n\nPrototype\n\nstruct aws_signable *aws_signable_new_trailing_headers( struct aws_allocator *allocator, struct aws_http_headers *trailing_headers, struct aws_byte_cursor previous_signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_algorithm_to_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_signing_algorithm_to_string","text":"aws_signing_algorithm_to_string(algorithm)\n\nReturns a c-string that describes the supplied signing algorithm\n\nParameters\n\nalgorithm: signing algorithm to get a friendly string name for\n\nReturns\n\nfriendly string name of the supplied algorithm, or \"Unknown\" if the algorithm is not recognized\n\nPrototype\n\nconst char *aws_signing_algorithm_to_string(enum aws_signing_algorithm algorithm);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_append_property_list-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_append_property_list","text":"aws_signing_result_append_property_list(result, list_name, property_name, property_value)\n\nAdds a key-value pair to a named property list. If the named list does not yet exist, it will be created as an empty list before the pair is added. No uniqueness checks are made against existing pairs.\n\nParameters\n\nresult: signing result to modify\nlist_name: name of the list to add the property key-value pair to\nproperty_name: key value of the key-value pair to append\nproperty_value: property value of the key-value pair to append\n\nReturns\n\nAWS_OP_SUCCESS if the operation was successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signing_result_append_property_list( struct aws_signing_result *result, const struct aws_string *list_name, const struct aws_byte_cursor *property_name, const struct aws_byte_cursor *property_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_clean_up","text":"aws_signing_result_clean_up(result)\n\nClean up all resources held by the signing result\n\nParameters\n\nresult: signing result to clean up resources for\n\nPrototype\n\nvoid aws_signing_result_clean_up(struct aws_signing_result *result);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_get_property-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_get_property","text":"aws_signing_result_get_property(result, property_name, out_property_value)\n\nGets the value of a property on a signing result\n\nParameters\n\nresult: signing result to query from\nproperty_name: name of the property to query the value of\nout_property_value: output parameter for the property value\n\nReturns\n\nAWS_OP_SUCCESS if the get was successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signing_result_get_property( const struct aws_signing_result *result, const struct aws_string *property_name, struct aws_string **out_property_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_get_property_list-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_get_property_list","text":"aws_signing_result_get_property_list(result, list_name, out_list)\n\nGets a named property list on the signing result. If the list does not exist, *out_list will be set to null\n\nParameters\n\nresult: signing result to query\nlist_name: name of the list of key-value pairs to get\nout_list: output parameter for the list of key-value pairs\n\nPrototype\n\nvoid aws_signing_result_get_property_list( const struct aws_signing_result *result, const struct aws_string *list_name, struct aws_array_list **out_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_get_property_value_in_property_list-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_get_property_value_in_property_list","text":"aws_signing_result_get_property_value_in_property_list(result, list_name, property_name, out_value)\n\nLooks for a property within a named property list on the signing result. If the list does not exist, or the property does not exist within the list, *out_value will be set to NULL.\n\nParameters\n\nresult: signing result to query\nlist_name: name of the list of key-value pairs to search through for the property\nproperty_name: name of the property to search for within the list\nout_value: output parameter for the property value, if found\n\nPrototype\n\nvoid aws_signing_result_get_property_value_in_property_list( const struct aws_signing_result *result, const struct aws_string *list_name, const struct aws_string *property_name, struct aws_string **out_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_init","text":"aws_signing_result_init(result, allocator)\n\nInitialize a signing result to its starting state\n\nParameters\n\nresult: signing result to initialize\nallocator: allocator to use for all memory allocation\n\nReturns\n\nAWS_OP_SUCCESS if initialization was successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signing_result_init(struct aws_signing_result *result, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_signing_result_set_property-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_signing_result_set_property","text":"aws_signing_result_set_property(result, property_name, property_value)\n\nSets the value of a property on a signing result\n\nParameters\n\nresult: signing result to modify\nproperty_name: name of the property to set\nproperty_value: value that the property should assume\n\nReturns\n\nAWS_OP_SUCCESS if the set was successful, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_signing_result_set_property( struct aws_signing_result *result, const struct aws_string *property_name, const struct aws_byte_cursor *property_value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_bytes_active-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_bytes_active","text":"aws_small_block_allocator_bytes_active(sba_allocator)\n\nPrototype\n\nsize_t aws_small_block_allocator_bytes_active(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_bytes_reserved-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_bytes_reserved","text":"aws_small_block_allocator_bytes_reserved(sba_allocator)\n\nPrototype\n\nsize_t aws_small_block_allocator_bytes_reserved(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_destroy","text":"aws_small_block_allocator_destroy(sba_allocator)\n\nPrototype\n\nvoid aws_small_block_allocator_destroy(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_new","text":"aws_small_block_allocator_new(allocator, multi_threaded)\n\nPrototype\n\nstruct aws_allocator *aws_small_block_allocator_new(struct aws_allocator *allocator, bool multi_threaded);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_page_size-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_page_size","text":"aws_small_block_allocator_page_size(sba_allocator)\n\nPrototype\n\nsize_t aws_small_block_allocator_page_size(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_small_block_allocator_page_size_available-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_small_block_allocator_page_size_available","text":"aws_small_block_allocator_page_size_available(sba_allocator)\n\nPrototype\n\nsize_t aws_small_block_allocator_page_size_available(struct aws_allocator *sba_allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_assign_to_event_loop-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_assign_to_event_loop","text":"aws_socket_assign_to_event_loop(socket, event_loop)\n\nAssigns the socket to the event-loop. The socket will begin receiving read/write/error notifications after this call.\n\nNote: If you called connect for TCP or Unix Domain Sockets and received a connection_success callback, this has already happened. You only need to call this function when:\n\na.) This socket is a server socket (e.g. a result of a call to start_accept()) b.) This socket is a UDP socket.\n\nPrototype\n\nint aws_socket_assign_to_event_loop(struct aws_socket *socket, struct aws_event_loop *event_loop);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_bind-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_bind","text":"aws_socket_bind(socket, local_endpoint)\n\nBinds the socket to a local address. In UDP mode, the socket is ready for [awssocketread](@ref)() operations. In connection oriented modes, you still must call [awssocketlisten](@ref)() and [awssocketstartaccept](@ref)() before using the socket. local\\endpoint is copied.\n\nPrototype\n\nint aws_socket_bind(struct aws_socket *socket, const struct aws_socket_endpoint *local_endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_clean_up","text":"aws_socket_clean_up(socket)\n\nShuts down any pending operations on the socket, and cleans up state. The socket object can be re-initialized after this operation. This function calls aws_socket_close. If you have not already called aws_socket_close() on the socket, all of the rules for aws_socket_close() apply here. In this case it will not fail if you use the function improperly, but on some platforms you will certainly leak memory.\n\nIf the socket has already been closed, you can safely, call this from any thread.\n\nPrototype\n\nvoid aws_socket_clean_up(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_close-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_close","text":"aws_socket_close(socket)\n\nCalls close() on the socket and unregisters all io operations from the event loop. This function must be called from the event-loop's thread unless this is a listening socket. If it's a listening socket it can be called from any non-event-loop thread or the event-loop the socket is currently assigned to. If called from outside the event-loop, this function will block waiting on the socket to close. If this is called from an event-loop thread other than the one it's assigned to, it presents the possibility of a deadlock, so don't do it.\n\nPrototype\n\nint aws_socket_close(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_connect-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_socket_connect","text":"aws_socket_connect(socket, remote_endpoint, event_loop, on_connection_result, user_data)\n\nConnects to a remote endpoint. In UDP, this simply binds the socket to a remote address for use with [awssocketwrite](@ref)(), and if the operation is successful, the socket can immediately be used for write operations.\n\nIn TCP, LOCAL and VSOCK this function will not block. If the return value is successful, then you must wait on the on\\_connection\\_result() callback to be invoked before using the socket.\n\nIf an event_loop is provided for UDP sockets, a notification will be sent on on_connection_result in the event-loop's thread. Upon completion, the socket will already be assigned an event loop. If NULL is passed for UDP, it will immediately return upon success, but you must call aws_socket_assign_to_event_loop before use.\n\nPrototype\n\nint aws_socket_connect( struct aws_socket *socket, const struct aws_socket_endpoint *remote_endpoint, struct aws_event_loop *event_loop, aws_socket_on_connection_result_fn *on_connection_result, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_endpoint_init_local_address_for_test-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_endpoint_init_local_address_for_test","text":"aws_socket_endpoint_init_local_address_for_test(endpoint)\n\nAssigns a random address (UUID) for use with AWS_SOCKET_LOCAL (Unix Domain Sockets). For use in internal tests only.\n\nPrototype\n\nvoid aws_socket_endpoint_init_local_address_for_test(struct aws_socket_endpoint *endpoint);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_get_bound_address-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_get_bound_address","text":"aws_socket_get_bound_address(socket, out_address)\n\nGet the local address which the socket is bound to. Raises an error if no address is bound.\n\nPrototype\n\nint aws_socket_get_bound_address(const struct aws_socket *socket, struct aws_socket_endpoint *out_address);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_get_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_get_error","text":"aws_socket_get_error(socket)\n\nGets the latest error from the socket. If no error has occurred AWS_OP_SUCCESS will be returned. This function does not raise any errors to the installed error handlers.\n\nPrototype\n\nint aws_socket_get_error(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_get_event_loop-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_get_event_loop","text":"aws_socket_get_event_loop(socket)\n\nGets the event-loop the socket is assigned to.\n\nPrototype\n\nstruct aws_event_loop *aws_socket_get_event_loop(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_handler_get_socket-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_handler_get_socket","text":"aws_socket_handler_get_socket(handler)\n\nPrototype\n\nconst struct aws_socket *aws_socket_handler_get_socket(const struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_handler_new-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_socket_handler_new","text":"aws_socket_handler_new(allocator, socket, slot, max_read_size)\n\nSocket handlers should be the first slot/handler in a channel. It interacts directly with the channel's event loop for read and write notifications. max_read_size is the maximum amount of data it will read from the socket before a context switch (a continuation task will be scheduled).\n\nPrototype\n\nstruct aws_channel_handler *aws_socket_handler_new( struct aws_allocator *allocator, struct aws_socket *socket, struct aws_channel_slot *slot, size_t max_read_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_init-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_init","text":"aws_socket_init(socket, alloc, options)\n\nInitializes a socket object with socket options. options will be copied.\n\nPrototype\n\nint aws_socket_init( struct aws_socket *socket, struct aws_allocator *alloc, const struct aws_socket_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_is_open-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_is_open","text":"aws_socket_is_open(socket)\n\nReturns true if the socket is still open (doesn't mean connected or listening, only that it hasn't had close() called.\n\nPrototype\n\nbool aws_socket_is_open(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_listen-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_listen","text":"aws_socket_listen(socket, backlog_size)\n\nTCP, LOCAL and VSOCK only. Sets up the socket to listen on the address bound to in [awssocketbind](@ref)().\n\nPrototype\n\nint aws_socket_listen(struct aws_socket *socket, int backlog_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_read-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_read","text":"aws_socket_read(socket, buffer, amount_read)\n\nReads from the socket. This call is non-blocking and will return AWS_IO_SOCKET_READ_WOULD_BLOCK if no data is available. read is the amount of data read into buffer.\n\nAttempts to read enough to fill all remaining space in the buffer, from buffer->len to buffer->capacity. buffer->len is updated to reflect the buffer's new length.\n\nUse aws_socket_subscribe_to_readable_events() to receive notifications of when the socket goes readable.\n\nNOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\nPrototype\n\nint aws_socket_read(struct aws_socket *socket, struct aws_byte_buf *buffer, size_t *amount_read);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_set_options-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_set_options","text":"aws_socket_set_options(socket, options)\n\nSets new socket options on the underlying socket. This is mainly useful in context of accepting a new connection via: on\\_incoming\\_connection(). options is copied.\n\nPrototype\n\nint aws_socket_set_options(struct aws_socket *socket, const struct aws_socket_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_shutdown_dir-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_shutdown_dir","text":"aws_socket_shutdown_dir(socket, dir)\n\nCalls shutdown() on the socket based on direction.\n\nPrototype\n\nint aws_socket_shutdown_dir(struct aws_socket *socket, enum aws_channel_direction dir);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_start_accept-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_socket_start_accept","text":"aws_socket_start_accept(socket, accept_loop, on_accept_result, user_data)\n\nTCP, LOCAL and VSOCK only. The socket will begin accepting new connections. This is an asynchronous operation. New connections or errors will arrive via the on_accept_result callback.\n\naws_socket_bind() and aws_socket_listen() must be called before calling this function.\n\nPrototype\n\nint aws_socket_start_accept( struct aws_socket *socket, struct aws_event_loop *accept_loop, aws_socket_on_accept_result_fn *on_accept_result, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_stop_accept-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_socket_stop_accept","text":"aws_socket_stop_accept(socket)\n\nTCP, LOCAL and VSOCK only. The listening socket will stop accepting new connections. It is safe to call [awssocketstart_accept](@ref)() again after this operation. This can be called from any thread but be aware, on some platforms, if you call this from outside of the current event loop's thread, it will block until the event loop finishes processing the request for unsubscribe in it's own thread.\n\nPrototype\n\nint aws_socket_stop_accept(struct aws_socket *socket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_subscribe_to_readable_events-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_socket_subscribe_to_readable_events","text":"aws_socket_subscribe_to_readable_events(socket, on_readable, user_data)\n\nSubscribes on_readable to notifications when the socket goes readable (edge-triggered). Errors will also be recieved in the callback.\n\nNote! This function is technically not thread safe, but we do not enforce which thread you call from. It's your responsibility to either call this in safely (e.g. just don't call it in parallel from multiple threads) or schedule a task to call it. If you call it before your first call to read, it will be fine.\n\nPrototype\n\nint aws_socket_subscribe_to_readable_events( struct aws_socket *socket, aws_socket_on_readable_fn *on_readable, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_socket_write-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_socket_write","text":"aws_socket_write(socket, cursor, written_fn, user_data)\n\nWrites to the socket. This call is non-blocking and will attempt to write as much as it can, but will queue any remaining portion of the data for write when available. written_fn will be invoked once the entire cursor has been written, or the write failed or was cancelled.\n\nNOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\nFor client sockets, connect() and aws_socket_assign_to_event_loop() must be called before calling this.\n\nFor incoming sockets from a listener, aws_socket_assign_to_event_loop() must be called first.\n\nPrototype\n\nint aws_socket_write( struct aws_socket *socket, const struct aws_byte_cursor *cursor, aws_socket_on_write_completed_fn *written_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_bytes-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_string_bytes","text":"aws_string_bytes(str)\n\nEquivalent to str->bytes.\n\nPrototype\n\nAWS_STATIC_IMPL const uint8_t *aws_string_bytes(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_c_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_string_c_str","text":"aws_string_c_str(str)\n\nEquivalent to (const char *)str->bytes.\n\nPrototype\n\nAWS_STATIC_IMPL const char *aws_string_c_str(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_clone_or_reuse-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_clone_or_reuse","text":"aws_string_clone_or_reuse(allocator, str)\n\nIf the string was dynamically allocated, clones it. If the string was statically allocated (i.e. has no allocator), returns the original string.\n\nPrototype\n\nstruct aws_string *aws_string_clone_or_reuse(struct aws_allocator *allocator, const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_compare-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_compare","text":"aws_string_compare(a, b)\n\nCompares lexicographical ordering of two strings. This is a binary byte-by-byte comparison, treating bytes as unsigned integers. It is suitable for either textual or binary data and is unaware of unicode or any other byte encoding. If both strings are identical in the bytes of the shorter string, then the longer string is lexicographically after the shorter.\n\nReturns a positive number if string a > string b. (i.e., string a is lexicographically after string b.) Returns zero if string a = string b. Returns negative number if string a < string b.\n\nPrototype\n\nint aws_string_compare(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_string_destroy","text":"aws_string_destroy(str)\n\nDeallocate string.\n\nPrototype\n\nvoid aws_string_destroy(struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_destroy_secure-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_string_destroy_secure","text":"aws_string_destroy_secure(str)\n\nZeroes out the data bytes of string and then deallocates the memory. Not safe to run on a string created with AWS_STATIC_STRING_FROM_LITERAL.\n\nPrototype\n\nvoid aws_string_destroy_secure(struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq","text":"aws_string_eq(a, b)\n\nReturns true if bytes of string are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_byte_buf-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_byte_buf","text":"aws_string_eq_byte_buf(str, buf)\n\nReturns true if bytes of string and buffer are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq_byte_buf(const struct aws_string *str, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_byte_buf_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_byte_buf_ignore_case","text":"aws_string_eq_byte_buf_ignore_case(str, buf)\n\nReturns true if bytes of string and buffer are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_byte_buf_ignore_case(const struct aws_string *str, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_byte_cursor-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_byte_cursor","text":"aws_string_eq_byte_cursor(str, cur)\n\nReturns true if bytes of string and cursor are the same, false otherwise.\n\nPrototype\n\nbool aws_string_eq_byte_cursor(const struct aws_string *str, const struct aws_byte_cursor *cur);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_byte_cursor_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_byte_cursor_ignore_case","text":"aws_string_eq_byte_cursor_ignore_case(str, cur)\n\nReturns true if bytes of string and cursor are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_byte_cursor_ignore_case(const struct aws_string *str, const struct aws_byte_cursor *cur);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_c_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_c_str","text":"aws_string_eq_c_str(str, c_str)\n\nPrototype\n\nbool aws_string_eq_c_str(const struct aws_string *str, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_c_str_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_c_str_ignore_case","text":"aws_string_eq_c_str_ignore_case(str, c_str)\n\nReturns true if bytes of strings are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_c_str_ignore_case(const struct aws_string *str, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_eq_ignore_case-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_eq_ignore_case","text":"aws_string_eq_ignore_case(a, b)\n\nReturns true if bytes of string are equivalent, using a case-insensitive comparison.\n\nPrototype\n\nbool aws_string_eq_ignore_case(const struct aws_string *a, const struct aws_string *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_string_is_valid","text":"aws_string_is_valid(str)\n\nEvaluates the set of properties that define the shape of all valid aws_string structures. It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion).\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_string_is_valid(const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_new_from_array-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_new_from_array","text":"aws_string_new_from_array(allocator, bytes, len)\n\nAllocate a new string with the same contents as array.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_array(struct aws_allocator *allocator, const uint8_t *bytes, size_t len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_new_from_buf-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_new_from_buf","text":"aws_string_new_from_buf(allocator, buf)\n\nAllocate a new string with the same contents as buf.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_buf(struct aws_allocator *allocator, const struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_new_from_c_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_new_from_c_str","text":"aws_string_new_from_c_str(allocator, c_str)\n\nConstructor functions which copy data from null-terminated C-string or array of bytes.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_c_str(struct aws_allocator *allocator, const char *c_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_new_from_cursor-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_new_from_cursor","text":"aws_string_new_from_cursor(allocator, cursor)\n\nAllocate a new string with the same contents as cursor.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_cursor(struct aws_allocator *allocator, const struct aws_byte_cursor *cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_new_from_string-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_new_from_string","text":"aws_string_new_from_string(allocator, str)\n\nAllocate a new string with the same contents as another string.\n\nPrototype\n\nstruct aws_string *aws_string_new_from_string(struct aws_allocator *allocator, const struct aws_string *str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_string_to_log_level-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_string_to_log_level","text":"aws_string_to_log_level(level_string, log_level)\n\nConverts a c-string constant to a log level value. Uses case-insensitive comparison and simply iterates all possibilities until a match or nothing remains. If no match is found, AWS_OP_ERR is returned.\n\nPrototype\n\nint aws_string_to_log_level(const char *level_string, enum aws_log_level *log_level);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_size_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_size_checked","text":"aws_sub_size_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_size_checked(size_t a, size_t b, size_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_size_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_size_saturating","text":"aws_sub_size_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL size_t aws_sub_size_saturating(size_t a, size_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_u32_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_u32_checked","text":"aws_sub_u32_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_u32_checked(uint32_t a, uint32_t b, uint32_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_u32_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_u32_saturating","text":"aws_sub_u32_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL uint32_t aws_sub_u32_saturating(uint32_t a, uint32_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_u64_checked-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_u64_checked","text":"aws_sub_u64_checked(a, b, r)\n\nIf a - b overflows, returns AWS_OP_ERR; otherwise subtracts a - b, returns the result in *r, and returns AWS_OP_SUCCESS.\n\nPrototype\n\nAWS_STATIC_IMPL int aws_sub_u64_checked(uint64_t a, uint64_t b, uint64_t *r);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sub_u64_saturating-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_sub_u64_saturating","text":"aws_sub_u64_saturating(a, b)\n\nSubtracts a - b. If the result overflows returns 0.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_sub_u64_saturating(uint64_t a, uint64_t b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_decrypt-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_decrypt","text":"aws_symmetric_cipher_decrypt(cipher, to_decrypt, out)\n\nDecrypts the value in to_decrypt and writes the decrypted data into out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of to_decrypt + an extra BLOCK to account for padding etc...\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_decrypt( struct aws_symmetric_cipher *cipher, struct aws_byte_cursor to_decrypt, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_destroy","text":"aws_symmetric_cipher_destroy(cipher)\n\nCleans up internal resources and state for cipher and then deallocates it.\n\nPrototype\n\nvoid aws_symmetric_cipher_destroy(struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_encrypt-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_encrypt","text":"aws_symmetric_cipher_encrypt(cipher, to_encrypt, out)\n\nEncrypts the value in to_encrypt and writes the encrypted data into out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the encrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of to_encrypt + an extra BLOCK to account for padding etc...\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_encrypt( struct aws_symmetric_cipher *cipher, struct aws_byte_cursor to_encrypt, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_finalize_decryption-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_finalize_decryption","text":"aws_symmetric_cipher_finalize_decryption(cipher, out)\n\nDecrypts any remaining data that was reserved for final padding, loads GMACs etc... and if there is any writes any remaining decrypted data to out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of 2 BLOCKs to account for padding etc...\n\nAfter invoking this function, you MUST call aws_symmetric_cipher_reset() before invoking any encrypt/decrypt operations on this cipher again.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_finalize_decryption(struct aws_symmetric_cipher *cipher, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_finalize_encryption-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_finalize_encryption","text":"aws_symmetric_cipher_finalize_encryption(cipher, out)\n\nEncrypts any remaining data that was reserved for final padding, loads GMACs etc... and if there is any writes any remaining encrypted data to out. If out is dynamic it will be expanded. If it is not, and out is not large enough to handle the decrypted output, the call will fail. If you're trying to optimize to use a stack based array or something, make sure it's at least as large as the size of 2 BLOCKs to account for padding etc...\n\nAfter invoking this function, you MUST call aws_symmetric_cipher_reset() before invoking any encrypt/decrypt operations on this cipher again.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_finalize_encryption(struct aws_symmetric_cipher *cipher, struct aws_byte_buf *out);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_get_initialization_vector-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_get_initialization_vector","text":"aws_symmetric_cipher_get_initialization_vector(cipher)\n\nGets the original intialization vector as a cursor. The memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API.\n\nUnlike some other fields, this value does not change after the inital construction of the cipher.\n\nFor some algorithms, such as AES Keywrap, this will return an empty cursor.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_initialization_vector( const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_get_key-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_get_key","text":"aws_symmetric_cipher_get_key(cipher)\n\nGets the original key.\n\nThe memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API.\n\nUnlike some other fields, this value does not change after the inital construction of the cipher.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_key(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_get_tag-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_get_tag","text":"aws_symmetric_cipher_get_tag(cipher)\n\nGets the current GMAC tag. If not AES GCM, this function will just return an empty cursor. The memory in this cursor is unsafe as it refers to the internal buffer. This was done because the use case doesn't require fetching these during an encryption or decryption operation and it dramatically simplifies the API. Only use this function between other calls to this API as any function call can alter the value of this tag.\n\nIf you need to access it in a different pattern, copy the values to your own buffer first.\n\nPrototype\n\nstruct aws_byte_cursor aws_symmetric_cipher_get_tag(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_is_good-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_is_good","text":"aws_symmetric_cipher_is_good(cipher)\n\nReturns true if the state of the cipher is good, and otherwise returns false. Most operations, other than aws_symmetric_cipher_reset() will fail if this function is returning false. aws_symmetric_cipher_reset() will reset the state to a good state if possible.\n\nPrototype\n\nbool aws_symmetric_cipher_is_good(const struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_symmetric_cipher_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_symmetric_cipher_reset","text":"aws_symmetric_cipher_reset(cipher)\n\nResets the cipher state for starting a new encrypt or decrypt operation. Note encrypt/decrypt cannot be mixed on the same cipher without a call to reset in between them. However, this leaves the key, iv etc... materials setup for immediate reuse.\n\nreturns AWS_OP_SUCCESS on success. Call aws_last_error() to determine the failure cause if it returns AWS_OP_ERR;\n\nPrototype\n\nint aws_symmetric_cipher_reset(struct aws_symmetric_cipher *cipher);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_sys_clock_get_ticks-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_sys_clock_get_ticks","text":"aws_sys_clock_get_ticks(timestamp)\n\nGet ticks in nanoseconds (usually 100 nanosecond precision) on the system clock. Reflects actual system time via nanoseconds since unix epoch. Use with care since an inaccurately set clock will probably cause bugs. On success, timestamp will be set.\n\nPrototype\n\nint aws_sys_clock_get_ticks(uint64_t *timestamp);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_system_info_processor_count-Tuple{}","page":"Home","title":"LibAWSCRT.aws_system_info_processor_count","text":"aws_system_info_processor_count()\n\nPrototype\n\nsize_t aws_system_info_processor_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_init-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_task_init","text":"aws_task_init(task, fn, arg, type_tag)\n\nInit an aws_task\n\nPrototype\n\nvoid aws_task_init(struct aws_task *task, aws_task_fn *fn, void *arg, const char *type_tag);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_run-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_run","text":"aws_task_run(task, status)\n\nPrototype\n\nvoid aws_task_run(struct aws_task *task, enum aws_task_status status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_cancel_task","text":"aws_task_scheduler_cancel_task(scheduler, task)\n\nRemoves task from the scheduler and invokes the task with the AWS_TASK_STATUS_CANCELED status.\n\nPrototype\n\nvoid aws_task_scheduler_cancel_task(struct aws_task_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_clean_up","text":"aws_task_scheduler_clean_up(scheduler)\n\nEmpties and executes all queued tasks, passing the AWS_TASK_STATUS_CANCELED status to the task function. Cleans up any memory allocated, and prepares the instance for reuse or deletion.\n\nPrototype\n\nvoid aws_task_scheduler_clean_up(struct aws_task_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_has_tasks-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_has_tasks","text":"aws_task_scheduler_has_tasks(scheduler, next_task_time)\n\nReturns whether the scheduler has any scheduled tasks. next_task_time (optional) will be set to time of the next task, note that 0 will be set if tasks were added via aws_task_scheduler_schedule_now() and UINT64_MAX will be set if no tasks are scheduled at all.\n\nPrototype\n\nbool aws_task_scheduler_has_tasks(const struct aws_task_scheduler *scheduler, uint64_t *next_task_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_init","text":"aws_task_scheduler_init(scheduler, alloc)\n\nInitializes a task scheduler instance.\n\nPrototype\n\nint aws_task_scheduler_init(struct aws_task_scheduler *scheduler, struct aws_allocator *alloc);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_is_valid-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_is_valid","text":"aws_task_scheduler_is_valid(scheduler)\n\nPrototype\n\nbool aws_task_scheduler_is_valid(const struct aws_task_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_run_all-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_run_all","text":"aws_task_scheduler_run_all(scheduler, current_time)\n\nSequentially execute all tasks scheduled to run at, or before current_time. AWS_TASK_STATUS_RUN_READY will be passed to the task function as the task status.\n\nIf a task schedules another task, the new task will not be executed until the next call to this function.\n\nPrototype\n\nvoid aws_task_scheduler_run_all(struct aws_task_scheduler *scheduler, uint64_t current_time);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_schedule_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_schedule_future","text":"aws_task_scheduler_schedule_future(scheduler, task, time_to_run)\n\nSchedules a task to run at time_to_run. The task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_task_scheduler_schedule_future( struct aws_task_scheduler *scheduler, struct aws_task *task, uint64_t time_to_run);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_scheduler_schedule_now-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_task_scheduler_schedule_now","text":"aws_task_scheduler_schedule_now(scheduler, task)\n\nSchedules a task to run immediately. The task should not be cleaned up or modified until its function is executed.\n\nPrototype\n\nvoid aws_task_scheduler_schedule_now(struct aws_task_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_task_status_to_c_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_task_status_to_c_str","text":"aws_task_status_to_c_str(status)\n\nConvert a status value to a c-string suitable for logging\n\nPrototype\n\nconst char *aws_task_status_to_c_str(enum aws_task_status status);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_text_detect_encoding-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_text_detect_encoding","text":"aws_text_detect_encoding(bytes, size)\n\nPrototype\n\nAWS_STATIC_IMPL enum aws_text_encoding aws_text_detect_encoding(const uint8_t *bytes, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_text_is_utf8-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_text_is_utf8","text":"aws_text_is_utf8(bytes, size)\n\nPrototype\n\nAWS_STATIC_IMPL bool aws_text_is_utf8(const uint8_t *bytes, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_call_once-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_call_once","text":"aws_thread_call_once(flag, call_once, user_data)\n\nPrototype\n\nvoid aws_thread_call_once(aws_thread_once *flag, void (*call_once)(void *), void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_clean_up","text":"aws_thread_clean_up(thread)\n\nCleans up the thread handle. Don't call this on a managed thread. If you wish to join the thread, you must join before calling this function.\n\nPrototype\n\nvoid aws_thread_clean_up(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_current_at_exit-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_current_at_exit","text":"aws_thread_current_at_exit(callback, user_data)\n\nAdds a callback to the chain to be called when the current thread joins. Callbacks are called from the current thread, in the reverse order they were added, after the thread function returns. If not called from within an aws_thread, has no effect.\n\nPrototype\n\nint aws_thread_current_at_exit(aws_thread_atexit_fn *callback, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_current_name-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_current_name","text":"aws_thread_current_name(allocator, out_name)\n\nGets name of the current thread. Caller is responsible for destroying returned string. If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is set to NULL. If underlying OS call fails, AWS_ERROR_SYS_CALL_FAILURE will be raised If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED will be raised\n\nPrototype\n\nint aws_thread_current_name(struct aws_allocator *allocator, struct aws_string **out_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_current_sleep-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_current_sleep","text":"aws_thread_current_sleep(nanos)\n\nSleeps the current thread by nanos.\n\nPrototype\n\nvoid aws_thread_current_sleep(uint64_t nanos);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_current_thread_id-Tuple{}","page":"Home","title":"LibAWSCRT.aws_thread_current_thread_id","text":"aws_thread_current_thread_id()\n\nReturns the thread id of the calling thread.\n\nPrototype\n\naws_thread_id_t aws_thread_current_thread_id(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_decrement_unjoined_count-Tuple{}","page":"Home","title":"LibAWSCRT.aws_thread_decrement_unjoined_count","text":"aws_thread_decrement_unjoined_count()\n\nDecrements the count of unjoined threads in the managed thread system. Used by managed threads and event loop threads. Additional usage requires the user to join corresponding threads themselves and correctly increment/decrement even in the face of launch/join errors.\n\naws_thread_join_all_managed() will not return until this count has gone to zero.\n\nPrototype\n\nvoid aws_thread_decrement_unjoined_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_get_detach_state-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_get_detach_state","text":"aws_thread_get_detach_state(thread)\n\nGets the detach state of the thread. For example, is it safe to call join on this thread? Has it been detached()?\n\nPrototype\n\nenum aws_thread_detach_state aws_thread_get_detach_state(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_get_id-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_get_id","text":"aws_thread_get_id(thread)\n\nGets the id of thread\n\nPrototype\n\naws_thread_id_t aws_thread_get_id(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_id_t_to_string-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_id_t_to_string","text":"aws_thread_id_t_to_string(thread_id, buffer, bufsz)\n\nConverts an aws_thread_id_t to a c-string. For portability, aws_thread_id_t must not be printed directly. Intended primarily to support building log lines that include the thread id in them. The parameter buffer must point-to a char buffer of length bufsz == [AWSTHREADIDTREPR_BUFSZ](@ref). The thread id representation is returned in buffer.\n\nPrototype\n\nint aws_thread_id_t_to_string(aws_thread_id_t thread_id, char *buffer, size_t bufsz);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_increment_unjoined_count-Tuple{}","page":"Home","title":"LibAWSCRT.aws_thread_increment_unjoined_count","text":"aws_thread_increment_unjoined_count()\n\nIncrements the count of unjoined threads in the managed thread system. Used by managed threads and event loop threads. Additional usage requires the user to join corresponding threads themselves and correctly increment/decrement even in the face of launch/join errors.\n\naws_thread_join_all_managed() will not return until this count has gone to zero.\n\nPrototype\n\nvoid aws_thread_increment_unjoined_count(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_init-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_init","text":"aws_thread_init(thread, allocator)\n\nInitializes a new platform specific thread object struct (not the os-level thread itself).\n\nPrototype\n\nint aws_thread_init(struct aws_thread *thread, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_join-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_join","text":"aws_thread_join(thread)\n\nJoins the calling thread to a thread instance. Returns when thread is finished. Calling this from the associated OS thread will cause a deadlock.\n\nPrototype\n\nint aws_thread_join(struct aws_thread *thread);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_join_all_managed-Tuple{}","page":"Home","title":"LibAWSCRT.aws_thread_join_all_managed","text":"aws_thread_join_all_managed()\n\nBlocking call that waits for all managed threads to complete their join call. This can only be called from the main thread or a non-managed thread.\n\nThis gets called automatically from library cleanup.\n\nBy default the wait is unbounded, but that default can be overridden via aws_thread_set_managed_join_timeout_ns()\n\nPrototype\n\nint aws_thread_join_all_managed(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_launch-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_thread_launch","text":"aws_thread_launch(thread, func, arg, options)\n\nCreates an OS level thread and associates it with func. context will be passed to func when it is executed. options will be applied to the thread if they are applicable for the platform.\n\nAfter launch, you may join on the thread. A successfully launched thread must have clean_up called on it in order to avoid a handle leak. If you do not join before calling clean_up, the thread will become detached.\n\nManaged threads must not have join or clean_up called on them by external code.\n\nPrototype\n\nint aws_thread_launch( struct aws_thread *thread, void (*func)(void *arg), void *arg, const struct aws_thread_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_name-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_name","text":"aws_thread_name(allocator, thread_id, out_name)\n\nGets name of the thread. Caller is responsible for destroying returned string. If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is set to NULL. If underlying OS call fails, AWS_ERROR_SYS_CALL_FAILURE will be raised If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED will be raised\n\nPrototype\n\nint aws_thread_name( struct aws_allocator *allocator, aws_thread_id_t thread_id, struct aws_string **out_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_acquire","text":"aws_thread_scheduler_acquire(scheduler)\n\nAcquire a reference to the scheduler.\n\nPrototype\n\nvoid aws_thread_scheduler_acquire(struct aws_thread_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_cancel_task-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_cancel_task","text":"aws_thread_scheduler_cancel_task(scheduler, task)\n\nCancel a task that has been scheduled. The cancellation callback will be invoked in the background thread. This function is slow, so please don't do it in the hot path for your code.\n\nPrototype\n\nvoid aws_thread_scheduler_cancel_task(struct aws_thread_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_new","text":"aws_thread_scheduler_new(allocator, thread_options)\n\nCreates a new instance of a thread scheduler. This object receives scheduled tasks and executes them inside a background thread. On success, this function returns an instance with a ref-count of 1. On failure it returns NULL.\n\nthread_options are optional.\n\nThe semantics of this interface conform to the semantics of aws_task_scheduler.\n\nPrototype\n\nstruct aws_thread_scheduler *aws_thread_scheduler_new( struct aws_allocator *allocator, const struct aws_thread_options *thread_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_release","text":"aws_thread_scheduler_release(scheduler)\n\nRelease a reference to the scheduler.\n\nPrototype\n\nvoid aws_thread_scheduler_release(const struct aws_thread_scheduler *scheduler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_schedule_future-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_schedule_future","text":"aws_thread_scheduler_schedule_future(scheduler, task, time_to_run)\n\nSchedules a task to run in the future. time_to_run is the absolute time from the system hw_clock.\n\nPrototype\n\nvoid aws_thread_scheduler_schedule_future( struct aws_thread_scheduler *scheduler, struct aws_task *task, uint64_t time_to_run);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_scheduler_schedule_now-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_scheduler_schedule_now","text":"aws_thread_scheduler_schedule_now(scheduler, task)\n\nSchedules a task to run as soon as possible.\n\nPrototype\n\nvoid aws_thread_scheduler_schedule_now(struct aws_thread_scheduler *scheduler, struct aws_task *task);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_set_managed_join_timeout_ns-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_thread_set_managed_join_timeout_ns","text":"aws_thread_set_managed_join_timeout_ns(timeout_in_ns)\n\nOverrides how long, in nanoseconds, that aws_thread_join_all_managed will wait for threads to complete. A value of zero will result in an unbounded wait.\n\nPrototype\n\nvoid aws_thread_set_managed_join_timeout_ns(uint64_t timeout_in_ns);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_thread_thread_id_equal-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_thread_thread_id_equal","text":"aws_thread_thread_id_equal(t1, t2)\n\nCompare thread ids.\n\nPrototype\n\nbool aws_thread_thread_id_equal(aws_thread_id_t t1, aws_thread_id_t t2);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_timegm-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_timegm","text":"aws_timegm(t)\n\nCross platform friendly version of timegm\n\nPrototype\n\ntime_t aws_timegm(struct tm *const t);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_timestamp_convert-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_timestamp_convert","text":"aws_timestamp_convert(timestamp, convert_from, convert_to, remainder)\n\nConverts 'timestamp' from unit 'convert_from' to unit 'convert_to', if the units are the same then 'timestamp' is returned. If 'remainder' is NOT NULL, it will be set to the remainder if convert_from is a more precise unit than convert_to. To avoid unnecessary branching, 'remainder' is not zero initialized in this function, be sure to set it to 0 first if you care about that kind of thing. If conversion would lead to integer overflow, the timestamp returned will be the highest possible time that is representable, i.e. UINT64_MAX.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_timestamp_convert( uint64_t timestamp, enum aws_timestamp_unit convert_from, enum aws_timestamp_unit convert_to, uint64_t *remainder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_timestamp_convert_u64-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_timestamp_convert_u64","text":"aws_timestamp_convert_u64(ticks, old_frequency, new_frequency, remainder)\n\nMore general form of aws_timestamp_convert that takes arbitrary frequencies rather than the timestamp enum.\n\nPrototype\n\nAWS_STATIC_IMPL uint64_t aws_timestamp_convert_u64(uint64_t ticks, uint64_t old_frequency, uint64_t new_frequency, uint64_t *remainder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_alpn_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_alpn_handler_new","text":"aws_tls_alpn_handler_new(allocator, on_protocol_negotiated, user_data)\n\nCreates a channel handler, for client or server mode, that handles alpn. This isn't necessarily required since you can always call aws_tls_handler_protocol in the aws_tls_on_negotiation_result_fn callback, but this makes channel bootstrap easier to handle.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_alpn_handler_new( struct aws_allocator *allocator, aws_tls_on_protocol_negotiated on_protocol_negotiated, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_client_ctx_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_client_ctx_new","text":"aws_tls_client_ctx_new(alloc, options)\n\nCreates a new client ctx. This ctx can be used for the lifetime of the application assuming you want the same options for every outgoing connection. Options will be copied.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_client_ctx_new( struct aws_allocator *alloc, const struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_client_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_client_handler_new","text":"aws_tls_client_handler_new(allocator, options, slot)\n\nCreates a new tls channel handler in client mode. Options will be copied. You must call aws_tls_client_handler_start_negotiation and wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing application data.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_client_handler_new( struct aws_allocator *allocator, struct aws_tls_connection_options *options, struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_client_handler_start_negotiation-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_client_handler_start_negotiation","text":"aws_tls_client_handler_start_negotiation(handler)\n\nKicks off the negotiation process. This function must be called when in client mode to initiate the TLS handshake. Once the handshake has completed the aws_tls_on_negotiation_result_fn will be invoked.\n\nPrototype\n\nint aws_tls_client_handler_start_negotiation(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_clean_up","text":"aws_tls_connection_options_clean_up(connection_options)\n\nCleans up resources in aws_tls_connection_options. This can be called immediately after initializing a tls handler, or if using the bootstrap api, immediately after asking for a channel.\n\nPrototype\n\nvoid aws_tls_connection_options_clean_up(struct aws_tls_connection_options *connection_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_copy-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_copy","text":"aws_tls_connection_options_copy(to, from)\n\nCopies 'from' to 'to'\n\nPrototype\n\nint aws_tls_connection_options_copy( struct aws_tls_connection_options *to, const struct aws_tls_connection_options *from);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_init_from_ctx-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_init_from_ctx","text":"aws_tls_connection_options_init_from_ctx(conn_options, ctx)\n\nInitializes default connection options from an instance ot aws_tls_ctx.\n\nPrototype\n\nvoid aws_tls_connection_options_init_from_ctx( struct aws_tls_connection_options *conn_options, struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_set_alpn_list-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_set_alpn_list","text":"aws_tls_connection_options_set_alpn_list(conn_options, allocator, alpn_list)\n\nSets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported. alpn_list is copied. This value is already inherited from aws_tls_ctx, but the aws_tls_ctx is expensive, and should be used across as many connections as possible. If you want to set this per connection, set it here.\n\nPrototype\n\nint aws_tls_connection_options_set_alpn_list( struct aws_tls_connection_options *conn_options, struct aws_allocator *allocator, const char *alpn_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_set_callbacks-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_set_callbacks","text":"aws_tls_connection_options_set_callbacks(conn_options, on_negotiation_result, on_data_read, on_error, user_data)\n\nSets callbacks for use with a tls connection.\n\nPrototype\n\nvoid aws_tls_connection_options_set_callbacks( struct aws_tls_connection_options *conn_options, aws_tls_on_negotiation_result_fn *on_negotiation_result, aws_tls_on_data_read_fn *on_data_read, aws_tls_on_error_fn *on_error, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_connection_options_set_server_name-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_connection_options_set_server_name","text":"aws_tls_connection_options_set_server_name(conn_options, allocator, server_name)\n\nSets server name to use for the SNI extension (supported everywhere), as well as x.509 validation. If you don't set this, your x.509 validation will likely fail.\n\nPrototype\n\nint aws_tls_connection_options_set_server_name( struct aws_tls_connection_options *conn_options, struct aws_allocator *allocator, const struct aws_byte_cursor *server_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_acquire","text":"aws_tls_ctx_acquire(ctx)\n\nIncrements the reference count on the tls context, allowing the caller to take a reference to it.\n\nReturns the same tls context passed in.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_ctx_acquire(struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_clean_up","text":"aws_tls_ctx_options_clean_up(options)\n\nCleans up resources allocated by init_* functions\n\nPrototype\n\nvoid aws_tls_ctx_options_clean_up(struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls","text":"aws_tls_ctx_options_init_client_mtls(options, allocator, cert, pkey)\n\nInitializes options for use with mutual tls in client mode. cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM armored.\n\nNOTE: This is unsupported on iOS.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const struct aws_byte_cursor *cert, const struct aws_byte_cursor *pkey);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_from_path-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_from_path","text":"aws_tls_ctx_options_init_client_mtls_from_path(options, allocator, cert_path, pkey_path)\n\nInitializes options for use with mutual tls in client mode. cert_path and pkey_path are paths to files on disk. cert_path and pkey_path are treated as PKCS#7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nNOTE: This is unsupported on iOS.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_path, const char *pkey_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_from_system_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_from_system_path","text":"aws_tls_ctx_options_init_client_mtls_from_system_path(options, allocator, cert_reg_path)\n\nInitializes options for use with mutual tls in client mode. cert_reg_path is the path to a system installed certficate/private key pair. Example: CurrentUser\\MY\\<thumprint>\n\nNOTE: This only works on Windows.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_from_system_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_reg_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_pkcs12-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_pkcs12","text":"aws_tls_ctx_options_init_client_mtls_pkcs12(options, allocator, pkcs12, pkcs_pwd)\n\nInitializes options for use with mutual tls in client mode. pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied. pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_pkcs12( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *pkcs12, struct aws_byte_cursor *pkcs_pwd);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_pkcs12_from_path-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_pkcs12_from_path","text":"aws_tls_ctx_options_init_client_mtls_pkcs12_from_path(options, allocator, pkcs12_path, pkcs_pwd)\n\nInitializes options for use with mutual tls in client mode. pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_pkcs12_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *pkcs12_path, const struct aws_byte_cursor *pkcs_pwd);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_with_custom_key_operations-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_with_custom_key_operations","text":"aws_tls_ctx_options_init_client_mtls_with_custom_key_operations(options, allocator, custom, cert_file_contents)\n\nInitializes options for use with mutual TLS in client mode, where private key operations are handled by custom code.\n\nNote: cert_file_contents will be copied into a new buffer after this function is called, so you do not need to keep that data alive after calling this function.\n\nParameters\n\noptions: aws_tls_ctx_options to be initialized.\nallocator: Allocator to use.\ncustom: Options for custom key operations.\ncert_file_contents: The contents of a certificate file.\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_with_custom_key_operations( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_custom_key_op_handler *custom, const struct aws_byte_cursor *cert_file_contents);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_client_mtls_with_pkcs11-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_client_mtls_with_pkcs11","text":"aws_tls_ctx_options_init_client_mtls_with_pkcs11(options, allocator, pkcs11_options)\n\nInitializes options for use with mutual TLS in client mode, where a PKCS#11 library provides access to the private key.\n\nNOTE: This only works on Unix devices.\n\nParameters\n\noptions: aws_tls_ctx_options to be initialized.\nallocator: Allocator to use.\npkcs11_options: Options for using PKCS#11 (contents are copied)\n\nPrototype\n\nint aws_tls_ctx_options_init_client_mtls_with_pkcs11( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const struct aws_tls_ctx_pkcs11_options *pkcs11_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_default_client-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_default_client","text":"aws_tls_ctx_options_init_default_client(options, allocator)\n\n****************************** tls options init stuff **********************\n\nInitializes options with default client options\n\nPrototype\n\nvoid aws_tls_ctx_options_init_default_client( struct aws_tls_ctx_options *options, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_default_server-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_default_server","text":"aws_tls_ctx_options_init_default_server(options, allocator, cert, pkey)\n\nInitializes options for use with in server mode. cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM armored.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *cert, struct aws_byte_cursor *pkey);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_default_server_from_path-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_default_server_from_path","text":"aws_tls_ctx_options_init_default_server_from_path(options, allocator, cert_path, pkey_path)\n\nInitializes options for use with in server mode. cert_path and pkey_path are paths to files on disk. cert_path and pkey_path are treated as PKCS#7 PEM armored. They are loaded from disk and stored in buffers internally.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_path, const char *pkey_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_default_server_from_system_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_default_server_from_system_path","text":"aws_tls_ctx_options_init_default_server_from_system_path(options, allocator, cert_reg_path)\n\nInitializes options for use with server mode. cert_reg_path is the path to a system installed certficate/private key pair. Example: CurrentUser\\MY\\<thumprint>\n\nNOTE: This only works on Windows.\n\nPrototype\n\nint aws_tls_ctx_options_init_default_server_from_system_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *cert_reg_path);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_server_pkcs12-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_server_pkcs12","text":"aws_tls_ctx_options_init_server_pkcs12(options, allocator, pkcs12, pkcs_password)\n\nInitializes options for use in server mode. pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied. pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_server_pkcs12( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, struct aws_byte_cursor *pkcs12, struct aws_byte_cursor *pkcs_password);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_init_server_pkcs12_from_path-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_init_server_pkcs12_from_path","text":"aws_tls_ctx_options_init_server_pkcs12_from_path(options, allocator, pkcs12_path, pkcs_password)\n\nInitializes options for use in server mode. pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\nNOTE: This only works on Apple devices.\n\nPrototype\n\nint aws_tls_ctx_options_init_server_pkcs12_from_path( struct aws_tls_ctx_options *options, struct aws_allocator *allocator, const char *pkcs12_path, struct aws_byte_cursor *pkcs_password);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_override_default_trust_store-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_override_default_trust_store","text":"aws_tls_ctx_options_override_default_trust_store(options, ca_file)\n\nOverride the default trust store. ca_file is a buffer containing a PEM armored chain of trusted CA certificates. ca_file is copied.\n\nPrototype\n\nint aws_tls_ctx_options_override_default_trust_store( struct aws_tls_ctx_options *options, const struct aws_byte_cursor *ca_file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_override_default_trust_store_from_path-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_override_default_trust_store_from_path","text":"aws_tls_ctx_options_override_default_trust_store_from_path(options, ca_path, ca_file)\n\nOverride the default trust store. ca_path is a path to a directory on disk containing trusted certificates. This is only supported on Unix systems (otherwise this parameter is ignored). ca_file is a path to a file on disk containing trusted certificates. ca_file is loaded from disk and stored in an internal buffer.\n\nPrototype\n\nint aws_tls_ctx_options_override_default_trust_store_from_path( struct aws_tls_ctx_options *options, const char *ca_path, const char *ca_file);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_alpn_list-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_alpn_list","text":"aws_tls_ctx_options_set_alpn_list(options, alpn_list)\n\nSets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported. alpn_list is copied.\n\nPrototype\n\nint aws_tls_ctx_options_set_alpn_list(struct aws_tls_ctx_options *options, const char *alpn_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_extension_data-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_extension_data","text":"aws_tls_ctx_options_set_extension_data(options, extension_data)\n\nWhen implementing BYO_CRYPTO, if you need extra data to pass to your tls implementation, set it here. The lifetime of extension_data must outlive the options object and be cleaned up after options is cleaned up.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_extension_data(struct aws_tls_ctx_options *options, void *extension_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_keychain_path-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_keychain_path","text":"aws_tls_ctx_options_set_keychain_path(options, keychain_path_cursor)\n\n\\deprecated \n\nSets a custom keychain path for storing the cert and pkey with mutual tls in client mode.\n\nNOTE: This only works on MacOS.\n\nPrototype\n\nint aws_tls_ctx_options_set_keychain_path( struct aws_tls_ctx_options *options, struct aws_byte_cursor *keychain_path_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_minimum_tls_version-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_minimum_tls_version","text":"aws_tls_ctx_options_set_minimum_tls_version(options, minimum_tls_version)\n\nSets the minimum TLS version to allow.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_minimum_tls_version( struct aws_tls_ctx_options *options, enum aws_tls_versions minimum_tls_version);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_tls_cipher_preference-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_tls_cipher_preference","text":"aws_tls_ctx_options_set_tls_cipher_preference(options, cipher_pref)\n\nSets preferred TLS Cipher List\n\nPrototype\n\nvoid aws_tls_ctx_options_set_tls_cipher_preference( struct aws_tls_ctx_options *options, enum aws_tls_cipher_pref cipher_pref);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_options_set_verify_peer-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_options_set_verify_peer","text":"aws_tls_ctx_options_set_verify_peer(options, verify_peer)\n\nEnables or disables x.509 validation. Disable this only for testing. To enable mutual TLS in server mode, set verify_peer to true.\n\nPrototype\n\nvoid aws_tls_ctx_options_set_verify_peer(struct aws_tls_ctx_options *options, bool verify_peer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_ctx_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_ctx_release","text":"aws_tls_ctx_release(ctx)\n\nDecrements a tls context's ref count. When the ref count drops to zero, the object will be destroyed.\n\nPrototype\n\nvoid aws_tls_ctx_release(struct aws_tls_ctx *ctx);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_handler_protocol-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_handler_protocol","text":"aws_tls_handler_protocol(handler)\n\nReturns a byte buffer by copy of the negotiated protocols. If there is no agreed upon protocol, len will be 0 and buffer will be NULL.\n\nPrototype\n\nstruct aws_byte_buf aws_tls_handler_protocol(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_handler_server_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_handler_server_name","text":"aws_tls_handler_server_name(handler)\n\nClient mode only. This is the server name that was used for SNI and host name validation.\n\nPrototype\n\nstruct aws_byte_buf aws_tls_handler_server_name(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_handler_write-NTuple{5, Any}","page":"Home","title":"LibAWSCRT.aws_tls_handler_write","text":"aws_tls_handler_write(handler, slot, buf, on_write_completed, completion_user_data)\n\nNot necessary if you are installing more handlers into the channel, but if you just want to have TLS for arbitrary data and use the channel handler directly, this function allows you to write data to the channel and have it encrypted.\n\nPrototype\n\nint aws_tls_handler_write( struct aws_channel_handler *handler, struct aws_channel_slot *slot, struct aws_byte_buf *buf, aws_channel_on_message_write_completed_fn *on_write_completed, void *completion_user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_hash_algorithm_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_hash_algorithm_str","text":"aws_tls_hash_algorithm_str(hash)\n\nGiven enum, return string like: AWS_TLS_HASH_SHA256 -> \"SHA256\"\n\nPrototype\n\nconst char *aws_tls_hash_algorithm_str(enum aws_tls_hash_algorithm hash);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_is_alpn_available-Tuple{}","page":"Home","title":"LibAWSCRT.aws_tls_is_alpn_available","text":"aws_tls_is_alpn_available()\n\nReturns true if alpn is available in the underlying tls implementation. This function should always be called before setting an alpn list.\n\nPrototype\n\nbool aws_tls_is_alpn_available(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_is_cipher_pref_supported-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_is_cipher_pref_supported","text":"aws_tls_is_cipher_pref_supported(cipher_pref)\n\nReturns true if this Cipher Preference is available in the underlying TLS implementation. This function should always be called before setting a Cipher Preference\n\nPrototype\n\nbool aws_tls_is_cipher_pref_supported(enum aws_tls_cipher_pref cipher_pref);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_complete-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_complete","text":"aws_tls_key_operation_complete(operation, output)\n\nComplete a successful TLS private key operation by providing its output. The output is copied into the TLS connection. The operation is freed by this call.\n\nYou MUST call this or aws_tls_key_operation_complete_with_error(). Failure to do so will stall the TLS connection indefinitely and leak memory.\n\nPrototype\n\nvoid aws_tls_key_operation_complete(struct aws_tls_key_operation *operation, struct aws_byte_cursor output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_complete_with_error-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_complete_with_error","text":"aws_tls_key_operation_complete_with_error(operation, error_code)\n\nComplete an failed TLS private key operation. The TLS connection will fail. The operation is freed by this call.\n\nYou MUST call this or aws_tls_key_operation_complete(). Failure to do so will stall the TLS connection indefinitely and leak memory.\n\nPrototype\n\nvoid aws_tls_key_operation_complete_with_error(struct aws_tls_key_operation *operation, int error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_get_digest_algorithm-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_get_digest_algorithm","text":"aws_tls_key_operation_get_digest_algorithm(operation)\n\nReturns the algorithm the operation digest is signed with. If the implementation does not support the digest algorithm, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_hash_algorithm aws_tls_key_operation_get_digest_algorithm(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_get_input-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_get_input","text":"aws_tls_key_operation_get_input(operation)\n\nReturns the input data that needs to be operated on by the custom key operation.\n\nPrototype\n\nstruct aws_byte_cursor aws_tls_key_operation_get_input(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_get_signature_algorithm-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_get_signature_algorithm","text":"aws_tls_key_operation_get_signature_algorithm(operation)\n\nReturns the algorithm the operation is expected to be operated with. If the implementation does not support the signature algorithm, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_signature_algorithm aws_tls_key_operation_get_signature_algorithm( const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_get_type-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_get_type","text":"aws_tls_key_operation_get_type(operation)\n\nReturns the type of operation that needs to be performed by the custom key operation. If the implementation cannot perform the operation, use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection.\n\nPrototype\n\nenum aws_tls_key_operation_type aws_tls_key_operation_get_type(const struct aws_tls_key_operation *operation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_key_operation_type_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_key_operation_type_str","text":"aws_tls_key_operation_type_str(operation_type)\n\nGiven enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\"\n\nPrototype\n\nconst char *aws_tls_key_operation_type_str(enum aws_tls_key_operation_type operation_type);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_server_ctx_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_server_ctx_new","text":"aws_tls_server_ctx_new(alloc, options)\n\nCreates a new server ctx. This ctx can be used for the lifetime of the application assuming you want the same options for every incoming connection. Options will be copied.\n\nPrototype\n\nstruct aws_tls_ctx *aws_tls_server_ctx_new( struct aws_allocator *alloc, const struct aws_tls_ctx_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_server_handler_new-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_tls_server_handler_new","text":"aws_tls_server_handler_new(allocator, options, slot)\n\nCreates a new tls channel handler in server mode. Options will be copied. You must wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing application data.\n\nPrototype\n\nstruct aws_channel_handler *aws_tls_server_handler_new( struct aws_allocator *allocator, struct aws_tls_connection_options *options, struct aws_channel_slot *slot);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_tls_signature_algorithm_str-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_tls_signature_algorithm_str","text":"aws_tls_signature_algorithm_str(signature)\n\nGiven enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\"\n\nPrototype\n\nconst char *aws_tls_signature_algorithm_str(enum aws_tls_signature_algorithm signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_translate_and_raise_io_error-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_translate_and_raise_io_error","text":"aws_translate_and_raise_io_error(error_no)\n\nConvert a c library io error into an aws error, and raise it. If no conversion is found, AWS_ERROR_SYS_CALL_FAILURE is raised. Always returns AWS_OP_ERR.\n\nPrototype\n\nint aws_translate_and_raise_io_error(int error_no);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_trim_padded_sigv4a_signature-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_trim_padded_sigv4a_signature","text":"aws_trim_padded_sigv4a_signature(signature)\n\nRemoves any padding added to the end of a sigv4a signature. Signature must be hex-encoded.\n\nParameters\n\nsignature: signature to remove padding from\n\nReturns\n\ncursor that ranges over only the valid hex encoding of the sigv4a signature\n\nPrototype\n\nstruct aws_byte_cursor aws_trim_padded_sigv4a_signature(struct aws_byte_cursor signature);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_unregister_error_info-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_unregister_error_info","text":"aws_unregister_error_info(error_info)\n\nPrototype\n\nvoid aws_unregister_error_info(const struct aws_error_info_list *error_info);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_unregister_log_subject_info_list-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_unregister_log_subject_info_list","text":"aws_unregister_log_subject_info_list(log_subject_list)\n\nDisconnects log subject strings with log subject integer values\n\nPrototype\n\nvoid aws_unregister_log_subject_info_list(struct aws_log_subject_info_list *log_subject_list);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_unset_environment_value-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_unset_environment_value","text":"aws_unset_environment_value(variable_name)\n\nPrototype\n\nint aws_unset_environment_value(const struct aws_string *variable_name);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_authority-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_authority","text":"aws_uri_authority(uri)\n\nReturns the authority portion of the uri (host[:port]). If it was not present, this was a request uri. In that case, the value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_authority(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_clean_up-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_clean_up","text":"aws_uri_clean_up(uri)\n\nPrototype\n\nvoid aws_uri_clean_up(struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_host_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_host_name","text":"aws_uri_host_name(uri)\n\nReturns the 'host_name' portion of the authority. If no authority was present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_host_name(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_init_from_builder_options-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_uri_init_from_builder_options","text":"aws_uri_init_from_builder_options(uri, allocator, options)\n\nInitializes uri to values specified in options. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure. After calling this function, the parts can be accessed.\n\nPrototype\n\nint aws_uri_init_from_builder_options( struct aws_uri *uri, struct aws_allocator *allocator, struct aws_uri_builder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_init_parse-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_uri_init_parse","text":"aws_uri_init_parse(uri, allocator, uri_str)\n\nParses 'uri_str' and initializes uri. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure. After calling this function, the parts can be accessed.\n\nPrototype\n\nint aws_uri_init_parse( struct aws_uri *uri, struct aws_allocator *allocator, const struct aws_byte_cursor *uri_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_path-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_path","text":"aws_uri_path(uri)\n\nReturns the path portion of the uri, including any leading '/'. If not present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_path(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_path_and_query-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_path_and_query","text":"aws_uri_path_and_query(uri)\n\nReturns the path and query portion of the uri (i.e., the thing you send across the wire).\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_path_and_query(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_port-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_port","text":"aws_uri_port(uri)\n\nReturns the port portion of the authority if it was present, otherwise, returns 0. If this is 0, it is the users job to determine the correct port based on scheme and protocol.\n\nPrototype\n\nuint16_t aws_uri_port(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_query_string-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_query_string","text":"aws_uri_query_string(uri)\n\nReturns the query string portion of the uri, minus the '?'. If not present, this value will be empty.\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_query_string(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_query_string_next_param-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_uri_query_string_next_param","text":"aws_uri_query_string_next_param(uri, param)\n\nFor iterating over the params in the uri query string. param is an in/out argument used to track progress, it MUST be zeroed out to start. If true is returned, param contains the value of the next param. If false is returned, there are no further params.\n\nEdge cases: 1) Entries without '=' sign are treated as having a key and no value. Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\nBlank entries are skipped. Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\"\n\nPrototype\n\nbool aws_uri_query_string_next_param(const struct aws_uri *uri, struct aws_uri_param *param);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_query_string_params-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_uri_query_string_params","text":"aws_uri_query_string_params(uri, out_params)\n\nParses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param. The user is also responsible for cleaning up out_params when finished.\n\nPrototype\n\nint aws_uri_query_string_params(const struct aws_uri *uri, struct aws_array_list *out_params);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uri_scheme-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uri_scheme","text":"aws_uri_scheme(uri)\n\nReturns the scheme portion of the uri (e.g. http, https, ftp, ftps, etc...). If the scheme was not present in the uri, the returned value will be empty. It is the users job to determine the appropriate defaults if this field is empty, based on protocol, port, etc...\n\nPrototype\n\nconst struct aws_byte_cursor *aws_uri_scheme(const struct aws_uri *uri);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_utf8_decoder_destroy-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_utf8_decoder_destroy","text":"aws_utf8_decoder_destroy(decoder)\n\nPrototype\n\nvoid aws_utf8_decoder_destroy(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_utf8_decoder_finalize-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_utf8_decoder_finalize","text":"aws_utf8_decoder_finalize(decoder)\n\nTell the decoder that you've reached the end of your text. Raises AWS_ERROR_INVALID_UTF8 if the text did not end with a complete UTF8 codepoint. This also resets the decoder.\n\nPrototype\n\nint aws_utf8_decoder_finalize(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_utf8_decoder_new-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_utf8_decoder_new","text":"aws_utf8_decoder_new(allocator, options)\n\nCreate a UTF8/ASCII decoder, which can process text incrementally as you receive it. Text is always validated according to RFC-3629 (you may perform additional validation in the on_codepoint callback). The text does not need to begin with a UTF8 BOM. To decode text all at once, simply use aws_decode_utf8().\n\nFeed bytes into the decoder with aws_utf8_decoder_update(), and call aws_utf8_decoder_finalize() when the text is complete.\n\nParameters\n\nallocator: Allocator\noptions: Options for decoder. If NULL is passed, the text is simply validated.\n\nPrototype\n\nstruct aws_utf8_decoder *aws_utf8_decoder_new( struct aws_allocator *allocator, const struct aws_utf8_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_utf8_decoder_reset-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_utf8_decoder_reset","text":"aws_utf8_decoder_reset(decoder)\n\nPrototype\n\nvoid aws_utf8_decoder_reset(struct aws_utf8_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_utf8_decoder_update-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_utf8_decoder_update","text":"aws_utf8_decoder_update(decoder, bytes)\n\nUpdate the decoder with more bytes of text. The on_codepoint callback will be invoked for each codepoint encountered. Raises an error if invalid UTF8 is encountered or the on_codepoint callback reports an error.\n\nNote: You must call aws_utf8_decoder_finalize() when the text is 100% complete, to ensure the input was completely valid.\n\nPrototype\n\nint aws_utf8_decoder_update(struct aws_utf8_decoder *decoder, struct aws_byte_cursor bytes);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uuid_equals-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_uuid_equals","text":"aws_uuid_equals(a, b)\n\nPrototype\n\nbool aws_uuid_equals(const struct aws_uuid *a, const struct aws_uuid *b);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uuid_init-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_uuid_init","text":"aws_uuid_init(uuid)\n\nPrototype\n\nint aws_uuid_init(struct aws_uuid *uuid);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uuid_init_from_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_uuid_init_from_str","text":"aws_uuid_init_from_str(uuid, uuid_str)\n\nPrototype\n\nint aws_uuid_init_from_str(struct aws_uuid *uuid, const struct aws_byte_cursor *uuid_str);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_uuid_to_str-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_uuid_to_str","text":"aws_uuid_to_str(uuid, output)\n\nPrototype\n\nint aws_uuid_to_str(const struct aws_uuid *uuid, struct aws_byte_buf *output);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_validate_aws_signing_config_aws-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_validate_aws_signing_config_aws","text":"aws_validate_aws_signing_config_aws(config)\n\nChecks a signing configuration for invalid settings combinations.\n\nParameters\n\nconfig: signing configuration to validate\n\nReturns\n\nAWS_OP_SUCCESS if the configuration is valid, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_validate_aws_signing_config_aws(const struct aws_signing_config_aws *config);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_validate_v4a_authorization_value-NTuple{4, Any}","page":"Home","title":"LibAWSCRT.aws_validate_v4a_authorization_value","text":"aws_validate_v4a_authorization_value(allocator, ecc_key, string_to_sign_cursor, signature_value_cursor)\n\nAnother helper function to check a computed sigv4a signature.\n\nPrototype\n\nint aws_validate_v4a_authorization_value( struct aws_allocator *allocator, struct aws_ecc_key_pair *ecc_key, struct aws_byte_cursor string_to_sign_cursor, struct aws_byte_cursor signature_value_cursor);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_verify_sigv4a_signing-NTuple{7, Any}","page":"Home","title":"LibAWSCRT.aws_verify_sigv4a_signing","text":"aws_verify_sigv4a_signing(allocator, signable, base_config, expected_canonical_request_cursor, signature_cursor, ecc_key_pub_x, ecc_key_pub_y)\n\nTest-only API used for cross-library signing verification tests\n\nVerifies: (1) The canonical request generated during sigv4a signing of the request matches what is passed in (2) The signature passed in is a valid ECDSA signature of the hashed string-to-sign derived from the canonical request\n\nParameters\n\nallocator: memory allocator to use throughout the signing verification process\nsignable: the thing to be signed. See signable.h for common constructors for signables that wrap different types.\nbase_config: pointer to a signing configuration, currently this must be of type aws_signing_config_aws\nexpected_canonical_request_cursor: expected result when building the canonical request\nsignature_cursor: the actual signature computed from a previous signing of the signable\necc_key_pub_x: the x coordinate of the public part of the ecc key to verify the signature\necc_key_pub_y: the y coordinate of the public part of the ecc key to verify the signature\n\nReturns\n\nAWS_OP_SUCCESS if the signing attempt was initiated successfully, AWS_OP_ERR otherwise\n\nPrototype\n\nint aws_verify_sigv4a_signing( struct aws_allocator *allocator, const struct aws_signable *signable, const struct aws_signing_config_base *base_config, struct aws_byte_cursor expected_canonical_request_cursor, struct aws_byte_cursor signature_cursor, struct aws_byte_cursor ecc_key_pub_x, struct aws_byte_cursor ecc_key_pub_y);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_acquire-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_acquire","text":"aws_websocket_acquire(websocket)\n\nIncrement the websocket's ref-count, preventing it from being destroyed.\n\nReturns\n\nAlways returns the same pointer that is passed in.\n\nPrototype\n\nstruct aws_websocket *aws_websocket_acquire(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_client_connect-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_client_connect","text":"aws_websocket_client_connect(options)\n\nAsynchronously establish a client websocket connection. The on_connection_setup callback is invoked when the operation has finished creating a connection, or failed.\n\nPrototype\n\nint aws_websocket_client_connect(const struct aws_websocket_client_connection_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_close-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_websocket_close","text":"aws_websocket_close(websocket, free_scarce_resources_immediately)\n\nClose the websocket connection. It is safe to call this, even if the connection is already closed or closing. The websocket will attempt to send a CLOSE frame during normal shutdown. If free_scarce_resources_immediately is true, the connection will be torn down as quickly as possible. This function may be called from any thread.\n\nPrototype\n\nvoid aws_websocket_close(struct aws_websocket *websocket, bool free_scarce_resources_immediately);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_convert_to_midchannel_handler-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_convert_to_midchannel_handler","text":"aws_websocket_convert_to_midchannel_handler(websocket)\n\nConvert the websocket into a mid-channel handler. The websocket will stop being usable via its public API and become just another handler in the channel. The caller will likely install a channel handler to the right. This must not be called in the middle of an incoming frame (between \"frame begin\" and \"frame complete\" callbacks). This MUST be called from the websocket's thread.\n\nIf successful: - Other than aws_websocket_release(), all calls to aws_websocket_x() functions are ignored. - The websocket will no longer invoke any \"incoming frame\" callbacks. - aws_io_messages written by a downstream handler will be wrapped in binary data frames and sent upstream. The data may be split/combined as it is sent along. - aws_io_messages read from upstream handlers will be scanned for binary data frames. The payloads of these frames will be sent downstream. The payloads may be split/combined as they are sent along. - An incoming close frame will automatically result in channel-shutdown. - aws_websocket_release() must still be called or the websocket and its channel will never be cleaned up. - The websocket will still invoke its \"on connection shutdown\" callback when channel shutdown completes.\n\nIf unsuccessful, NULL is returned and the websocket is unchanged.\n\nPrototype\n\nint aws_websocket_convert_to_midchannel_handler(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_get_channel-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_get_channel","text":"aws_websocket_get_channel(websocket)\n\nReturns the websocket's underlying I/O channel.\n\nPrototype\n\nstruct aws_channel *aws_websocket_get_channel(const struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_websocket_increment_read_window","text":"aws_websocket_increment_read_window(websocket, size)\n\nManually increment the read window to keep frames flowing.\n\nIf the websocket was created with manual_window_management set true, then whenever the read window reaches 0 you will stop receiving data. The websocket's initial_window_size determines the starting size of the read window. The read window shrinks as you receive the payload from \"data\" frames (TEXT, BINARY, and CONTINUATION). Use aws_websocket_increment_read_window() to increment the window again and keep frames flowing. Maintain a larger window to keep up high throughput. You only need to worry about the payload from \"data\" frames. The websocket automatically increments the window to account for any other incoming bytes, including other parts of a frame (opcode, payload-length, etc) and the payload of other frame types (PING, PONG, CLOSE).\n\nIf the websocket was created with manual_window_management set false, this function does nothing.\n\nThis function may be called from any thread.\n\nPrototype\n\nvoid aws_websocket_increment_read_window(struct aws_websocket *websocket, size_t size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_is_data_frame-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_is_data_frame","text":"aws_websocket_is_data_frame(opcode)\n\nReturn true if opcode is for a data frame, false if opcode if for a control frame.\n\nPrototype\n\nbool aws_websocket_is_data_frame(uint8_t opcode);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_random_handshake_key-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_random_handshake_key","text":"aws_websocket_random_handshake_key(dst)\n\nGenerate value for a Sec-WebSocket-Key header and write it into dst buffer. The buffer should have at least AWS_WEBSOCKET_MAX_HANDSHAKE_KEY_LENGTH space available.\n\nThis value is the base64 encoding of a random 16-byte value. RFC-6455 Section 4.1\n\nPrototype\n\nint aws_websocket_random_handshake_key(struct aws_byte_buf *dst);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_release-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_websocket_release","text":"aws_websocket_release(websocket)\n\nDecrement the websocket's ref-count. When the ref-count reaches zero, the connection will shut down, if it hasn't already. Users must release the websocket when they are done with it. The websocket's memory cannot be reclaimed until this is done. Callbacks may continue firing after this is called, with \"shutdown\" being the final callback. This function may be called from any thread.\n\nIt is safe to pass NULL, nothing will happen.\n\nPrototype\n\nvoid aws_websocket_release(struct aws_websocket *websocket);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_websocket_send_frame-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_websocket_send_frame","text":"aws_websocket_send_frame(websocket, options)\n\nSend a websocket frame. The options struct is copied. A callback will be invoked when the operation completes. This function may be called from any thread.\n\nPrototype\n\nint aws_websocket_send_frame(struct aws_websocket *websocket, const struct aws_websocket_send_frame_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_write_u16-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_write_u16","text":"aws_write_u16(value, buffer)\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u16(uint16_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_write_u24-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_write_u24","text":"aws_write_u24(value, buffer)\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u24(uint32_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_write_u32-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_write_u32","text":"aws_write_u32(value, buffer)\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u32(uint32_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_write_u64-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_write_u64","text":"aws_write_u64(value, buffer)\n\nPrototype\n\nAWS_STATIC_IMPL void aws_write_u64(uint64_t value, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_node_as_body-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_xml_node_as_body","text":"aws_xml_node_as_body(node, out_body)\n\nWrites the contents of the body of node into out_body. out_body is an output parameter in this case. Upon success, out_body will contain the body of the node.\n\nPrototype\n\nint aws_xml_node_as_body(struct aws_xml_node *node, struct aws_byte_cursor *out_body);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_node_get_attribute-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_xml_node_get_attribute","text":"aws_xml_node_get_attribute(node, attribute_index)\n\nPrototype\n\nstruct aws_xml_attribute aws_xml_node_get_attribute(const struct aws_xml_node *node, size_t attribute_index);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_node_get_name-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_xml_node_get_name","text":"aws_xml_node_get_name(node)\n\nPrototype\n\nstruct aws_byte_cursor aws_xml_node_get_name(const struct aws_xml_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_node_get_num_attributes-Tuple{Any}","page":"Home","title":"LibAWSCRT.aws_xml_node_get_num_attributes","text":"aws_xml_node_get_num_attributes(node)\n\nPrototype\n\nsize_t aws_xml_node_get_num_attributes(const struct aws_xml_node *node);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_node_traverse-Tuple{Any, Any, Any}","page":"Home","title":"LibAWSCRT.aws_xml_node_traverse","text":"aws_xml_node_traverse(node, on_node_encountered, user_data)\n\nTraverse node and invoke on_node_encountered when a nested node is encountered.\n\nPrototype\n\nint aws_xml_node_traverse( struct aws_xml_node *node, aws_xml_parser_on_node_encountered_fn *on_node_encountered, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAWSCRT.aws_xml_parse-Tuple{Any, Any}","page":"Home","title":"LibAWSCRT.aws_xml_parse","text":"aws_xml_parse(allocator, options)\n\nParse an XML document. WARNING: This is not a public API. It is only intended for use within the aws-c libraries.\n\nPrototype\n\nint aws_xml_parse(struct aws_allocator *allocator, const struct aws_xml_parser_options *options);\n\n\n\n\n\n","category":"method"}]
}
